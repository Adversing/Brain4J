// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: org.brain4j.core.importing.onnx.proto
// Protobuf Java Version: 4.31.1

package org.brain4j.core.importing.onnx;

@com.google.protobuf.Generated
public final class ProtoOnnx {
    private ProtoOnnx() {}
    static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
            com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
            /* major= */ 4,
            /* minor= */ 31,
            /* patch= */ 1,
            /* suffix= */ "",
            ProtoOnnx.class.getName());
    }
    public static void registerAllExtensions(
        com.google.protobuf.ExtensionRegistryLite registry) {
    }
    
    public static void registerAllExtensions(
        com.google.protobuf.ExtensionRegistry registry) {
        registerAllExtensions(
            (com.google.protobuf.ExtensionRegistryLite) registry);
    }
    /**
     * <pre>
     * Versioning
     *
     * ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
     *
     * To be compatible with both proto2 and proto3, we will use a version number
     * that is not defined by the default value but an explicit enum number.
     * </pre>
     *
     * Protobuf enum {@code org.brain4j.core.importing.onnx.Version}
     */
    public enum Version
        implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         * proto3 requires the first enum value to be zero.
         * We add this just to appease the compiler.
         * </pre>
         *
         * <code>_START_VERSION = 0;</code>
         */
        _START_VERSION(0),
        /**
         * <pre>
         * The version field is always serialized and we will use it to store the
         * version that the  graph is generated from. This helps us set up version
         * control.
         * For the IR, we are using simple numbers starting with 0x00000001,
         * which was the version we published on Oct 10, 2017.
         * </pre>
         *
         * <code>IR_VERSION_2017_10_10 = 1;</code>
         */
        IR_VERSION_2017_10_10(1),
        /**
         * <pre>
         * IR_VERSION 2 published on Oct 30, 2017
         * - Added type discriminator to AttributeProto to support proto3 users
         * </pre>
         *
         * <code>IR_VERSION_2017_10_30 = 2;</code>
         */
        IR_VERSION_2017_10_30(2),
        /**
         * <pre>
         * IR VERSION 3 published on Nov 3, 2017
         * - For operator versioning:
         * - Added new message OperatorSetIdProto
         * - Added opset_import in ModelProto
         * - For vendor extensions, added domain in NodeProto
         * </pre>
         *
         * <code>IR_VERSION_2017_11_3 = 3;</code>
         */
        IR_VERSION_2017_11_3(3),
        /**
         * <pre>
         * IR VERSION 4 published on Jan 22, 2019
         * - Relax constraint that initializers should be a subset of graph inputs
         * - Add type BFLOAT16
         * </pre>
         *
         * <code>IR_VERSION_2019_1_22 = 4;</code>
         */
        IR_VERSION_2019_1_22(4),
        /**
         * <pre>
         * IR VERSION 5 published on March 18, 2019
         * - Add message TensorAnnotation.
         * - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
         * </pre>
         *
         * <code>IR_VERSION_2019_3_18 = 5;</code>
         */
        IR_VERSION_2019_3_18(5),
        /**
         * <pre>
         * IR VERSION 6 published on Sep 19, 2019
         * - Add support for sparse tensor constants stored in model.
         * - Add message SparseTensorProto
         * - Add sparse initializers
         * </pre>
         *
         * <code>IR_VERSION_2019_9_19 = 6;</code>
         */
        IR_VERSION_2019_9_19(6),
        /**
         * <pre>
         * IR VERSION 7 published on May 8, 2020
         * - Add support to allow function body graph to rely on multiple external operator sets.
         * - Add a list to promote inference graph's initializers to global and
         * mutable variables. Global variables are visible in all graphs of the
         * stored models.
         * - Add message TrainingInfoProto to store initialization
         * method and training algorithm. The execution of TrainingInfoProto
         * can modify the values of mutable variables.
         * - Implicitly add inference graph into each TrainingInfoProto's algorithm.
         * </pre>
         *
         * <code>IR_VERSION_2020_5_8 = 7;</code>
         */
        IR_VERSION_2020_5_8(7),
        /**
         * <pre>
         * IR VERSION 8 published on July 30, 2021
         * Introduce TypeProto.SparseTensor
         * Introduce TypeProto.Optional
         * Added a list of FunctionProtos local to the model
         * Deprecated since_version and operator status from FunctionProto
         * </pre>
         *
         * <code>IR_VERSION_2021_7_30 = 8;</code>
         */
        IR_VERSION_2021_7_30(8),
        /**
         * <pre>
         * IR VERSION 9 published on May 5, 2023
         * Added AttributeProto to FunctionProto so that default attribute values can be set.
         * Added FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ.
         * </pre>
         *
         * <code>IR_VERSION_2023_5_5 = 9;</code>
         */
        IR_VERSION_2023_5_5(9),
        /**
         * <pre>
         * IR VERSION 10 published on March 25, 2024
         * Added UINT4, INT4, overload field for functions and metadata_props on multiple proto definitions.
         * </pre>
         *
         * <code>IR_VERSION_2024_3_25 = 10;</code>
         */
        IR_VERSION_2024_3_25(10),
        /**
         * <pre>
         * IR VERSION 11 published on May 12, 2025
         * Added FLOAT4E2M1, multi-device protobuf classes.
         * </pre>
         *
         * <code>IR_VERSION = 11;</code>
         */
        IR_VERSION(11),
        ;
        
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                Version.class.getName());
        }
        /**
         * <pre>
         * proto3 requires the first enum value to be zero.
         * We add this just to appease the compiler.
         * </pre>
         *
         * <code>_START_VERSION = 0;</code>
         */
        public static final int _START_VERSION_VALUE = 0;
        /**
         * <pre>
         * The version field is always serialized and we will use it to store the
         * version that the  graph is generated from. This helps us set up version
         * control.
         * For the IR, we are using simple numbers starting with 0x00000001,
         * which was the version we published on Oct 10, 2017.
         * </pre>
         *
         * <code>IR_VERSION_2017_10_10 = 1;</code>
         */
        public static final int IR_VERSION_2017_10_10_VALUE = 1;
        /**
         * <pre>
         * IR_VERSION 2 published on Oct 30, 2017
         * - Added type discriminator to AttributeProto to support proto3 users
         * </pre>
         *
         * <code>IR_VERSION_2017_10_30 = 2;</code>
         */
        public static final int IR_VERSION_2017_10_30_VALUE = 2;
        /**
         * <pre>
         * IR VERSION 3 published on Nov 3, 2017
         * - For operator versioning:
         * - Added new message OperatorSetIdProto
         * - Added opset_import in ModelProto
         * - For vendor extensions, added domain in NodeProto
         * </pre>
         *
         * <code>IR_VERSION_2017_11_3 = 3;</code>
         */
        public static final int IR_VERSION_2017_11_3_VALUE = 3;
        /**
         * <pre>w
         * IR VERSION 4 published on Jan 22, 2019
         * - Relax constraint that initializers should be a subset of graph inputs
         * - Add type BFLOAT16
         * </pre>
         *
         * <code>IR_VERSION_2019_1_22 = 4;</code>
         */
        public static final int IR_VERSION_2019_1_22_VALUE = 4;
        /**
         * <pre>
         * IR VERSION 5 published on March 18, 2019
         * - Add message TensorAnnotation.
         * - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
         * </pre>
         *
         * <code>IR_VERSION_2019_3_18 = 5;</code>
         */
        public static final int IR_VERSION_2019_3_18_VALUE = 5;
        /**
         * <pre>
         * IR VERSION 6 published on Sep 19, 2019
         * - Add support for sparse tensor constants stored in model.
         * - Add message SparseTensorProto
         * - Add sparse initializers
         * </pre>
         *
         * <code>IR_VERSION_2019_9_19 = 6;</code>
         */
        public static final int IR_VERSION_2019_9_19_VALUE = 6;
        /**
         * <pre>
         * IR VERSION 7 published on May 8, 2020
         * - Add support to allow function body graph to rely on multiple external operator sets.
         * - Add a list to promote inference graph's initializers to global and
         * mutable variables. Global variables are visible in all graphs of the
         * stored models.
         * - Add message TrainingInfoProto to store initialization
         * method and training algorithm. The execution of TrainingInfoProto
         * can modify the values of mutable variables.
         * - Implicitly add inference graph into each TrainingInfoProto's algorithm.
         * </pre>
         *
         * <code>IR_VERSION_2020_5_8 = 7;</code>
         */
        public static final int IR_VERSION_2020_5_8_VALUE = 7;
        /**
         * <pre>
         * IR VERSION 8 published on July 30, 2021
         * Introduce TypeProto.SparseTensor
         * Introduce TypeProto.Optional
         * Added a list of FunctionProtos local to the model
         * Deprecated since_version and operator status from FunctionProto
         * </pre>
         *
         * <code>IR_VERSION_2021_7_30 = 8;</code>
         */
        public static final int IR_VERSION_2021_7_30_VALUE = 8;
        /**
         * <pre>
         * IR VERSION 9 published on May 5, 2023
         * Added AttributeProto to FunctionProto so that default attribute values can be set.
         * Added FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ.
         * </pre>
         *
         * <code>IR_VERSION_2023_5_5 = 9;</code>
         */
        public static final int IR_VERSION_2023_5_5_VALUE = 9;
        /**
         * <pre>
         * IR VERSION 10 published on March 25, 2024
         * Added UINT4, INT4, overload field for functions and metadata_props on multiple proto definitions.
         * </pre>
         *
         * <code>IR_VERSION_2024_3_25 = 10;</code>
         */
        public static final int IR_VERSION_2024_3_25_VALUE = 10;
        /**
         * <pre>
         * IR VERSION 11 published on May 12, 2025
         * Added FLOAT4E2M1, multi-device protobuf classes.
         * </pre>
         *
         * <code>IR_VERSION = 11;</code>
         */
        public static final int IR_VERSION_VALUE = 11;
        
        
        public final int getNumber() {
            return value;
        }
        
        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Version valueOf(int value) {
            return forNumber(value);
        }
        
        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static Version forNumber(int value) {
            switch (value) {
                case 0: return _START_VERSION;
                case 1: return IR_VERSION_2017_10_10;
                case 2: return IR_VERSION_2017_10_30;
                case 3: return IR_VERSION_2017_11_3;
                case 4: return IR_VERSION_2019_1_22;
                case 5: return IR_VERSION_2019_3_18;
                case 6: return IR_VERSION_2019_9_19;
                case 7: return IR_VERSION_2020_5_8;
                case 8: return IR_VERSION_2021_7_30;
                case 9: return IR_VERSION_2023_5_5;
                case 10: return IR_VERSION_2024_3_25;
                case 11: return IR_VERSION;
                default: return null;
            }
        }
        
        public static com.google.protobuf.Internal.EnumLiteMap<Version>
        internalGetValueMap() {
            return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Version> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Version>() {
                public Version findValueByNumber(int number) {
                    return Version.forNumber(number);
                }
            };
        
        public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
            return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
            return getDescriptor();
        }
        public static com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
            return ProtoOnnx.getDescriptor().getEnumTypes().get(0);
        }
        
        private static final Version[] VALUES = values();
        
        public static Version valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
            if (desc.getType() != getDescriptor()) {
                throw new java.lang.IllegalArgumentException(
                    "EnumValueDescriptor is not for this type.");
            }
            return VALUES[desc.getIndex()];
        }
        
        private final int value;
        
        private Version(int value) {
            this.value = value;
        }
        
        // @@protoc_insertion_point(enum_scope:org.brain4j.core.importing.onnx.Version)
    }
    
    /**
     * <pre>
     * Operator/function status.
     * </pre>
     *
     * Protobuf enum {@code org.brain4j.core.importing.onnx.OperatorStatus}
     */
    public enum OperatorStatus
        implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>EXPERIMENTAL = 0;</code>
         */
        EXPERIMENTAL(0),
        /**
         * <code>STABLE = 1;</code>
         */
        STABLE(1),
        ;
        
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                OperatorStatus.class.getName());
        }
        /**
         * <code>EXPERIMENTAL = 0;</code>
         */
        public static final int EXPERIMENTAL_VALUE = 0;
        /**
         * <code>STABLE = 1;</code>
         */
        public static final int STABLE_VALUE = 1;
        
        
        public final int getNumber() {
            return value;
        }
        
        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static OperatorStatus valueOf(int value) {
            return forNumber(value);
        }
        
        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static OperatorStatus forNumber(int value) {
            switch (value) {
                case 0: return EXPERIMENTAL;
                case 1: return STABLE;
                default: return null;
            }
        }
        
        public static com.google.protobuf.Internal.EnumLiteMap<OperatorStatus>
        internalGetValueMap() {
            return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            OperatorStatus> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<OperatorStatus>() {
                public OperatorStatus findValueByNumber(int number) {
                    return OperatorStatus.forNumber(number);
                }
            };
        
        public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
            return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
            return getDescriptor();
        }
        public static com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
            return ProtoOnnx.getDescriptor().getEnumTypes().get(1);
        }
        
        private static final OperatorStatus[] VALUES = values();
        
        public static OperatorStatus valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
            if (desc.getType() != getDescriptor()) {
                throw new java.lang.IllegalArgumentException(
                    "EnumValueDescriptor is not for this type.");
            }
            return VALUES[desc.getIndex()];
        }
        
        private final int value;
        
        private OperatorStatus(int value) {
            this.value = value;
        }
        
        // @@protoc_insertion_point(enum_scope:org.brain4j.core.importing.onnx.OperatorStatus)
    }
    
    public interface AttributeProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.AttributeProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();
        
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return Whether the refAttrName field is set.
         */
        boolean hasRefAttrName();
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return The refAttrName.
         */
        java.lang.String getRefAttrName();
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return The bytes for refAttrName.
         */
        com.google.protobuf.ByteString
        getRefAttrNameBytes();
        
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();
        
        /**
         * <pre>
         * The type field MUST be present for this version of the IR.
         * For 0.0.1 versions of the IR, this field was not defined, and
         * implementations needed to use has_field heuristics to determine
         * which value field was in use.  For IR_VERSION 0.0.2 or later, this
         * field MUST be set and match the f|i|s|t|... field in use.  This
         * change was made to accommodate proto3 implementations.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.AttributeProto.AttributeType type = 20;</code>
         * @return Whether the type field is set.
         */
        boolean hasType();
        /**
         * <pre>
         * The type field MUST be present for this version of the IR.
         * For 0.0.1 versions of the IR, this field was not defined, and
         * implementations needed to use has_field heuristics to determine
         * which value field was in use.  For IR_VERSION 0.0.2 or later, this
         * field MUST be set and match the f|i|s|t|... field in use.  This
         * change was made to accommodate proto3 implementations.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.AttributeProto.AttributeType type = 20;</code>
         * @return The type.
         */
        ProtoOnnx.AttributeProto.AttributeType getType();
        
        /**
         * <pre>
         * Exactly ONE of the following fields must be present for this version of the IR
         * </pre>
         *
         * <code>optional float f = 2;</code>
         * @return Whether the f field is set.
         */
        boolean hasF();
        /**
         * <pre>
         * Exactly ONE of the following fields must be present for this version of the IR
         * </pre>
         *
         * <code>optional float f = 2;</code>
         * @return The f.
         */
        float getF();
        
        /**
         * <pre>
         * int
         * </pre>
         *
         * <code>optional int64 i = 3;</code>
         * @return Whether the i field is set.
         */
        boolean hasI();
        /**
         * <pre>
         * int
         * </pre>
         *
         * <code>optional int64 i = 3;</code>
         * @return The i.
         */
        long getI();
        
        /**
         * <pre>
         * UTF-8 string
         * </pre>
         *
         * <code>optional bytes s = 4;</code>
         * @return Whether the s field is set.
         */
        boolean hasS();
        /**
         * <pre>
         * UTF-8 string
         * </pre>
         *
         * <code>optional bytes s = 4;</code>
         * @return The s.
         */
        com.google.protobuf.ByteString getS();
        
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
         * @return Whether the t field is set.
         */
        boolean hasT();
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
         * @return The t.
         */
        ProtoOnnx.TensorProto getT();
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
         */
        ProtoOnnx.TensorProtoOrBuilder getTOrBuilder();
        
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
         * @return Whether the g field is set.
         */
        boolean hasG();
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
         * @return The g.
         */
        ProtoOnnx.GraphProto getG();
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
         */
        ProtoOnnx.GraphProtoOrBuilder getGOrBuilder();
        
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
         * @return Whether the sparseTensor field is set.
         */
        boolean hasSparseTensor();
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
         * @return The sparseTensor.
         */
        ProtoOnnx.SparseTensorProto getSparseTensor();
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
         */
        ProtoOnnx.SparseTensorProtoOrBuilder getSparseTensorOrBuilder();
        
        /**
         * <pre>
         * Do not use field below, it's deprecated.
         * optional ValueProto v = 12;         // value - subsumes everything but graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
         * @return Whether the tp field is set.
         */
        boolean hasTp();
        /**
         * <pre>
         * Do not use field below, it's deprecated.
         * optional ValueProto v = 12;         // value - subsumes everything but graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
         * @return The tp.
         */
        ProtoOnnx.TypeProto getTp();
        /**
         * <pre>
         * Do not use field below, it's deprecated.
         * optional ValueProto v = 12;         // value - subsumes everything but graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
         */
        ProtoOnnx.TypeProtoOrBuilder getTpOrBuilder();
        
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @return A list containing the floats.
         */
        java.util.List<java.lang.Float> getFloatsList();
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @return The count of floats.
         */
        int getFloatsCount();
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @param index The index of the element to return.
         * @return The floats at the given index.
         */
        float getFloats(int index);
        
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @return A list containing the ints.
         */
        java.util.List<java.lang.Long> getIntsList();
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @return The count of ints.
         */
        int getIntsCount();
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @param index The index of the element to return.
         * @return The ints at the given index.
         */
        long getInts(int index);
        
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @return A list containing the strings.
         */
        java.util.List<com.google.protobuf.ByteString> getStringsList();
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @return The count of strings.
         */
        int getStringsCount();
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @param index The index of the element to return.
         * @return The strings at the given index.
         */
        com.google.protobuf.ByteString getStrings(int index);
        
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
         */
        java.util.List<ProtoOnnx.TensorProto>
        getTensorsList();
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
         */
        ProtoOnnx.TensorProto getTensors(int index);
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
         */
        int getTensorsCount();
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
         */
        java.util.List<? extends ProtoOnnx.TensorProtoOrBuilder>
        getTensorsOrBuilderList();
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
         */
        ProtoOnnx.TensorProtoOrBuilder getTensorsOrBuilder(
            int index);
        
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
         */
        java.util.List<ProtoOnnx.GraphProto>
        getGraphsList();
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
         */
        ProtoOnnx.GraphProto getGraphs(int index);
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
         */
        int getGraphsCount();
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
         */
        java.util.List<? extends ProtoOnnx.GraphProtoOrBuilder>
        getGraphsOrBuilderList();
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
         */
        ProtoOnnx.GraphProtoOrBuilder getGraphsOrBuilder(
            int index);
        
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        java.util.List<ProtoOnnx.SparseTensorProto>
        getSparseTensorsList();
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        ProtoOnnx.SparseTensorProto getSparseTensors(int index);
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        int getSparseTensorsCount();
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        java.util.List<? extends ProtoOnnx.SparseTensorProtoOrBuilder>
        getSparseTensorsOrBuilderList();
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        ProtoOnnx.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(
            int index);
        
        /**
         * <pre>
         * list of type protos
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
         */
        java.util.List<ProtoOnnx.TypeProto>
        getTypeProtosList();
        /**
         * <pre>
         * list of type protos
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
         */
        ProtoOnnx.TypeProto getTypeProtos(int index);
        /**
         * <pre>
         * list of type protos
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
         */
        int getTypeProtosCount();
        /**
         * <pre>
         * list of type protos
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
         */
        java.util.List<? extends ProtoOnnx.TypeProtoOrBuilder>
        getTypeProtosOrBuilderList();
        /**
         * <pre>
         * list of type protos
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
         */
        ProtoOnnx.TypeProtoOrBuilder getTypeProtosOrBuilder(
            int index);
    }
    /**
     * <pre>
     * Attributes
     *
     * A named attribute containing either singular float, integer, string, graph,
     * and tensor values, or repeated float, integer, string, graph, and tensor values.
     * An AttributeProto MUST contain the name field, and *only one* of the
     * following content fields, effectively enforcing a C/C++ union equivalent.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.AttributeProto}
     */
    public static final class AttributeProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.AttributeProto)
        AttributeProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                AttributeProto.class.getName());
        }
        // Use AttributeProto.newBuilder() to construct.
        private AttributeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private AttributeProto() {
            name_ = "";
            refAttrName_ = "";
            docString_ = "";
            type_ = 0;
            s_ = com.google.protobuf.ByteString.EMPTY;
            floats_ = emptyFloatList();
            ints_ = emptyLongList();
            strings_ = emptyList(com.google.protobuf.ByteString.class);
            tensors_ = java.util.Collections.emptyList();
            graphs_ = java.util.Collections.emptyList();
            sparseTensors_ = java.util.Collections.emptyList();
            typeProtos_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ProtoOnnx.internal_static_onnx_AttributeProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ProtoOnnx.internal_static_onnx_AttributeProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    ProtoOnnx.AttributeProto.class, ProtoOnnx.AttributeProto.Builder.class);
        }
        
        /**
         * <pre>
         * Note: this enum is structurally identical to the OpSchema::AttrType
         * enum defined in schema.h.  If you rev one, you likely need to rev the other.
         * </pre>
         *
         * Protobuf enum {@code org.brain4j.core.importing.onnx.AttributeProto.AttributeType}
         */
        public enum AttributeType
            implements com.google.protobuf.ProtocolMessageEnum {
            /**
             * <code>UNDEFINED = 0;</code>
             */
            UNDEFINED(0),
            /**
             * <code>FLOAT = 1;</code>
             */
            FLOAT(1),
            /**
             * <code>INT = 2;</code>
             */
            INT(2),
            /**
             * <code>STRING = 3;</code>
             */
            STRING(3),
            /**
             * <code>TENSOR = 4;</code>
             */
            TENSOR(4),
            /**
             * <code>GRAPH = 5;</code>
             */
            GRAPH(5),
            /**
             * <code>SPARSE_TENSOR = 11;</code>
             */
            SPARSE_TENSOR(11),
            /**
             * <code>TYPE_PROTO = 13;</code>
             */
            TYPE_PROTO(13),
            /**
             * <code>FLOATS = 6;</code>
             */
            FLOATS(6),
            /**
             * <code>INTS = 7;</code>
             */
            INTS(7),
            /**
             * <code>STRINGS = 8;</code>
             */
            STRINGS(8),
            /**
             * <code>TENSORS = 9;</code>
             */
            TENSORS(9),
            /**
             * <code>GRAPHS = 10;</code>
             */
            GRAPHS(10),
            /**
             * <code>SPARSE_TENSORS = 12;</code>
             */
            SPARSE_TENSORS(12),
            /**
             * <code>TYPE_PROTOS = 14;</code>
             */
            TYPE_PROTOS(14),
            ;
            
            static {
                com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                    com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 31,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    AttributeType.class.getName());
            }
            /**
             * <code>UNDEFINED = 0;</code>
             */
            public static final int UNDEFINED_VALUE = 0;
            /**
             * <code>FLOAT = 1;</code>
             */
            public static final int FLOAT_VALUE = 1;
            /**
             * <code>INT = 2;</code>
             */
            public static final int INT_VALUE = 2;
            /**
             * <code>STRING = 3;</code>
             */
            public static final int STRING_VALUE = 3;
            /**
             * <code>TENSOR = 4;</code>
             */
            public static final int TENSOR_VALUE = 4;
            /**
             * <code>GRAPH = 5;</code>
             */
            public static final int GRAPH_VALUE = 5;
            /**
             * <code>SPARSE_TENSOR = 11;</code>
             */
            public static final int SPARSE_TENSOR_VALUE = 11;
            /**
             * <code>TYPE_PROTO = 13;</code>
             */
            public static final int TYPE_PROTO_VALUE = 13;
            /**
             * <code>FLOATS = 6;</code>
             */
            public static final int FLOATS_VALUE = 6;
            /**
             * <code>INTS = 7;</code>
             */
            public static final int INTS_VALUE = 7;
            /**
             * <code>STRINGS = 8;</code>
             */
            public static final int STRINGS_VALUE = 8;
            /**
             * <code>TENSORS = 9;</code>
             */
            public static final int TENSORS_VALUE = 9;
            /**
             * <code>GRAPHS = 10;</code>
             */
            public static final int GRAPHS_VALUE = 10;
            /**
             * <code>SPARSE_TENSORS = 12;</code>
             */
            public static final int SPARSE_TENSORS_VALUE = 12;
            /**
             * <code>TYPE_PROTOS = 14;</code>
             */
            public static final int TYPE_PROTOS_VALUE = 14;
            
            
            public final int getNumber() {
                return value;
            }
            
            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             * @deprecated Use {@link #forNumber(int)} instead.
             */
            @java.lang.Deprecated
            public static AttributeType valueOf(int value) {
                return forNumber(value);
            }
            
            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             */
            public static AttributeType forNumber(int value) {
                switch (value) {
                    case 0: return UNDEFINED;
                    case 1: return FLOAT;
                    case 2: return INT;
                    case 3: return STRING;
                    case 4: return TENSOR;
                    case 5: return GRAPH;
                    case 11: return SPARSE_TENSOR;
                    case 13: return TYPE_PROTO;
                    case 6: return FLOATS;
                    case 7: return INTS;
                    case 8: return STRINGS;
                    case 9: return TENSORS;
                    case 10: return GRAPHS;
                    case 12: return SPARSE_TENSORS;
                    case 14: return TYPE_PROTOS;
                    default: return null;
                }
            }
            
            public static com.google.protobuf.Internal.EnumLiteMap<AttributeType>
            internalGetValueMap() {
                return internalValueMap;
            }
            private static final com.google.protobuf.Internal.EnumLiteMap<
                AttributeType> internalValueMap =
                new com.google.protobuf.Internal.EnumLiteMap<AttributeType>() {
                    public AttributeType findValueByNumber(int number) {
                        return AttributeType.forNumber(number);
                    }
                };
            
            public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
                return getDescriptor().getValues().get(ordinal());
            }
            public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
                return getDescriptor();
            }
            public static com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
                return ProtoOnnx.AttributeProto.getDescriptor().getEnumTypes().get(0);
            }
            
            private static final AttributeType[] VALUES = values();
            
            public static AttributeType valueOf(
                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
                if (desc.getType() != getDescriptor()) {
                    throw new java.lang.IllegalArgumentException(
                        "EnumValueDescriptor is not for this type.");
                }
                return VALUES[desc.getIndex()];
            }
            
            private final int value;
            
            private AttributeType(int value) {
                this.value = value;
            }
            
            // @@protoc_insertion_point(enum_scope:org.brain4j.core.importing.onnx.AttributeProto.AttributeType)
        }
        
        private int bitField0_;
        public static final int NAME_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private volatile java.lang.Object name_ = "";
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int REF_ATTR_NAME_FIELD_NUMBER = 21;
        @SuppressWarnings("serial")
        private volatile java.lang.Object refAttrName_ = "";
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return Whether the refAttrName field is set.
         */
        @java.lang.Override
        public boolean hasRefAttrName() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return The refAttrName.
         */
        @java.lang.Override
        public java.lang.String getRefAttrName() {
            java.lang.Object ref = refAttrName_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    refAttrName_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return The bytes for refAttrName.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getRefAttrNameBytes() {
            java.lang.Object ref = refAttrName_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                refAttrName_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int DOC_STRING_FIELD_NUMBER = 13;
        @SuppressWarnings("serial")
        private volatile java.lang.Object docString_ = "";
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int TYPE_FIELD_NUMBER = 20;
        private int type_ = 0;
        /**
         * <pre>
         * The type field MUST be present for this version of the IR.
         * For 0.0.1 versions of the IR, this field was not defined, and
         * implementations needed to use has_field heuristics to determine
         * which value field was in use.  For IR_VERSION 0.0.2 or later, this
         * field MUST be set and match the f|i|s|t|... field in use.  This
         * change was made to accommodate proto3 implementations.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.AttributeProto.AttributeType type = 20;</code>
         * @return Whether the type field is set.
         */
        @java.lang.Override public boolean hasType() {
            return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * The type field MUST be present for this version of the IR.
         * For 0.0.1 versions of the IR, this field was not defined, and
         * implementations needed to use has_field heuristics to determine
         * which value field was in use.  For IR_VERSION 0.0.2 or later, this
         * field MUST be set and match the f|i|s|t|... field in use.  This
         * change was made to accommodate proto3 implementations.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.AttributeProto.AttributeType type = 20;</code>
         * @return The type.
         */
        @java.lang.Override public ProtoOnnx.AttributeProto.AttributeType getType() {
            ProtoOnnx.AttributeProto.AttributeType result = ProtoOnnx.AttributeProto.AttributeType.forNumber(type_);
            return result == null ? ProtoOnnx.AttributeProto.AttributeType.UNDEFINED : result;
        }
        
        public static final int F_FIELD_NUMBER = 2;
        private float f_ = 0F;
        /**
         * <pre>
         * Exactly ONE of the following fields must be present for this version of the IR
         * </pre>
         *
         * <code>optional float f = 2;</code>
         * @return Whether the f field is set.
         */
        @java.lang.Override
        public boolean hasF() {
            return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Exactly ONE of the following fields must be present for this version of the IR
         * </pre>
         *
         * <code>optional float f = 2;</code>
         * @return The f.
         */
        @java.lang.Override
        public float getF() {
            return f_;
        }
        
        public static final int I_FIELD_NUMBER = 3;
        private long i_ = 0L;
        /**
         * <pre>
         * int
         * </pre>
         *
         * <code>optional int64 i = 3;</code>
         * @return Whether the i field is set.
         */
        @java.lang.Override
        public boolean hasI() {
            return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * int
         * </pre>
         *
         * <code>optional int64 i = 3;</code>
         * @return The i.
         */
        @java.lang.Override
        public long getI() {
            return i_;
        }
        
        public static final int S_FIELD_NUMBER = 4;
        private com.google.protobuf.ByteString s_ = com.google.protobuf.ByteString.EMPTY;
        /**
         * <pre>
         * UTF-8 string
         * </pre>
         *
         * <code>optional bytes s = 4;</code>
         * @return Whether the s field is set.
         */
        @java.lang.Override
        public boolean hasS() {
            return ((bitField0_ & 0x00000040) != 0);
        }
        /**
         * <pre>
         * UTF-8 string
         * </pre>
         *
         * <code>optional bytes s = 4;</code>
         * @return The s.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getS() {
            return s_;
        }
        
        public static final int T_FIELD_NUMBER = 5;
        private ProtoOnnx.TensorProto t_;
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
         * @return Whether the t field is set.
         */
        @java.lang.Override
        public boolean hasT() {
            return ((bitField0_ & 0x00000080) != 0);
        }
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
         * @return The t.
         */
        @java.lang.Override
        public ProtoOnnx.TensorProto getT() {
            return t_ == null ? ProtoOnnx.TensorProto.getDefaultInstance() : t_;
        }
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
         */
        @java.lang.Override
        public ProtoOnnx.TensorProtoOrBuilder getTOrBuilder() {
            return t_ == null ? ProtoOnnx.TensorProto.getDefaultInstance() : t_;
        }
        
        public static final int G_FIELD_NUMBER = 6;
        private ProtoOnnx.GraphProto g_;
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
         * @return Whether the g field is set.
         */
        @java.lang.Override
        public boolean hasG() {
            return ((bitField0_ & 0x00000100) != 0);
        }
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
         * @return The g.
         */
        @java.lang.Override
        public ProtoOnnx.GraphProto getG() {
            return g_ == null ? ProtoOnnx.GraphProto.getDefaultInstance() : g_;
        }
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
         */
        @java.lang.Override
        public ProtoOnnx.GraphProtoOrBuilder getGOrBuilder() {
            return g_ == null ? ProtoOnnx.GraphProto.getDefaultInstance() : g_;
        }
        
        public static final int SPARSE_TENSOR_FIELD_NUMBER = 22;
        private ProtoOnnx.SparseTensorProto sparseTensor_;
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
         * @return Whether the sparseTensor field is set.
         */
        @java.lang.Override
        public boolean hasSparseTensor() {
            return ((bitField0_ & 0x00000200) != 0);
        }
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
         * @return The sparseTensor.
         */
        @java.lang.Override
        public ProtoOnnx.SparseTensorProto getSparseTensor() {
            return sparseTensor_ == null ? ProtoOnnx.SparseTensorProto.getDefaultInstance() : sparseTensor_;
        }
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
         */
        @java.lang.Override
        public ProtoOnnx.SparseTensorProtoOrBuilder getSparseTensorOrBuilder() {
            return sparseTensor_ == null ? ProtoOnnx.SparseTensorProto.getDefaultInstance() : sparseTensor_;
        }
        
        public static final int TP_FIELD_NUMBER = 14;
        private ProtoOnnx.TypeProto tp_;
        /**
         * <pre>
         * Do not use field below, it's deprecated.
         * optional ValueProto v = 12;         // value - subsumes everything but graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
         * @return Whether the tp field is set.
         */
        @java.lang.Override
        public boolean hasTp() {
            return ((bitField0_ & 0x00000400) != 0);
        }
        /**
         * <pre>
         * Do not use field below, it's deprecated.
         * optional ValueProto v = 12;         // value - subsumes everything but graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
         * @return The tp.
         */
        @java.lang.Override
        public ProtoOnnx.TypeProto getTp() {
            return tp_ == null ? ProtoOnnx.TypeProto.getDefaultInstance() : tp_;
        }
        /**
         * <pre>
         * Do not use field below, it's deprecated.
         * optional ValueProto v = 12;         // value - subsumes everything but graph
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
         */
        @java.lang.Override
        public ProtoOnnx.TypeProtoOrBuilder getTpOrBuilder() {
            return tp_ == null ? ProtoOnnx.TypeProto.getDefaultInstance() : tp_;
        }
        
        public static final int FLOATS_FIELD_NUMBER = 7;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.FloatList floats_ =
            emptyFloatList();
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @return A list containing the floats.
         */
        @java.lang.Override
        public java.util.List<java.lang.Float>
        getFloatsList() {
            return floats_;
        }
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @return The count of floats.
         */
        public int getFloatsCount() {
            return floats_.size();
        }
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @param index The index of the element to return.
         * @return The floats at the given index.
         */
        public float getFloats(int index) {
            return floats_.getFloat(index);
        }
        
        public static final int INTS_FIELD_NUMBER = 8;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.LongList ints_ =
            emptyLongList();
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @return A list containing the ints.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getIntsList() {
            return ints_;
        }
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @return The count of ints.
         */
        public int getIntsCount() {
            return ints_.size();
        }
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @param index The index of the element to return.
         * @return The ints at the given index.
         */
        public long getInts(int index) {
            return ints_.getLong(index);
        }
        
        public static final int STRINGS_FIELD_NUMBER = 9;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> strings_ =
            emptyList(com.google.protobuf.ByteString.class);
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @return A list containing the strings.
         */
        @java.lang.Override
        public java.util.List<com.google.protobuf.ByteString>
        getStringsList() {
            return strings_;
        }
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @return The count of strings.
         */
        public int getStringsCount() {
            return strings_.size();
        }
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @param index The index of the element to return.
         * @return The strings at the given index.
         */
        public com.google.protobuf.ByteString getStrings(int index) {
            return strings_.get(index);
        }
        
        public static final int TENSORS_FIELD_NUMBER = 10;
        @SuppressWarnings("serial")
        private java.util.List<ProtoOnnx.TensorProto> tensors_;
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.TensorProto> getTensorsList() {
            return tensors_;
        }
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ProtoOnnx.TensorProtoOrBuilder>
        getTensorsOrBuilderList() {
            return tensors_;
        }
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
         */
        @java.lang.Override
        public int getTensorsCount() {
            return tensors_.size();
        }
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
         */
        @java.lang.Override
        public ProtoOnnx.TensorProto getTensors(int index) {
            return tensors_.get(index);
        }
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
         */
        @java.lang.Override
        public ProtoOnnx.TensorProtoOrBuilder getTensorsOrBuilder(
            int index) {
            return tensors_.get(index);
        }
        
        public static final int GRAPHS_FIELD_NUMBER = 11;
        @SuppressWarnings("serial")
        private java.util.List<ProtoOnnx.GraphProto> graphs_;
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.GraphProto> getGraphsList() {
            return graphs_;
        }
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ProtoOnnx.GraphProtoOrBuilder>
        getGraphsOrBuilderList() {
            return graphs_;
        }
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
         */
        @java.lang.Override
        public int getGraphsCount() {
            return graphs_.size();
        }
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
         */
        @java.lang.Override
        public ProtoOnnx.GraphProto getGraphs(int index) {
            return graphs_.get(index);
        }
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
         */
        @java.lang.Override
        public ProtoOnnx.GraphProtoOrBuilder getGraphsOrBuilder(
            int index) {
            return graphs_.get(index);
        }
        
        public static final int SPARSE_TENSORS_FIELD_NUMBER = 23;
        @SuppressWarnings("serial")
        private java.util.List<ProtoOnnx.SparseTensorProto> sparseTensors_;
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.SparseTensorProto> getSparseTensorsList() {
            return sparseTensors_;
        }
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ProtoOnnx.SparseTensorProtoOrBuilder>
        getSparseTensorsOrBuilderList() {
            return sparseTensors_;
        }
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        @java.lang.Override
        public int getSparseTensorsCount() {
            return sparseTensors_.size();
        }
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        @java.lang.Override
        public ProtoOnnx.SparseTensorProto getSparseTensors(int index) {
            return sparseTensors_.get(index);
        }
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        @java.lang.Override
        public ProtoOnnx.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(
            int index) {
            return sparseTensors_.get(index);
        }
        
        public static final int TYPE_PROTOS_FIELD_NUMBER = 15;
        @SuppressWarnings("serial")
        private java.util.List<ProtoOnnx.TypeProto> typeProtos_;
        /**
         * <pre>
         * list of type protos
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.TypeProto> getTypeProtosList() {
            return typeProtos_;
        }
        /**
         * <pre>
         * list of type protos
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ProtoOnnx.TypeProtoOrBuilder>
        getTypeProtosOrBuilderList() {
            return typeProtos_;
        }
        /**
         * <pre>
         * list of type protos
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
         */
        @java.lang.Override
        public int getTypeProtosCount() {
            return typeProtos_.size();
        }
        /**
         * <pre>
         * list of type protos
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
         */
        @java.lang.Override
        public ProtoOnnx.TypeProto getTypeProtos(int index) {
            return typeProtos_.get(index);
        }
        /**
         * <pre>
         * list of type protos
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
         */
        @java.lang.Override
        public ProtoOnnx.TypeProtoOrBuilder getTypeProtosOrBuilder(
            int index) {
            return typeProtos_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                output.writeFloat(2, f_);
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                output.writeInt64(3, i_);
            }
            if (((bitField0_ & 0x00000040) != 0)) {
                output.writeBytes(4, s_);
            }
            if (((bitField0_ & 0x00000080) != 0)) {
                output.writeMessage(5, getT());
            }
            if (((bitField0_ & 0x00000100) != 0)) {
                output.writeMessage(6, getG());
            }
            for (int i = 0; i < floats_.size(); i++) {
                output.writeFloat(7, floats_.getFloat(i));
            }
            for (int i = 0; i < ints_.size(); i++) {
                output.writeInt64(8, ints_.getLong(i));
            }
            for (int i = 0; i < strings_.size(); i++) {
                output.writeBytes(9, strings_.get(i));
            }
            for (int i = 0; i < tensors_.size(); i++) {
                output.writeMessage(10, tensors_.get(i));
            }
            for (int i = 0; i < graphs_.size(); i++) {
                output.writeMessage(11, graphs_.get(i));
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 13, docString_);
            }
            if (((bitField0_ & 0x00000400) != 0)) {
                output.writeMessage(14, getTp());
            }
            for (int i = 0; i < typeProtos_.size(); i++) {
                output.writeMessage(15, typeProtos_.get(i));
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                output.writeEnum(20, type_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 21, refAttrName_);
            }
            if (((bitField0_ & 0x00000200) != 0)) {
                output.writeMessage(22, getSparseTensor());
            }
            for (int i = 0; i < sparseTensors_.size(); i++) {
                output.writeMessage(23, sparseTensors_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeFloatSize(2, f_);
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt64Size(3, i_);
            }
            if (((bitField0_ & 0x00000040) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeBytesSize(4, s_);
            }
            if (((bitField0_ & 0x00000080) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(5, getT());
            }
            if (((bitField0_ & 0x00000100) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(6, getG());
            }
            {
                int dataSize = 0;
                dataSize = 4 * getFloatsList().size();
                size += dataSize;
                size += 1 * getFloatsList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < ints_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                        .computeInt64SizeNoTag(ints_.getLong(i));
                }
                size += dataSize;
                size += 1 * getIntsList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < strings_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                        .computeBytesSizeNoTag(strings_.get(i));
                }
                size += dataSize;
                size += 1 * getStringsList().size();
            }
            for (int i = 0; i < tensors_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(10, tensors_.get(i));
            }
            for (int i = 0; i < graphs_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(11, graphs_.get(i));
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(13, docString_);
            }
            if (((bitField0_ & 0x00000400) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(14, getTp());
            }
            for (int i = 0; i < typeProtos_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(15, typeProtos_.get(i));
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeEnumSize(20, type_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(21, refAttrName_);
            }
            if (((bitField0_ & 0x00000200) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(22, getSparseTensor());
            }
            for (int i = 0; i < sparseTensors_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(23, sparseTensors_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ProtoOnnx.AttributeProto)) {
                return super.equals(obj);
            }
            ProtoOnnx.AttributeProto other = (ProtoOnnx.AttributeProto) obj;
            
            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                    .equals(other.getName())) return false;
            }
            if (hasRefAttrName() != other.hasRefAttrName()) return false;
            if (hasRefAttrName()) {
                if (!getRefAttrName()
                    .equals(other.getRefAttrName())) return false;
            }
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                    .equals(other.getDocString())) return false;
            }
            if (hasType() != other.hasType()) return false;
            if (hasType()) {
                if (type_ != other.type_) return false;
            }
            if (hasF() != other.hasF()) return false;
            if (hasF()) {
                if (java.lang.Float.floatToIntBits(getF())
                    != java.lang.Float.floatToIntBits(
                    other.getF())) return false;
            }
            if (hasI() != other.hasI()) return false;
            if (hasI()) {
                if (getI()
                    != other.getI()) return false;
            }
            if (hasS() != other.hasS()) return false;
            if (hasS()) {
                if (!getS()
                    .equals(other.getS())) return false;
            }
            if (hasT() != other.hasT()) return false;
            if (hasT()) {
                if (!getT()
                    .equals(other.getT())) return false;
            }
            if (hasG() != other.hasG()) return false;
            if (hasG()) {
                if (!getG()
                    .equals(other.getG())) return false;
            }
            if (hasSparseTensor() != other.hasSparseTensor()) return false;
            if (hasSparseTensor()) {
                if (!getSparseTensor()
                    .equals(other.getSparseTensor())) return false;
            }
            if (hasTp() != other.hasTp()) return false;
            if (hasTp()) {
                if (!getTp()
                    .equals(other.getTp())) return false;
            }
            if (!getFloatsList()
                .equals(other.getFloatsList())) return false;
            if (!getIntsList()
                .equals(other.getIntsList())) return false;
            if (!getStringsList()
                .equals(other.getStringsList())) return false;
            if (!getTensorsList()
                .equals(other.getTensorsList())) return false;
            if (!getGraphsList()
                .equals(other.getGraphsList())) return false;
            if (!getSparseTensorsList()
                .equals(other.getSparseTensorsList())) return false;
            if (!getTypeProtosList()
                .equals(other.getTypeProtosList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (hasRefAttrName()) {
                hash = (37 * hash) + REF_ATTR_NAME_FIELD_NUMBER;
                hash = (53 * hash) + getRefAttrName().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (hasType()) {
                hash = (37 * hash) + TYPE_FIELD_NUMBER;
                hash = (53 * hash) + type_;
            }
            if (hasF()) {
                hash = (37 * hash) + F_FIELD_NUMBER;
                hash = (53 * hash) + java.lang.Float.floatToIntBits(
                    getF());
            }
            if (hasI()) {
                hash = (37 * hash) + I_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                    getI());
            }
            if (hasS()) {
                hash = (37 * hash) + S_FIELD_NUMBER;
                hash = (53 * hash) + getS().hashCode();
            }
            if (hasT()) {
                hash = (37 * hash) + T_FIELD_NUMBER;
                hash = (53 * hash) + getT().hashCode();
            }
            if (hasG()) {
                hash = (37 * hash) + G_FIELD_NUMBER;
                hash = (53 * hash) + getG().hashCode();
            }
            if (hasSparseTensor()) {
                hash = (37 * hash) + SPARSE_TENSOR_FIELD_NUMBER;
                hash = (53 * hash) + getSparseTensor().hashCode();
            }
            if (hasTp()) {
                hash = (37 * hash) + TP_FIELD_NUMBER;
                hash = (53 * hash) + getTp().hashCode();
            }
            if (getFloatsCount() > 0) {
                hash = (37 * hash) + FLOATS_FIELD_NUMBER;
                hash = (53 * hash) + getFloatsList().hashCode();
            }
            if (getIntsCount() > 0) {
                hash = (37 * hash) + INTS_FIELD_NUMBER;
                hash = (53 * hash) + getIntsList().hashCode();
            }
            if (getStringsCount() > 0) {
                hash = (37 * hash) + STRINGS_FIELD_NUMBER;
                hash = (53 * hash) + getStringsList().hashCode();
            }
            if (getTensorsCount() > 0) {
                hash = (37 * hash) + TENSORS_FIELD_NUMBER;
                hash = (53 * hash) + getTensorsList().hashCode();
            }
            if (getGraphsCount() > 0) {
                hash = (37 * hash) + GRAPHS_FIELD_NUMBER;
                hash = (53 * hash) + getGraphsList().hashCode();
            }
            if (getSparseTensorsCount() > 0) {
                hash = (37 * hash) + SPARSE_TENSORS_FIELD_NUMBER;
                hash = (53 * hash) + getSparseTensorsList().hashCode();
            }
            if (getTypeProtosCount() > 0) {
                hash = (37 * hash) + TYPE_PROTOS_FIELD_NUMBER;
                hash = (53 * hash) + getTypeProtosList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static ProtoOnnx.AttributeProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ProtoOnnx.AttributeProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.AttributeProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ProtoOnnx.AttributeProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.AttributeProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ProtoOnnx.AttributeProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.AttributeProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static ProtoOnnx.AttributeProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static ProtoOnnx.AttributeProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static ProtoOnnx.AttributeProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ProtoOnnx.AttributeProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static ProtoOnnx.AttributeProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ProtoOnnx.AttributeProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Attributes
         *
         * A named attribute containing either singular float, integer, string, graph,
         * and tensor values, or repeated float, integer, string, graph, and tensor values.
         * An AttributeProto MUST contain the name field, and *only one* of the
         * following content fields, effectively enforcing a C/C++ union equivalent.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.AttributeProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.AttributeProto)
            ProtoOnnx.AttributeProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ProtoOnnx.internal_static_onnx_AttributeProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ProtoOnnx.internal_static_onnx_AttributeProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        ProtoOnnx.AttributeProto.class, ProtoOnnx.AttributeProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessage
                    .alwaysUseFieldBuilders) {
                    internalGetTFieldBuilder();
                    internalGetGFieldBuilder();
                    internalGetSparseTensorFieldBuilder();
                    internalGetTpFieldBuilder();
                    internalGetTensorsFieldBuilder();
                    internalGetGraphsFieldBuilder();
                    internalGetSparseTensorsFieldBuilder();
                    internalGetTypeProtosFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                name_ = "";
                refAttrName_ = "";
                docString_ = "";
                type_ = 0;
                f_ = 0F;
                i_ = 0L;
                s_ = com.google.protobuf.ByteString.EMPTY;
                t_ = null;
                if (tBuilder_ != null) {
                    tBuilder_.dispose();
                    tBuilder_ = null;
                }
                g_ = null;
                if (gBuilder_ != null) {
                    gBuilder_.dispose();
                    gBuilder_ = null;
                }
                sparseTensor_ = null;
                if (sparseTensorBuilder_ != null) {
                    sparseTensorBuilder_.dispose();
                    sparseTensorBuilder_ = null;
                }
                tp_ = null;
                if (tpBuilder_ != null) {
                    tpBuilder_.dispose();
                    tpBuilder_ = null;
                }
                floats_ = emptyFloatList();
                ints_ = emptyLongList();
                strings_ = emptyList(com.google.protobuf.ByteString.class);
                if (tensorsBuilder_ == null) {
                    tensors_ = java.util.Collections.emptyList();
                } else {
                    tensors_ = null;
                    tensorsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00004000);
                if (graphsBuilder_ == null) {
                    graphs_ = java.util.Collections.emptyList();
                } else {
                    graphs_ = null;
                    graphsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00008000);
                if (sparseTensorsBuilder_ == null) {
                    sparseTensors_ = java.util.Collections.emptyList();
                } else {
                    sparseTensors_ = null;
                    sparseTensorsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00010000);
                if (typeProtosBuilder_ == null) {
                    typeProtos_ = java.util.Collections.emptyList();
                } else {
                    typeProtos_ = null;
                    typeProtosBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00020000);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ProtoOnnx.internal_static_onnx_AttributeProto_descriptor;
            }
            
            @java.lang.Override
            public ProtoOnnx.AttributeProto getDefaultInstanceForType() {
                return ProtoOnnx.AttributeProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public ProtoOnnx.AttributeProto build() {
                ProtoOnnx.AttributeProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public ProtoOnnx.AttributeProto buildPartial() {
                ProtoOnnx.AttributeProto result = new ProtoOnnx.AttributeProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(ProtoOnnx.AttributeProto result) {
                if (tensorsBuilder_ == null) {
                    if (((bitField0_ & 0x00004000) != 0)) {
                        tensors_ = java.util.Collections.unmodifiableList(tensors_);
                        bitField0_ = (bitField0_ & ~0x00004000);
                    }
                    result.tensors_ = tensors_;
                } else {
                    result.tensors_ = tensorsBuilder_.build();
                }
                if (graphsBuilder_ == null) {
                    if (((bitField0_ & 0x00008000) != 0)) {
                        graphs_ = java.util.Collections.unmodifiableList(graphs_);
                        bitField0_ = (bitField0_ & ~0x00008000);
                    }
                    result.graphs_ = graphs_;
                } else {
                    result.graphs_ = graphsBuilder_.build();
                }
                if (sparseTensorsBuilder_ == null) {
                    if (((bitField0_ & 0x00010000) != 0)) {
                        sparseTensors_ = java.util.Collections.unmodifiableList(sparseTensors_);
                        bitField0_ = (bitField0_ & ~0x00010000);
                    }
                    result.sparseTensors_ = sparseTensors_;
                } else {
                    result.sparseTensors_ = sparseTensorsBuilder_.build();
                }
                if (typeProtosBuilder_ == null) {
                    if (((bitField0_ & 0x00020000) != 0)) {
                        typeProtos_ = java.util.Collections.unmodifiableList(typeProtos_);
                        bitField0_ = (bitField0_ & ~0x00020000);
                    }
                    result.typeProtos_ = typeProtos_;
                } else {
                    result.typeProtos_ = typeProtosBuilder_.build();
                }
            }
            
            private void buildPartial0(ProtoOnnx.AttributeProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.name_ = name_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.refAttrName_ = refAttrName_;
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    result.docString_ = docString_;
                    to_bitField0_ |= 0x00000004;
                }
                if (((from_bitField0_ & 0x00000008) != 0)) {
                    result.type_ = type_;
                    to_bitField0_ |= 0x00000008;
                }
                if (((from_bitField0_ & 0x00000010) != 0)) {
                    result.f_ = f_;
                    to_bitField0_ |= 0x00000010;
                }
                if (((from_bitField0_ & 0x00000020) != 0)) {
                    result.i_ = i_;
                    to_bitField0_ |= 0x00000020;
                }
                if (((from_bitField0_ & 0x00000040) != 0)) {
                    result.s_ = s_;
                    to_bitField0_ |= 0x00000040;
                }
                if (((from_bitField0_ & 0x00000080) != 0)) {
                    result.t_ = tBuilder_ == null
                        ? t_
                        : tBuilder_.build();
                    to_bitField0_ |= 0x00000080;
                }
                if (((from_bitField0_ & 0x00000100) != 0)) {
                    result.g_ = gBuilder_ == null
                        ? g_
                        : gBuilder_.build();
                    to_bitField0_ |= 0x00000100;
                }
                if (((from_bitField0_ & 0x00000200) != 0)) {
                    result.sparseTensor_ = sparseTensorBuilder_ == null
                        ? sparseTensor_
                        : sparseTensorBuilder_.build();
                    to_bitField0_ |= 0x00000200;
                }
                if (((from_bitField0_ & 0x00000400) != 0)) {
                    result.tp_ = tpBuilder_ == null
                        ? tp_
                        : tpBuilder_.build();
                    to_bitField0_ |= 0x00000400;
                }
                if (((from_bitField0_ & 0x00000800) != 0)) {
                    floats_.makeImmutable();
                    result.floats_ = floats_;
                }
                if (((from_bitField0_ & 0x00001000) != 0)) {
                    ints_.makeImmutable();
                    result.ints_ = ints_;
                }
                if (((from_bitField0_ & 0x00002000) != 0)) {
                    strings_.makeImmutable();
                    result.strings_ = strings_;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ProtoOnnx.AttributeProto) {
                    return mergeFrom((ProtoOnnx.AttributeProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(ProtoOnnx.AttributeProto other) {
                if (other == ProtoOnnx.AttributeProto.getDefaultInstance()) return this;
                if (other.hasName()) {
                    name_ = other.name_;
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                if (other.hasRefAttrName()) {
                    refAttrName_ = other.refAttrName_;
                    bitField0_ |= 0x00000002;
                    onChanged();
                }
                if (other.hasDocString()) {
                    docString_ = other.docString_;
                    bitField0_ |= 0x00000004;
                    onChanged();
                }
                if (other.hasType()) {
                    setType(other.getType());
                }
                if (other.hasF()) {
                    setF(other.getF());
                }
                if (other.hasI()) {
                    setI(other.getI());
                }
                if (other.hasS()) {
                    setS(other.getS());
                }
                if (other.hasT()) {
                    mergeT(other.getT());
                }
                if (other.hasG()) {
                    mergeG(other.getG());
                }
                if (other.hasSparseTensor()) {
                    mergeSparseTensor(other.getSparseTensor());
                }
                if (other.hasTp()) {
                    mergeTp(other.getTp());
                }
                if (!other.floats_.isEmpty()) {
                    if (floats_.isEmpty()) {
                        floats_ = other.floats_;
                        floats_.makeImmutable();
                        bitField0_ |= 0x00000800;
                    } else {
                        ensureFloatsIsMutable();
                        floats_.addAll(other.floats_);
                    }
                    onChanged();
                }
                if (!other.ints_.isEmpty()) {
                    if (ints_.isEmpty()) {
                        ints_ = other.ints_;
                        ints_.makeImmutable();
                        bitField0_ |= 0x00001000;
                    } else {
                        ensureIntsIsMutable();
                        ints_.addAll(other.ints_);
                    }
                    onChanged();
                }
                if (!other.strings_.isEmpty()) {
                    if (strings_.isEmpty()) {
                        strings_ = other.strings_;
                        strings_.makeImmutable();
                        bitField0_ |= 0x00002000;
                    } else {
                        ensureStringsIsMutable();
                        strings_.addAll(other.strings_);
                    }
                    onChanged();
                }
                if (tensorsBuilder_ == null) {
                    if (!other.tensors_.isEmpty()) {
                        if (tensors_.isEmpty()) {
                            tensors_ = other.tensors_;
                            bitField0_ = (bitField0_ & ~0x00004000);
                        } else {
                            ensureTensorsIsMutable();
                            tensors_.addAll(other.tensors_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.tensors_.isEmpty()) {
                        if (tensorsBuilder_.isEmpty()) {
                            tensorsBuilder_.dispose();
                            tensorsBuilder_ = null;
                            tensors_ = other.tensors_;
                            bitField0_ = (bitField0_ & ~0x00004000);
                            tensorsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetTensorsFieldBuilder() : null;
                        } else {
                            tensorsBuilder_.addAllMessages(other.tensors_);
                        }
                    }
                }
                if (graphsBuilder_ == null) {
                    if (!other.graphs_.isEmpty()) {
                        if (graphs_.isEmpty()) {
                            graphs_ = other.graphs_;
                            bitField0_ = (bitField0_ & ~0x00008000);
                        } else {
                            ensureGraphsIsMutable();
                            graphs_.addAll(other.graphs_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.graphs_.isEmpty()) {
                        if (graphsBuilder_.isEmpty()) {
                            graphsBuilder_.dispose();
                            graphsBuilder_ = null;
                            graphs_ = other.graphs_;
                            bitField0_ = (bitField0_ & ~0x00008000);
                            graphsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetGraphsFieldBuilder() : null;
                        } else {
                            graphsBuilder_.addAllMessages(other.graphs_);
                        }
                    }
                }
                if (sparseTensorsBuilder_ == null) {
                    if (!other.sparseTensors_.isEmpty()) {
                        if (sparseTensors_.isEmpty()) {
                            sparseTensors_ = other.sparseTensors_;
                            bitField0_ = (bitField0_ & ~0x00010000);
                        } else {
                            ensureSparseTensorsIsMutable();
                            sparseTensors_.addAll(other.sparseTensors_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.sparseTensors_.isEmpty()) {
                        if (sparseTensorsBuilder_.isEmpty()) {
                            sparseTensorsBuilder_.dispose();
                            sparseTensorsBuilder_ = null;
                            sparseTensors_ = other.sparseTensors_;
                            bitField0_ = (bitField0_ & ~0x00010000);
                            sparseTensorsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetSparseTensorsFieldBuilder() : null;
                        } else {
                            sparseTensorsBuilder_.addAllMessages(other.sparseTensors_);
                        }
                    }
                }
                if (typeProtosBuilder_ == null) {
                    if (!other.typeProtos_.isEmpty()) {
                        if (typeProtos_.isEmpty()) {
                            typeProtos_ = other.typeProtos_;
                            bitField0_ = (bitField0_ & ~0x00020000);
                        } else {
                            ensureTypeProtosIsMutable();
                            typeProtos_.addAll(other.typeProtos_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.typeProtos_.isEmpty()) {
                        if (typeProtosBuilder_.isEmpty()) {
                            typeProtosBuilder_.dispose();
                            typeProtosBuilder_ = null;
                            typeProtos_ = other.typeProtos_;
                            bitField0_ = (bitField0_ & ~0x00020000);
                            typeProtosBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetTypeProtosFieldBuilder() : null;
                        } else {
                            typeProtosBuilder_.addAllMessages(other.typeProtos_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                name_ = input.readBytes();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 21: {
                                f_ = input.readFloat();
                                bitField0_ |= 0x00000010;
                                break;
                            } // case 21
                            case 24: {
                                i_ = input.readInt64();
                                bitField0_ |= 0x00000020;
                                break;
                            } // case 24
                            case 34: {
                                s_ = input.readBytes();
                                bitField0_ |= 0x00000040;
                                break;
                            } // case 34
                            case 42: {
                                input.readMessage(
                                    internalGetTFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000080;
                                break;
                            } // case 42
                            case 50: {
                                input.readMessage(
                                    internalGetGFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000100;
                                break;
                            } // case 50
                            case 61: {
                                float v = input.readFloat();
                                ensureFloatsIsMutable();
                                floats_.addFloat(v);
                                break;
                            } // case 61
                            case 58: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                int alloc = length > 4096 ? 4096 : length;
                                ensureFloatsIsMutable(alloc / 4);
                                while (input.getBytesUntilLimit() > 0) {
                                    floats_.addFloat(input.readFloat());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 58
                            case 64: {
                                long v = input.readInt64();
                                ensureIntsIsMutable();
                                ints_.addLong(v);
                                break;
                            } // case 64
                            case 66: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                ensureIntsIsMutable();
                                while (input.getBytesUntilLimit() > 0) {
                                    ints_.addLong(input.readInt64());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 66
                            case 74: {
                                com.google.protobuf.ByteString v = input.readBytes();
                                ensureStringsIsMutable();
                                strings_.add(v);
                                break;
                            } // case 74
                            case 82: {
                                ProtoOnnx.TensorProto m =
                                    input.readMessage(
                                        ProtoOnnx.TensorProto.parser(),
                                        extensionRegistry);
                                if (tensorsBuilder_ == null) {
                                    ensureTensorsIsMutable();
                                    tensors_.add(m);
                                } else {
                                    tensorsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 82
                            case 90: {
                                ProtoOnnx.GraphProto m =
                                    input.readMessage(
                                        ProtoOnnx.GraphProto.parser(),
                                        extensionRegistry);
                                if (graphsBuilder_ == null) {
                                    ensureGraphsIsMutable();
                                    graphs_.add(m);
                                } else {
                                    graphsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 90
                            case 106: {
                                docString_ = input.readBytes();
                                bitField0_ |= 0x00000004;
                                break;
                            } // case 106
                            case 114: {
                                input.readMessage(
                                    internalGetTpFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000400;
                                break;
                            } // case 114
                            case 122: {
                                ProtoOnnx.TypeProto m =
                                    input.readMessage(
                                        ProtoOnnx.TypeProto.parser(),
                                        extensionRegistry);
                                if (typeProtosBuilder_ == null) {
                                    ensureTypeProtosIsMutable();
                                    typeProtos_.add(m);
                                } else {
                                    typeProtosBuilder_.addMessage(m);
                                }
                                break;
                            } // case 122
                            case 160: {
                                int tmpRaw = input.readEnum();
                                ProtoOnnx.AttributeProto.AttributeType tmpValue =
                                    ProtoOnnx.AttributeProto.AttributeType.forNumber(tmpRaw);
                                if (tmpValue == null) {
                                    mergeUnknownVarintField(20, tmpRaw);
                                } else {
                                    type_ = tmpRaw;
                                    bitField0_ |= 0x00000008;
                                }
                                break;
                            } // case 160
                            case 170: {
                                refAttrName_ = input.readBytes();
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 170
                            case 178: {
                                input.readMessage(
                                    internalGetSparseTensorFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000200;
                                break;
                            } // case 178
                            case 186: {
                                ProtoOnnx.SparseTensorProto m =
                                    input.readMessage(
                                        ProtoOnnx.SparseTensorProto.parser(),
                                        extensionRegistry);
                                if (sparseTensorsBuilder_ == null) {
                                    ensureSparseTensorsIsMutable();
                                    sparseTensors_.add(m);
                                } else {
                                    sparseTensorsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 186
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.lang.Object name_ = "";
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                name_ = getDefaultInstance().getName();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            
            private java.lang.Object refAttrName_ = "";
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @return Whether the refAttrName field is set.
             */
            public boolean hasRefAttrName() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @return The refAttrName.
             */
            public java.lang.String getRefAttrName() {
                java.lang.Object ref = refAttrName_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        refAttrName_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @return The bytes for refAttrName.
             */
            public com.google.protobuf.ByteString
            getRefAttrNameBytes() {
                java.lang.Object ref = refAttrName_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    refAttrName_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @param value The refAttrName to set.
             * @return This builder for chaining.
             */
            public Builder setRefAttrName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                refAttrName_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @return This builder for chaining.
             */
            public Builder clearRefAttrName() {
                refAttrName_ = getDefaultInstance().getRefAttrName();
                bitField0_ = (bitField0_ & ~0x00000002);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @param value The bytes for refAttrName to set.
             * @return This builder for chaining.
             */
            public Builder setRefAttrNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                refAttrName_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            
            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                docString_ = getDefaultInstance().getDocString();
                bitField0_ = (bitField0_ & ~0x00000004);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            
            private int type_ = 0;
            /**
             * <pre>
             * The type field MUST be present for this version of the IR.
             * For 0.0.1 versions of the IR, this field was not defined, and
             * implementations needed to use has_field heuristics to determine
             * which value field was in use.  For IR_VERSION 0.0.2 or later, this
             * field MUST be set and match the f|i|s|t|... field in use.  This
             * change was made to accommodate proto3 implementations.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.AttributeProto.AttributeType type = 20;</code>
             * @return Whether the type field is set.
             */
            @java.lang.Override public boolean hasType() {
                return ((bitField0_ & 0x00000008) != 0);
            }
            /**
             * <pre>
             * The type field MUST be present for this version of the IR.
             * For 0.0.1 versions of the IR, this field was not defined, and
             * implementations needed to use has_field heuristics to determine
             * which value field was in use.  For IR_VERSION 0.0.2 or later, this
             * field MUST be set and match the f|i|s|t|... field in use.  This
             * change was made to accommodate proto3 implementations.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.AttributeProto.AttributeType type = 20;</code>
             * @return The type.
             */
            @java.lang.Override
            public ProtoOnnx.AttributeProto.AttributeType getType() {
                ProtoOnnx.AttributeProto.AttributeType result = ProtoOnnx.AttributeProto.AttributeType.forNumber(type_);
                return result == null ? ProtoOnnx.AttributeProto.AttributeType.UNDEFINED : result;
            }
            /**
             * <pre>
             * The type field MUST be present for this version of the IR.
             * For 0.0.1 versions of the IR, this field was not defined, and
             * implementations needed to use has_field heuristics to determine
             * which value field was in use.  For IR_VERSION 0.0.2 or later, this
             * field MUST be set and match the f|i|s|t|... field in use.  This
             * change was made to accommodate proto3 implementations.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.AttributeProto.AttributeType type = 20;</code>
             * @param value The type to set.
             * @return This builder for chaining.
             */
            public Builder setType(ProtoOnnx.AttributeProto.AttributeType value) {
                if (value == null) { throw new NullPointerException(); }
                bitField0_ |= 0x00000008;
                type_ = value.getNumber();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The type field MUST be present for this version of the IR.
             * For 0.0.1 versions of the IR, this field was not defined, and
             * implementations needed to use has_field heuristics to determine
             * which value field was in use.  For IR_VERSION 0.0.2 or later, this
             * field MUST be set and match the f|i|s|t|... field in use.  This
             * change was made to accommodate proto3 implementations.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.AttributeProto.AttributeType type = 20;</code>
             * @return This builder for chaining.
             */
            public Builder clearType() {
                bitField0_ = (bitField0_ & ~0x00000008);
                type_ = 0;
                onChanged();
                return this;
            }
            
            private float f_ ;
            /**
             * <pre>
             * Exactly ONE of the following fields must be present for this version of the IR
             * </pre>
             *
             * <code>optional float f = 2;</code>
             * @return Whether the f field is set.
             */
            @java.lang.Override
            public boolean hasF() {
                return ((bitField0_ & 0x00000010) != 0);
            }
            /**
             * <pre>
             * Exactly ONE of the following fields must be present for this version of the IR
             * </pre>
             *
             * <code>optional float f = 2;</code>
             * @return The f.
             */
            @java.lang.Override
            public float getF() {
                return f_;
            }
            /**
             * <pre>
             * Exactly ONE of the following fields must be present for this version of the IR
             * </pre>
             *
             * <code>optional float f = 2;</code>
             * @param value The f to set.
             * @return This builder for chaining.
             */
            public Builder setF(float value) {
                
                f_ = value;
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Exactly ONE of the following fields must be present for this version of the IR
             * </pre>
             *
             * <code>optional float f = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearF() {
                bitField0_ = (bitField0_ & ~0x00000010);
                f_ = 0F;
                onChanged();
                return this;
            }
            
            private long i_ ;
            /**
             * <pre>
             * int
             * </pre>
             *
             * <code>optional int64 i = 3;</code>
             * @return Whether the i field is set.
             */
            @java.lang.Override
            public boolean hasI() {
                return ((bitField0_ & 0x00000020) != 0);
            }
            /**
             * <pre>
             * int
             * </pre>
             *
             * <code>optional int64 i = 3;</code>
             * @return The i.
             */
            @java.lang.Override
            public long getI() {
                return i_;
            }
            /**
             * <pre>
             * int
             * </pre>
             *
             * <code>optional int64 i = 3;</code>
             * @param value The i to set.
             * @return This builder for chaining.
             */
            public Builder setI(long value) {
                
                i_ = value;
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * int
             * </pre>
             *
             * <code>optional int64 i = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearI() {
                bitField0_ = (bitField0_ & ~0x00000020);
                i_ = 0L;
                onChanged();
                return this;
            }
            
            private com.google.protobuf.ByteString s_ = com.google.protobuf.ByteString.EMPTY;
            /**
             * <pre>
             * UTF-8 string
             * </pre>
             *
             * <code>optional bytes s = 4;</code>
             * @return Whether the s field is set.
             */
            @java.lang.Override
            public boolean hasS() {
                return ((bitField0_ & 0x00000040) != 0);
            }
            /**
             * <pre>
             * UTF-8 string
             * </pre>
             *
             * <code>optional bytes s = 4;</code>
             * @return The s.
             */
            @java.lang.Override
            public com.google.protobuf.ByteString getS() {
                return s_;
            }
            /**
             * <pre>
             * UTF-8 string
             * </pre>
             *
             * <code>optional bytes s = 4;</code>
             * @param value The s to set.
             * @return This builder for chaining.
             */
            public Builder setS(com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                s_ = value;
                bitField0_ |= 0x00000040;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * UTF-8 string
             * </pre>
             *
             * <code>optional bytes s = 4;</code>
             * @return This builder for chaining.
             */
            public Builder clearS() {
                bitField0_ = (bitField0_ & ~0x00000040);
                s_ = getDefaultInstance().getS();
                onChanged();
                return this;
            }
            
            private ProtoOnnx.TensorProto t_;
            private com.google.protobuf.SingleFieldBuilder<
                ProtoOnnx.TensorProto, ProtoOnnx.TensorProto.Builder, ProtoOnnx.TensorProtoOrBuilder> tBuilder_;
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
             * @return Whether the t field is set.
             */
            public boolean hasT() {
                return ((bitField0_ & 0x00000080) != 0);
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
             * @return The t.
             */
            public ProtoOnnx.TensorProto getT() {
                if (tBuilder_ == null) {
                    return t_ == null ? ProtoOnnx.TensorProto.getDefaultInstance() : t_;
                } else {
                    return tBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
             */
            public Builder setT(ProtoOnnx.TensorProto value) {
                if (tBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    t_ = value;
                } else {
                    tBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000080;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
             */
            public Builder setT(
                ProtoOnnx.TensorProto.Builder builderForValue) {
                if (tBuilder_ == null) {
                    t_ = builderForValue.build();
                } else {
                    tBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000080;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
             */
            public Builder mergeT(ProtoOnnx.TensorProto value) {
                if (tBuilder_ == null) {
                    if (((bitField0_ & 0x00000080) != 0) &&
                        t_ != null &&
                        t_ != ProtoOnnx.TensorProto.getDefaultInstance()) {
                        getTBuilder().mergeFrom(value);
                    } else {
                        t_ = value;
                    }
                } else {
                    tBuilder_.mergeFrom(value);
                }
                if (t_ != null) {
                    bitField0_ |= 0x00000080;
                    onChanged();
                }
                return this;
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
             */
            public Builder clearT() {
                bitField0_ = (bitField0_ & ~0x00000080);
                t_ = null;
                if (tBuilder_ != null) {
                    tBuilder_.dispose();
                    tBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
             */
            public ProtoOnnx.TensorProto.Builder getTBuilder() {
                bitField0_ |= 0x00000080;
                onChanged();
                return internalGetTFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
             */
            public ProtoOnnx.TensorProtoOrBuilder getTOrBuilder() {
                if (tBuilder_ != null) {
                    return tBuilder_.getMessageOrBuilder();
                } else {
                    return t_ == null ?
                        ProtoOnnx.TensorProto.getDefaultInstance() : t_;
                }
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto t = 5;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                ProtoOnnx.TensorProto, ProtoOnnx.TensorProto.Builder, ProtoOnnx.TensorProtoOrBuilder>
            internalGetTFieldBuilder() {
                if (tBuilder_ == null) {
                    tBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        ProtoOnnx.TensorProto, ProtoOnnx.TensorProto.Builder, ProtoOnnx.TensorProtoOrBuilder>(
                        getT(),
                        getParentForChildren(),
                        isClean());
                    t_ = null;
                }
                return tBuilder_;
            }
            
            private ProtoOnnx.GraphProto g_;
            private com.google.protobuf.SingleFieldBuilder<
                ProtoOnnx.GraphProto, ProtoOnnx.GraphProto.Builder, ProtoOnnx.GraphProtoOrBuilder> gBuilder_;
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
             * @return Whether the g field is set.
             */
            public boolean hasG() {
                return ((bitField0_ & 0x00000100) != 0);
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
             * @return The g.
             */
            public ProtoOnnx.GraphProto getG() {
                if (gBuilder_ == null) {
                    return g_ == null ? ProtoOnnx.GraphProto.getDefaultInstance() : g_;
                } else {
                    return gBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
             */
            public Builder setG(ProtoOnnx.GraphProto value) {
                if (gBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    g_ = value;
                } else {
                    gBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000100;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
             */
            public Builder setG(
                ProtoOnnx.GraphProto.Builder builderForValue) {
                if (gBuilder_ == null) {
                    g_ = builderForValue.build();
                } else {
                    gBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000100;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
             */
            public Builder mergeG(ProtoOnnx.GraphProto value) {
                if (gBuilder_ == null) {
                    if (((bitField0_ & 0x00000100) != 0) &&
                        g_ != null &&
                        g_ != ProtoOnnx.GraphProto.getDefaultInstance()) {
                        getGBuilder().mergeFrom(value);
                    } else {
                        g_ = value;
                    }
                } else {
                    gBuilder_.mergeFrom(value);
                }
                if (g_ != null) {
                    bitField0_ |= 0x00000100;
                    onChanged();
                }
                return this;
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
             */
            public Builder clearG() {
                bitField0_ = (bitField0_ & ~0x00000100);
                g_ = null;
                if (gBuilder_ != null) {
                    gBuilder_.dispose();
                    gBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
             */
            public ProtoOnnx.GraphProto.Builder getGBuilder() {
                bitField0_ |= 0x00000100;
                onChanged();
                return internalGetGFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
             */
            public ProtoOnnx.GraphProtoOrBuilder getGOrBuilder() {
                if (gBuilder_ != null) {
                    return gBuilder_.getMessageOrBuilder();
                } else {
                    return g_ == null ?
                        ProtoOnnx.GraphProto.getDefaultInstance() : g_;
                }
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto g = 6;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                ProtoOnnx.GraphProto, ProtoOnnx.GraphProto.Builder, ProtoOnnx.GraphProtoOrBuilder>
            internalGetGFieldBuilder() {
                if (gBuilder_ == null) {
                    gBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        ProtoOnnx.GraphProto, ProtoOnnx.GraphProto.Builder, ProtoOnnx.GraphProtoOrBuilder>(
                        getG(),
                        getParentForChildren(),
                        isClean());
                    g_ = null;
                }
                return gBuilder_;
            }
            
            private ProtoOnnx.SparseTensorProto sparseTensor_;
            private com.google.protobuf.SingleFieldBuilder<
                ProtoOnnx.SparseTensorProto, ProtoOnnx.SparseTensorProto.Builder, ProtoOnnx.SparseTensorProtoOrBuilder> sparseTensorBuilder_;
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
             * @return Whether the sparseTensor field is set.
             */
            public boolean hasSparseTensor() {
                return ((bitField0_ & 0x00000200) != 0);
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
             * @return The sparseTensor.
             */
            public ProtoOnnx.SparseTensorProto getSparseTensor() {
                if (sparseTensorBuilder_ == null) {
                    return sparseTensor_ == null ? ProtoOnnx.SparseTensorProto.getDefaultInstance() : sparseTensor_;
                } else {
                    return sparseTensorBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public Builder setSparseTensor(ProtoOnnx.SparseTensorProto value) {
                if (sparseTensorBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    sparseTensor_ = value;
                } else {
                    sparseTensorBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000200;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public Builder setSparseTensor(
                ProtoOnnx.SparseTensorProto.Builder builderForValue) {
                if (sparseTensorBuilder_ == null) {
                    sparseTensor_ = builderForValue.build();
                } else {
                    sparseTensorBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000200;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public Builder mergeSparseTensor(ProtoOnnx.SparseTensorProto value) {
                if (sparseTensorBuilder_ == null) {
                    if (((bitField0_ & 0x00000200) != 0) &&
                        sparseTensor_ != null &&
                        sparseTensor_ != ProtoOnnx.SparseTensorProto.getDefaultInstance()) {
                        getSparseTensorBuilder().mergeFrom(value);
                    } else {
                        sparseTensor_ = value;
                    }
                } else {
                    sparseTensorBuilder_.mergeFrom(value);
                }
                if (sparseTensor_ != null) {
                    bitField0_ |= 0x00000200;
                    onChanged();
                }
                return this;
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public Builder clearSparseTensor() {
                bitField0_ = (bitField0_ & ~0x00000200);
                sparseTensor_ = null;
                if (sparseTensorBuilder_ != null) {
                    sparseTensorBuilder_.dispose();
                    sparseTensorBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public ProtoOnnx.SparseTensorProto.Builder getSparseTensorBuilder() {
                bitField0_ |= 0x00000200;
                onChanged();
                return internalGetSparseTensorFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public ProtoOnnx.SparseTensorProtoOrBuilder getSparseTensorOrBuilder() {
                if (sparseTensorBuilder_ != null) {
                    return sparseTensorBuilder_.getMessageOrBuilder();
                } else {
                    return sparseTensor_ == null ?
                        ProtoOnnx.SparseTensorProto.getDefaultInstance() : sparseTensor_;
                }
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                ProtoOnnx.SparseTensorProto, ProtoOnnx.SparseTensorProto.Builder, ProtoOnnx.SparseTensorProtoOrBuilder>
            internalGetSparseTensorFieldBuilder() {
                if (sparseTensorBuilder_ == null) {
                    sparseTensorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        ProtoOnnx.SparseTensorProto, ProtoOnnx.SparseTensorProto.Builder, ProtoOnnx.SparseTensorProtoOrBuilder>(
                        getSparseTensor(),
                        getParentForChildren(),
                        isClean());
                    sparseTensor_ = null;
                }
                return sparseTensorBuilder_;
            }
            
            private ProtoOnnx.TypeProto tp_;
            private com.google.protobuf.SingleFieldBuilder<
                ProtoOnnx.TypeProto, ProtoOnnx.TypeProto.Builder, ProtoOnnx.TypeProtoOrBuilder> tpBuilder_;
            /**
             * <pre>
             * Do not use field below, it's deprecated.
             * optional ValueProto v = 12;         // value - subsumes everything but graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
             * @return Whether the tp field is set.
             */
            public boolean hasTp() {
                return ((bitField0_ & 0x00000400) != 0);
            }
            /**
             * <pre>
             * Do not use field below, it's deprecated.
             * optional ValueProto v = 12;         // value - subsumes everything but graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
             * @return The tp.
             */
            public ProtoOnnx.TypeProto getTp() {
                if (tpBuilder_ == null) {
                    return tp_ == null ? ProtoOnnx.TypeProto.getDefaultInstance() : tp_;
                } else {
                    return tpBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * Do not use field below, it's deprecated.
             * optional ValueProto v = 12;         // value - subsumes everything but graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
             */
            public Builder setTp(ProtoOnnx.TypeProto value) {
                if (tpBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    tp_ = value;
                } else {
                    tpBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000400;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Do not use field below, it's deprecated.
             * optional ValueProto v = 12;         // value - subsumes everything but graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
             */
            public Builder setTp(
                ProtoOnnx.TypeProto.Builder builderForValue) {
                if (tpBuilder_ == null) {
                    tp_ = builderForValue.build();
                } else {
                    tpBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000400;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Do not use field below, it's deprecated.
             * optional ValueProto v = 12;         // value - subsumes everything but graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
             */
            public Builder mergeTp(ProtoOnnx.TypeProto value) {
                if (tpBuilder_ == null) {
                    if (((bitField0_ & 0x00000400) != 0) &&
                        tp_ != null &&
                        tp_ != ProtoOnnx.TypeProto.getDefaultInstance()) {
                        getTpBuilder().mergeFrom(value);
                    } else {
                        tp_ = value;
                    }
                } else {
                    tpBuilder_.mergeFrom(value);
                }
                if (tp_ != null) {
                    bitField0_ |= 0x00000400;
                    onChanged();
                }
                return this;
            }
            /**
             * <pre>
             * Do not use field below, it's deprecated.
             * optional ValueProto v = 12;         // value - subsumes everything but graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
             */
            public Builder clearTp() {
                bitField0_ = (bitField0_ & ~0x00000400);
                tp_ = null;
                if (tpBuilder_ != null) {
                    tpBuilder_.dispose();
                    tpBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Do not use field below, it's deprecated.
             * optional ValueProto v = 12;         // value - subsumes everything but graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
             */
            public ProtoOnnx.TypeProto.Builder getTpBuilder() {
                bitField0_ |= 0x00000400;
                onChanged();
                return internalGetTpFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * Do not use field below, it's deprecated.
             * optional ValueProto v = 12;         // value - subsumes everything but graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
             */
            public ProtoOnnx.TypeProtoOrBuilder getTpOrBuilder() {
                if (tpBuilder_ != null) {
                    return tpBuilder_.getMessageOrBuilder();
                } else {
                    return tp_ == null ?
                        ProtoOnnx.TypeProto.getDefaultInstance() : tp_;
                }
            }
            /**
             * <pre>
             * Do not use field below, it's deprecated.
             * optional ValueProto v = 12;         // value - subsumes everything but graph
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto tp = 14;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                ProtoOnnx.TypeProto, ProtoOnnx.TypeProto.Builder, ProtoOnnx.TypeProtoOrBuilder>
            internalGetTpFieldBuilder() {
                if (tpBuilder_ == null) {
                    tpBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        ProtoOnnx.TypeProto, ProtoOnnx.TypeProto.Builder, ProtoOnnx.TypeProtoOrBuilder>(
                        getTp(),
                        getParentForChildren(),
                        isClean());
                    tp_ = null;
                }
                return tpBuilder_;
            }
            
            private com.google.protobuf.Internal.FloatList floats_ = emptyFloatList();
            private void ensureFloatsIsMutable() {
                if (!floats_.isModifiable()) {
                    floats_ = makeMutableCopy(floats_);
                }
                bitField0_ |= 0x00000800;
            }
            private void ensureFloatsIsMutable(int capacity) {
                if (!floats_.isModifiable()) {
                    floats_ = makeMutableCopy(floats_, capacity);
                }
                bitField0_ |= 0x00000800;
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @return A list containing the floats.
             */
            public java.util.List<java.lang.Float>
            getFloatsList() {
                floats_.makeImmutable();
                return floats_;
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @return The count of floats.
             */
            public int getFloatsCount() {
                return floats_.size();
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @param index The index of the element to return.
             * @return The floats at the given index.
             */
            public float getFloats(int index) {
                return floats_.getFloat(index);
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @param index The index to set the value at.
             * @param value The floats to set.
             * @return This builder for chaining.
             */
            public Builder setFloats(
                int index, float value) {
                
                ensureFloatsIsMutable();
                floats_.setFloat(index, value);
                bitField0_ |= 0x00000800;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @param value The floats to add.
             * @return This builder for chaining.
             */
            public Builder addFloats(float value) {
                
                ensureFloatsIsMutable();
                floats_.addFloat(value);
                bitField0_ |= 0x00000800;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @param values The floats to add.
             * @return This builder for chaining.
             */
            public Builder addAllFloats(
                java.lang.Iterable<? extends java.lang.Float> values) {
                ensureFloatsIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, floats_);
                bitField0_ |= 0x00000800;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @return This builder for chaining.
             */
            public Builder clearFloats() {
                floats_ = emptyFloatList();
                bitField0_ = (bitField0_ & ~0x00000800);
                onChanged();
                return this;
            }
            
            private com.google.protobuf.Internal.LongList ints_ = emptyLongList();
            private void ensureIntsIsMutable() {
                if (!ints_.isModifiable()) {
                    ints_ = makeMutableCopy(ints_);
                }
                bitField0_ |= 0x00001000;
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @return A list containing the ints.
             */
            public java.util.List<java.lang.Long>
            getIntsList() {
                ints_.makeImmutable();
                return ints_;
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @return The count of ints.
             */
            public int getIntsCount() {
                return ints_.size();
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @param index The index of the element to return.
             * @return The ints at the given index.
             */
            public long getInts(int index) {
                return ints_.getLong(index);
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @param index The index to set the value at.
             * @param value The ints to set.
             * @return This builder for chaining.
             */
            public Builder setInts(
                int index, long value) {
                
                ensureIntsIsMutable();
                ints_.setLong(index, value);
                bitField0_ |= 0x00001000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @param value The ints to add.
             * @return This builder for chaining.
             */
            public Builder addInts(long value) {
                
                ensureIntsIsMutable();
                ints_.addLong(value);
                bitField0_ |= 0x00001000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @param values The ints to add.
             * @return This builder for chaining.
             */
            public Builder addAllInts(
                java.lang.Iterable<? extends java.lang.Long> values) {
                ensureIntsIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, ints_);
                bitField0_ |= 0x00001000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @return This builder for chaining.
             */
            public Builder clearInts() {
                ints_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00001000);
                onChanged();
                return this;
            }
            
            private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> strings_ = emptyList(com.google.protobuf.ByteString.class);
            private void ensureStringsIsMutable() {
                if (!strings_.isModifiable()) {
                    strings_ = makeMutableCopy(strings_);
                }
                bitField0_ |= 0x00002000;
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @return A list containing the strings.
             */
            public java.util.List<com.google.protobuf.ByteString>
            getStringsList() {
                strings_.makeImmutable();
                return strings_;
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @return The count of strings.
             */
            public int getStringsCount() {
                return strings_.size();
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @param index The index of the element to return.
             * @return The strings at the given index.
             */
            public com.google.protobuf.ByteString getStrings(int index) {
                return strings_.get(index);
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @param index The index to set the value at.
             * @param value The strings to set.
             * @return This builder for chaining.
             */
            public Builder setStrings(
                int index, com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                ensureStringsIsMutable();
                strings_.set(index, value);
                bitField0_ |= 0x00002000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @param value The strings to add.
             * @return This builder for chaining.
             */
            public Builder addStrings(com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                ensureStringsIsMutable();
                strings_.add(value);
                bitField0_ |= 0x00002000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @param values The strings to add.
             * @return This builder for chaining.
             */
            public Builder addAllStrings(
                java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
                ensureStringsIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, strings_);
                bitField0_ |= 0x00002000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @return This builder for chaining.
             */
            public Builder clearStrings() {
                strings_ = emptyList(com.google.protobuf.ByteString.class);
                bitField0_ = (bitField0_ & ~0x00002000);
                onChanged();
                return this;
            }
            
            private java.util.List<ProtoOnnx.TensorProto> tensors_ =
                java.util.Collections.emptyList();
            private void ensureTensorsIsMutable() {
                if (!((bitField0_ & 0x00004000) != 0)) {
                    tensors_ = new java.util.ArrayList<ProtoOnnx.TensorProto>(tensors_);
                    bitField0_ |= 0x00004000;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.TensorProto, ProtoOnnx.TensorProto.Builder, ProtoOnnx.TensorProtoOrBuilder> tensorsBuilder_;
            
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public java.util.List<ProtoOnnx.TensorProto> getTensorsList() {
                if (tensorsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(tensors_);
                } else {
                    return tensorsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public int getTensorsCount() {
                if (tensorsBuilder_ == null) {
                    return tensors_.size();
                } else {
                    return tensorsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public ProtoOnnx.TensorProto getTensors(int index) {
                if (tensorsBuilder_ == null) {
                    return tensors_.get(index);
                } else {
                    return tensorsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public Builder setTensors(
                int index, ProtoOnnx.TensorProto value) {
                if (tensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTensorsIsMutable();
                    tensors_.set(index, value);
                    onChanged();
                } else {
                    tensorsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public Builder setTensors(
                int index, ProtoOnnx.TensorProto.Builder builderForValue) {
                if (tensorsBuilder_ == null) {
                    ensureTensorsIsMutable();
                    tensors_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    tensorsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public Builder addTensors(ProtoOnnx.TensorProto value) {
                if (tensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTensorsIsMutable();
                    tensors_.add(value);
                    onChanged();
                } else {
                    tensorsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public Builder addTensors(
                int index, ProtoOnnx.TensorProto value) {
                if (tensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTensorsIsMutable();
                    tensors_.add(index, value);
                    onChanged();
                } else {
                    tensorsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public Builder addTensors(
                ProtoOnnx.TensorProto.Builder builderForValue) {
                if (tensorsBuilder_ == null) {
                    ensureTensorsIsMutable();
                    tensors_.add(builderForValue.build());
                    onChanged();
                } else {
                    tensorsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public Builder addTensors(
                int index, ProtoOnnx.TensorProto.Builder builderForValue) {
                if (tensorsBuilder_ == null) {
                    ensureTensorsIsMutable();
                    tensors_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    tensorsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public Builder addAllTensors(
                java.lang.Iterable<? extends ProtoOnnx.TensorProto> values) {
                if (tensorsBuilder_ == null) {
                    ensureTensorsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, tensors_);
                    onChanged();
                } else {
                    tensorsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public Builder clearTensors() {
                if (tensorsBuilder_ == null) {
                    tensors_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00004000);
                    onChanged();
                } else {
                    tensorsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public Builder removeTensors(int index) {
                if (tensorsBuilder_ == null) {
                    ensureTensorsIsMutable();
                    tensors_.remove(index);
                    onChanged();
                } else {
                    tensorsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public ProtoOnnx.TensorProto.Builder getTensorsBuilder(
                int index) {
                return internalGetTensorsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public ProtoOnnx.TensorProtoOrBuilder getTensorsOrBuilder(
                int index) {
                if (tensorsBuilder_ == null) {
                    return tensors_.get(index);  } else {
                    return tensorsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public java.util.List<? extends ProtoOnnx.TensorProtoOrBuilder>
            getTensorsOrBuilderList() {
                if (tensorsBuilder_ != null) {
                    return tensorsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(tensors_);
                }
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public ProtoOnnx.TensorProto.Builder addTensorsBuilder() {
                return internalGetTensorsFieldBuilder().addBuilder(
                    ProtoOnnx.TensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public ProtoOnnx.TensorProto.Builder addTensorsBuilder(
                int index) {
                return internalGetTensorsFieldBuilder().addBuilder(
                    index, ProtoOnnx.TensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto tensors = 10;</code>
             */
            public java.util.List<ProtoOnnx.TensorProto.Builder>
            getTensorsBuilderList() {
                return internalGetTensorsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.TensorProto, ProtoOnnx.TensorProto.Builder, ProtoOnnx.TensorProtoOrBuilder>
            internalGetTensorsFieldBuilder() {
                if (tensorsBuilder_ == null) {
                    tensorsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.TensorProto, ProtoOnnx.TensorProto.Builder, ProtoOnnx.TensorProtoOrBuilder>(
                        tensors_,
                        ((bitField0_ & 0x00004000) != 0),
                        getParentForChildren(),
                        isClean());
                    tensors_ = null;
                }
                return tensorsBuilder_;
            }
            
            private java.util.List<ProtoOnnx.GraphProto> graphs_ =
                java.util.Collections.emptyList();
            private void ensureGraphsIsMutable() {
                if (!((bitField0_ & 0x00008000) != 0)) {
                    graphs_ = new java.util.ArrayList<ProtoOnnx.GraphProto>(graphs_);
                    bitField0_ |= 0x00008000;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.GraphProto, ProtoOnnx.GraphProto.Builder, ProtoOnnx.GraphProtoOrBuilder> graphsBuilder_;
            
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public java.util.List<ProtoOnnx.GraphProto> getGraphsList() {
                if (graphsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(graphs_);
                } else {
                    return graphsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public int getGraphsCount() {
                if (graphsBuilder_ == null) {
                    return graphs_.size();
                } else {
                    return graphsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public ProtoOnnx.GraphProto getGraphs(int index) {
                if (graphsBuilder_ == null) {
                    return graphs_.get(index);
                } else {
                    return graphsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public Builder setGraphs(
                int index, ProtoOnnx.GraphProto value) {
                if (graphsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureGraphsIsMutable();
                    graphs_.set(index, value);
                    onChanged();
                } else {
                    graphsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public Builder setGraphs(
                int index, ProtoOnnx.GraphProto.Builder builderForValue) {
                if (graphsBuilder_ == null) {
                    ensureGraphsIsMutable();
                    graphs_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    graphsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public Builder addGraphs(ProtoOnnx.GraphProto value) {
                if (graphsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureGraphsIsMutable();
                    graphs_.add(value);
                    onChanged();
                } else {
                    graphsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public Builder addGraphs(
                int index, ProtoOnnx.GraphProto value) {
                if (graphsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureGraphsIsMutable();
                    graphs_.add(index, value);
                    onChanged();
                } else {
                    graphsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public Builder addGraphs(
                ProtoOnnx.GraphProto.Builder builderForValue) {
                if (graphsBuilder_ == null) {
                    ensureGraphsIsMutable();
                    graphs_.add(builderForValue.build());
                    onChanged();
                } else {
                    graphsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public Builder addGraphs(
                int index, ProtoOnnx.GraphProto.Builder builderForValue) {
                if (graphsBuilder_ == null) {
                    ensureGraphsIsMutable();
                    graphs_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    graphsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public Builder addAllGraphs(
                java.lang.Iterable<? extends ProtoOnnx.GraphProto> values) {
                if (graphsBuilder_ == null) {
                    ensureGraphsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, graphs_);
                    onChanged();
                } else {
                    graphsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public Builder clearGraphs() {
                if (graphsBuilder_ == null) {
                    graphs_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00008000);
                    onChanged();
                } else {
                    graphsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public Builder removeGraphs(int index) {
                if (graphsBuilder_ == null) {
                    ensureGraphsIsMutable();
                    graphs_.remove(index);
                    onChanged();
                } else {
                    graphsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public ProtoOnnx.GraphProto.Builder getGraphsBuilder(
                int index) {
                return internalGetGraphsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public ProtoOnnx.GraphProtoOrBuilder getGraphsOrBuilder(
                int index) {
                if (graphsBuilder_ == null) {
                    return graphs_.get(index);  } else {
                    return graphsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public java.util.List<? extends ProtoOnnx.GraphProtoOrBuilder>
            getGraphsOrBuilderList() {
                if (graphsBuilder_ != null) {
                    return graphsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(graphs_);
                }
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public ProtoOnnx.GraphProto.Builder addGraphsBuilder() {
                return internalGetGraphsFieldBuilder().addBuilder(
                    ProtoOnnx.GraphProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public ProtoOnnx.GraphProto.Builder addGraphsBuilder(
                int index) {
                return internalGetGraphsFieldBuilder().addBuilder(
                    index, ProtoOnnx.GraphProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.GraphProto graphs = 11;</code>
             */
            public java.util.List<ProtoOnnx.GraphProto.Builder>
            getGraphsBuilderList() {
                return internalGetGraphsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.GraphProto, ProtoOnnx.GraphProto.Builder, ProtoOnnx.GraphProtoOrBuilder>
            internalGetGraphsFieldBuilder() {
                if (graphsBuilder_ == null) {
                    graphsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.GraphProto, ProtoOnnx.GraphProto.Builder, ProtoOnnx.GraphProtoOrBuilder>(
                        graphs_,
                        ((bitField0_ & 0x00008000) != 0),
                        getParentForChildren(),
                        isClean());
                    graphs_ = null;
                }
                return graphsBuilder_;
            }
            
            private java.util.List<ProtoOnnx.SparseTensorProto> sparseTensors_ =
                java.util.Collections.emptyList();
            private void ensureSparseTensorsIsMutable() {
                if (!((bitField0_ & 0x00010000) != 0)) {
                    sparseTensors_ = new java.util.ArrayList<ProtoOnnx.SparseTensorProto>(sparseTensors_);
                    bitField0_ |= 0x00010000;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.SparseTensorProto, ProtoOnnx.SparseTensorProto.Builder, ProtoOnnx.SparseTensorProtoOrBuilder> sparseTensorsBuilder_;
            
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public java.util.List<ProtoOnnx.SparseTensorProto> getSparseTensorsList() {
                if (sparseTensorsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(sparseTensors_);
                } else {
                    return sparseTensorsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public int getSparseTensorsCount() {
                if (sparseTensorsBuilder_ == null) {
                    return sparseTensors_.size();
                } else {
                    return sparseTensorsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public ProtoOnnx.SparseTensorProto getSparseTensors(int index) {
                if (sparseTensorsBuilder_ == null) {
                    return sparseTensors_.get(index);
                } else {
                    return sparseTensorsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder setSparseTensors(
                int index, ProtoOnnx.SparseTensorProto value) {
                if (sparseTensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.set(index, value);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder setSparseTensors(
                int index, ProtoOnnx.SparseTensorProto.Builder builderForValue) {
                if (sparseTensorsBuilder_ == null) {
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    sparseTensorsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder addSparseTensors(ProtoOnnx.SparseTensorProto value) {
                if (sparseTensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.add(value);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder addSparseTensors(
                int index, ProtoOnnx.SparseTensorProto value) {
                if (sparseTensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.add(index, value);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder addSparseTensors(
                ProtoOnnx.SparseTensorProto.Builder builderForValue) {
                if (sparseTensorsBuilder_ == null) {
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.add(builderForValue.build());
                    onChanged();
                } else {
                    sparseTensorsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder addSparseTensors(
                int index, ProtoOnnx.SparseTensorProto.Builder builderForValue) {
                if (sparseTensorsBuilder_ == null) {
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    sparseTensorsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder addAllSparseTensors(
                java.lang.Iterable<? extends ProtoOnnx.SparseTensorProto> values) {
                if (sparseTensorsBuilder_ == null) {
                    ensureSparseTensorsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, sparseTensors_);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder clearSparseTensors() {
                if (sparseTensorsBuilder_ == null) {
                    sparseTensors_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00010000);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder removeSparseTensors(int index) {
                if (sparseTensorsBuilder_ == null) {
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.remove(index);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public ProtoOnnx.SparseTensorProto.Builder getSparseTensorsBuilder(
                int index) {
                return internalGetSparseTensorsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public ProtoOnnx.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(
                int index) {
                if (sparseTensorsBuilder_ == null) {
                    return sparseTensors_.get(index);  } else {
                    return sparseTensorsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public java.util.List<? extends ProtoOnnx.SparseTensorProtoOrBuilder>
            getSparseTensorsOrBuilderList() {
                if (sparseTensorsBuilder_ != null) {
                    return sparseTensorsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(sparseTensors_);
                }
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public ProtoOnnx.SparseTensorProto.Builder addSparseTensorsBuilder() {
                return internalGetSparseTensorsFieldBuilder().addBuilder(
                    ProtoOnnx.SparseTensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public ProtoOnnx.SparseTensorProto.Builder addSparseTensorsBuilder(
                int index) {
                return internalGetSparseTensorsFieldBuilder().addBuilder(
                    index, ProtoOnnx.SparseTensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder>
            getSparseTensorsBuilderList() {
                return internalGetSparseTensorsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProtoOrBuilder>
            internalGetSparseTensorsFieldBuilder() {
                if (sparseTensorsBuilder_ == null) {
                    sparseTensorsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.SparseTensorProto, ProtoOnnx.SparseTensorProto.Builder, ProtoOnnx.SparseTensorProtoOrBuilder>(
                        sparseTensors_,
                        ((bitField0_ & 0x00010000) != 0),
                        getParentForChildren(),
                        isClean());
                    sparseTensors_ = null;
                }
                return sparseTensorsBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto> typeProtos_ =
                java.util.Collections.emptyList();
            private void ensureTypeProtosIsMutable() {
                if (!((bitField0_ & 0x00020000) != 0)) {
                    typeProtos_ = new java.util.ArrayList<ProtoOnnx.TypeProto>(typeProtos_);
                    bitField0_ |= 0x00020000;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder> typeProtosBuilder_;
            
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto> getTypeProtosList() {
                if (typeProtosBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(typeProtos_);
                } else {
                    return typeProtosBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public int getTypeProtosCount() {
                if (typeProtosBuilder_ == null) {
                    return typeProtos_.size();
                } else {
                    return typeProtosBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getTypeProtos(int index) {
                if (typeProtosBuilder_ == null) {
                    return typeProtos_.get(index);
                } else {
                    return typeProtosBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public Builder setTypeProtos(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto value) {
                if (typeProtosBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTypeProtosIsMutable();
                    typeProtos_.set(index, value);
                    onChanged();
                } else {
                    typeProtosBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public Builder setTypeProtos(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder builderForValue) {
                if (typeProtosBuilder_ == null) {
                    ensureTypeProtosIsMutable();
                    typeProtos_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    typeProtosBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public Builder addTypeProtos(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto value) {
                if (typeProtosBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTypeProtosIsMutable();
                    typeProtos_.add(value);
                    onChanged();
                } else {
                    typeProtosBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public Builder addTypeProtos(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto value) {
                if (typeProtosBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTypeProtosIsMutable();
                    typeProtos_.add(index, value);
                    onChanged();
                } else {
                    typeProtosBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public Builder addTypeProtos(
                ProtoOnnx.TypeProto.Builder builderForValue) {
                if (typeProtosBuilder_ == null) {
                    ensureTypeProtosIsMutable();
                    typeProtos_.add(builderForValue.build());
                    onChanged();
                } else {
                    typeProtosBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public Builder addTypeProtos(
                int index, ProtoOnnx.TypeProto.Builder builderForValue) {
                if (typeProtosBuilder_ == null) {
                    ensureTypeProtosIsMutable();
                    typeProtos_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    typeProtosBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public Builder addAllTypeProtos(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto> values) {
                if (typeProtosBuilder_ == null) {
                    ensureTypeProtosIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, typeProtos_);
                    onChanged();
                } else {
                    typeProtosBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public Builder clearTypeProtos() {
                if (typeProtosBuilder_ == null) {
                    typeProtos_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00020000);
                    onChanged();
                } else {
                    typeProtosBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public Builder removeTypeProtos(int index) {
                if (typeProtosBuilder_ == null) {
                    ensureTypeProtosIsMutable();
                    typeProtos_.remove(index);
                    onChanged();
                } else {
                    typeProtosBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder getTypeProtosBuilder(
                int index) {
                return internalGetTypeProtosFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder getTypeProtosOrBuilder(
                int index) {
                if (typeProtosBuilder_ == null) {
                    return typeProtos_.get(index);  } else {
                    return typeProtosBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder>
            getTypeProtosOrBuilderList() {
                if (typeProtosBuilder_ != null) {
                    return typeProtosBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(typeProtos_);
                }
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder addTypeProtosBuilder() {
                return internalGetTypeProtosFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder addTypeProtosBuilder(
                int index) {
                return internalGetTypeProtosFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of type protos
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TypeProto type_protos = 15;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder>
            getTypeProtosBuilderList() {
                return internalGetTypeProtosFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder>
            internalGetTypeProtosFieldBuilder() {
                if (typeProtosBuilder_ == null) {
                    typeProtosBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder>(
                        typeProtos_,
                        ((bitField0_ & 0x00020000) != 0),
                        getParentForChildren(),
                        isClean());
                    typeProtos_ = null;
                }
                return typeProtosBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.AttributeProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.AttributeProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<AttributeProto>
            PARSER = new com.google.protobuf.AbstractParser<AttributeProto>() {
            @java.lang.Override
            public AttributeProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<AttributeProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<AttributeProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface ValueInfoProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.ValueInfoProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();
        
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
         * @return Whether the type field is set.
         */
        boolean hasType();
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
         * @return The type.
         */
        ProtoOnnx.TypeProto getType();
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder getTypeOrBuilder();
        
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();
        
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
         */
        java.util.List<ProtoOnnx.StringStringEntryProto>
        getMetadataPropsList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index);
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
         */
        int getMetadataPropsCount();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index);
    }
    /**
     * <pre>
     * Defines information on value, including the name, the type, and
     * the shape of the value.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.ValueInfoProto}
     */
    public static final class ValueInfoProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.ValueInfoProto)
        ValueInfoProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                ValueInfoProto.class.getName());
        }
        // Use ValueInfoProto.newBuilder() to construct.
        private ValueInfoProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private ValueInfoProto() {
            name_ = "";
            docString_ = "";
            metadataProps_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ValueInfoProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ValueInfoProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int NAME_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private volatile java.lang.Object name_ = "";
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int TYPE_FIELD_NUMBER = 2;
        private org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto type_;
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
         * @return Whether the type field is set.
         */
        @java.lang.Override
        public boolean hasType() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
         * @return The type.
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getType() {
            return type_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : type_;
        }
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
         */
        @java.lang.Override
        public ProtoOnnx.TypeProtoOrBuilder getTypeOrBuilder() {
            return type_ == null ? ProtoOnnx.TypeProto.getDefaultInstance() : type_;
        }
        
        public static final int DOC_STRING_FIELD_NUMBER = 3;
        @SuppressWarnings("serial")
        private volatile java.lang.Object docString_ = "";
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int METADATA_PROPS_FIELD_NUMBER = 4;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> metadataProps_;
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
         */
        @java.lang.Override
        public int getMetadataPropsCount() {
            return metadataProps_.size();
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
            return metadataProps_.get(index);
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index) {
            return metadataProps_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeMessage(2, getType());
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 3, docString_);
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                output.writeMessage(4, metadataProps_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(2, getType());
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(3, docString_);
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(4, metadataProps_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto) obj;
            
            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                    .equals(other.getName())) return false;
            }
            if (hasType() != other.hasType()) return false;
            if (hasType()) {
                if (!getType()
                    .equals(other.getType())) return false;
            }
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                    .equals(other.getDocString())) return false;
            }
            if (!getMetadataPropsList()
                .equals(other.getMetadataPropsList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (hasType()) {
                hash = (37 * hash) + TYPE_FIELD_NUMBER;
                hash = (53 * hash) + getType().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (getMetadataPropsCount() > 0) {
                hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
                hash = (53 * hash) + getMetadataPropsList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.ValueInfoProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.ValueInfoProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static ProtoOnnx.ValueInfoProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ProtoOnnx.ValueInfoProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Defines information on value, including the name, the type, and
         * the shape of the value.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.ValueInfoProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.ValueInfoProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ValueInfoProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ValueInfoProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessage
                    .alwaysUseFieldBuilders) {
                    internalGetTypeFieldBuilder();
                    internalGetMetadataPropsFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                name_ = "";
                type_ = null;
                if (typeBuilder_ != null) {
                    typeBuilder_.dispose();
                    typeBuilder_ = null;
                }
                docString_ = "";
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                } else {
                    metadataProps_ = null;
                    metadataPropsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000008);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ValueInfoProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getDefaultInstanceForType() {
                return ProtoOnnx.ValueInfoProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto result) {
                if (metadataPropsBuilder_ == null) {
                    if (((bitField0_ & 0x00000008) != 0)) {
                        metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
                        bitField0_ = (bitField0_ & ~0x00000008);
                    }
                    result.metadataProps_ = metadataProps_;
                } else {
                    result.metadataProps_ = metadataPropsBuilder_.build();
                }
            }
            
            private void buildPartial0(ProtoOnnx.ValueInfoProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.name_ = name_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.type_ = typeBuilder_ == null
                        ? type_
                        : typeBuilder_.build();
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    result.docString_ = docString_;
                    to_bitField0_ |= 0x00000004;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ProtoOnnx.ValueInfoProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.getDefaultInstance()) return this;
                if (other.hasName()) {
                    name_ = other.name_;
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                if (other.hasType()) {
                    mergeType(other.getType());
                }
                if (other.hasDocString()) {
                    docString_ = other.docString_;
                    bitField0_ |= 0x00000004;
                    onChanged();
                }
                if (metadataPropsBuilder_ == null) {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataProps_.isEmpty()) {
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                        } else {
                            ensureMetadataPropsIsMutable();
                            metadataProps_.addAll(other.metadataProps_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataPropsBuilder_.isEmpty()) {
                            metadataPropsBuilder_.dispose();
                            metadataPropsBuilder_ = null;
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                            metadataPropsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetMetadataPropsFieldBuilder() : null;
                        } else {
                            metadataPropsBuilder_.addAllMessages(other.metadataProps_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                name_ = input.readBytes();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 18: {
                                input.readMessage(
                                    internalGetTypeFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 18
                            case 26: {
                                docString_ = input.readBytes();
                                bitField0_ |= 0x00000004;
                                break;
                            } // case 26
                            case 34: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.parser(),
                                        extensionRegistry);
                                if (metadataPropsBuilder_ == null) {
                                    ensureMetadataPropsIsMutable();
                                    metadataProps_.add(m);
                                } else {
                                    metadataPropsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 34
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.lang.Object name_ = "";
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                name_ = getDefaultInstance().getName();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            
            private org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto type_;
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder> typeBuilder_;
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
             * @return Whether the type field is set.
             */
            public boolean hasType() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
             * @return The type.
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getType() {
                if (typeBuilder_ == null) {
                    return type_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : type_;
                } else {
                    return typeBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
             */
            public Builder setType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto value) {
                if (typeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    type_ = value;
                } else {
                    typeBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
             */
            public Builder setType(
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder builderForValue) {
                if (typeBuilder_ == null) {
                    type_ = builderForValue.build();
                } else {
                    typeBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
             */
            public Builder mergeType(ProtoOnnx.TypeProto value) {
                if (typeBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0) &&
                        type_ != null &&
                        type_ != org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance()) {
                        getTypeBuilder().mergeFrom(value);
                    } else {
                        type_ = value;
                    }
                } else {
                    typeBuilder_.mergeFrom(value);
                }
                if (type_ != null) {
                    bitField0_ |= 0x00000002;
                    onChanged();
                }
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
             */
            public Builder clearType() {
                bitField0_ = (bitField0_ & ~0x00000002);
                type_ = null;
                if (typeBuilder_ != null) {
                    typeBuilder_.dispose();
                    typeBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder getTypeBuilder() {
                bitField0_ |= 0x00000002;
                onChanged();
                return internalGetTypeFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
             */
            public ProtoOnnx.TypeProtoOrBuilder getTypeOrBuilder() {
                if (typeBuilder_ != null) {
                    return typeBuilder_.getMessageOrBuilder();
                } else {
                    return type_ == null ?
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : type_;
                }
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto type = 2;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder>
            internalGetTypeFieldBuilder() {
                if (typeBuilder_ == null) {
                    typeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, ProtoOnnx.TypeProto.Builder, ProtoOnnx.TypeProtoOrBuilder>(
                        getType(),
                        getParentForChildren(),
                        isClean());
                    type_ = null;
                }
                return typeBuilder_;
            }
            
            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                docString_ = getDefaultInstance().getDocString();
                bitField0_ = (bitField0_ & ~0x00000004);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> metadataProps_ =
                java.util.Collections.emptyList();
            private void ensureMetadataPropsIsMutable() {
                if (!((bitField0_ & 0x00000008) != 0)) {
                    metadataProps_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>(metadataProps_);
                    bitField0_ |= 0x00000008;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;
            
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
                if (metadataPropsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                } else {
                    return metadataPropsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public int getMetadataPropsCount() {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.size();
                } else {
                    return metadataPropsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);
                } else {
                    return metadataPropsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public Builder setMetadataProps(
                int index, ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public Builder setMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public Builder addMetadataProps(org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public Builder addMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public Builder addMetadataProps(
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public Builder addMetadataProps(
                int index, ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public Builder addAllMetadataProps(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> values) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, metadataProps_);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public Builder clearMetadataProps() {
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000008);
                    onChanged();
                } else {
                    metadataPropsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public Builder removeMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.remove(index);
                    onChanged();
                } else {
                    metadataPropsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
                int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);  } else {
                    return metadataPropsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            getMetadataPropsOrBuilderList() {
                if (metadataPropsBuilder_ != null) {
                    return metadataPropsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    index, ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 4;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder>
            getMetadataPropsBuilderList() {
                return internalGetMetadataPropsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, ProtoOnnx.StringStringEntryProtoOrBuilder>
            internalGetMetadataPropsFieldBuilder() {
                if (metadataPropsBuilder_ == null) {
                    metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>(
                        metadataProps_,
                        ((bitField0_ & 0x00000008) != 0),
                        getParentForChildren(),
                        isClean());
                    metadataProps_ = null;
                }
                return metadataPropsBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.ValueInfoProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.ValueInfoProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<ValueInfoProto>
            PARSER = new com.google.protobuf.AbstractParser<ValueInfoProto>() {
            @java.lang.Override
            public ValueInfoProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<ValueInfoProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<ValueInfoProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public ProtoOnnx.ValueInfoProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface NodeProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.NodeProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @return A list containing the input.
         */
        java.util.List<java.lang.String>
        getInputList();
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @return The count of input.
         */
        int getInputCount();
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @param index The index of the element to return.
         * @return The input at the given index.
         */
        java.lang.String getInput(int index);
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @param index The index of the value to return.
         * @return The bytes of the input at the given index.
         */
        com.google.protobuf.ByteString
        getInputBytes(int index);
        
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @return A list containing the output.
         */
        java.util.List<java.lang.String>
        getOutputList();
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @return The count of output.
         */
        int getOutputCount();
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @param index The index of the element to return.
         * @return The output at the given index.
         */
        java.lang.String getOutput(int index);
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @param index The index of the value to return.
         * @return The bytes of the output at the given index.
         */
        com.google.protobuf.ByteString
        getOutputBytes(int index);
        
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();
        
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return Whether the opType field is set.
         */
        boolean hasOpType();
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return The opType.
         */
        java.lang.String getOpType();
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return The bytes for opType.
         */
        com.google.protobuf.ByteString
        getOpTypeBytes();
        
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return Whether the domain field is set.
         */
        boolean hasDomain();
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return The domain.
         */
        java.lang.String getDomain();
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return The bytes for domain.
         */
        com.google.protobuf.ByteString
        getDomainBytes();
        
        /**
         * <pre>
         * Overload identifier, used only to map this to a model-local function.
         * </pre>
         *
         * <code>optional string overload = 8;</code>
         * @return Whether the overload field is set.
         */
        boolean hasOverload();
        /**
         * <pre>
         * Overload identifier, used only to map this to a model-local function.
         * </pre>
         *
         * <code>optional string overload = 8;</code>
         * @return The overload.
         */
        java.lang.String getOverload();
        /**
         * <pre>
         * Overload identifier, used only to map this to a model-local function.
         * </pre>
         *
         * <code>optional string overload = 8;</code>
         * @return The bytes for overload.
         */
        com.google.protobuf.ByteString
        getOverloadBytes();
        
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto>
        getAttributeList();
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
         */
        ProtoOnnx.AttributeProto getAttribute(int index);
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
         */
        int getAttributeCount();
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder>
        getAttributeOrBuilderList();
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder getAttributeOrBuilder(
            int index);
        
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();
        
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>
        getMetadataPropsList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index);
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
         */
        int getMetadataPropsCount();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index);
        
        /**
         * <pre>
         * Configuration of multi-device annotations.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto>
        getDeviceConfigurationsList();
        /**
         * <pre>
         * Configuration of multi-device annotations.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto getDeviceConfigurations(int index);
        /**
         * <pre>
         * Configuration of multi-device annotations.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
         */
        int getDeviceConfigurationsCount();
        /**
         * <pre>
         * Configuration of multi-device annotations.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProtoOrBuilder>
        getDeviceConfigurationsOrBuilderList();
        /**
         * <pre>
         * Configuration of multi-device annotations.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProtoOrBuilder getDeviceConfigurationsOrBuilder(
            int index);
    }
    /**
     * <pre>
     * Nodes
     *
     * Computation graphs are made up of a DAG of nodes, which represent what is
     * commonly called a "layer" or "pipeline stage" in machine learning frameworks.
     *
     * For example, it can be a node of type "Conv" that takes in an image, a filter
     * tensor and a bias tensor, and produces the convolved output.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.NodeProto}
     */
    public static final class NodeProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.NodeProto)
        NodeProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                NodeProto.class.getName());
        }
        // Use NodeProto.newBuilder() to construct.
        private NodeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private NodeProto() {
            input_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            output_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            name_ = "";
            opType_ = "";
            domain_ = "";
            overload_ = "";
            attribute_ = java.util.Collections.emptyList();
            docString_ = "";
            metadataProps_ = java.util.Collections.emptyList();
            deviceConfigurations_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_NodeProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_NodeProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int INPUT_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private com.google.protobuf.LazyStringArrayList input_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @return A list containing the input.
         */
        public com.google.protobuf.ProtocolStringList
        getInputList() {
            return input_;
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @return The count of input.
         */
        public int getInputCount() {
            return input_.size();
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @param index The index of the element to return.
         * @return The input at the given index.
         */
        public java.lang.String getInput(int index) {
            return input_.get(index);
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @param index The index of the value to return.
         * @return The bytes of the input at the given index.
         */
        public com.google.protobuf.ByteString
        getInputBytes(int index) {
            return input_.getByteString(index);
        }
        
        public static final int OUTPUT_FIELD_NUMBER = 2;
        @SuppressWarnings("serial")
        private com.google.protobuf.LazyStringArrayList output_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @return A list containing the output.
         */
        public com.google.protobuf.ProtocolStringList
        getOutputList() {
            return output_;
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @return The count of output.
         */
        public int getOutputCount() {
            return output_.size();
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @param index The index of the element to return.
         * @return The output at the given index.
         */
        public java.lang.String getOutput(int index) {
            return output_.get(index);
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @param index The index of the value to return.
         * @return The bytes of the output at the given index.
         */
        public com.google.protobuf.ByteString
        getOutputBytes(int index) {
            return output_.getByteString(index);
        }
        
        public static final int NAME_FIELD_NUMBER = 3;
        @SuppressWarnings("serial")
        private volatile java.lang.Object name_ = "";
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int OP_TYPE_FIELD_NUMBER = 4;
        @SuppressWarnings("serial")
        private volatile java.lang.Object opType_ = "";
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return Whether the opType field is set.
         */
        @java.lang.Override
        public boolean hasOpType() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return The opType.
         */
        @java.lang.Override
        public java.lang.String getOpType() {
            java.lang.Object ref = opType_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    opType_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return The bytes for opType.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getOpTypeBytes() {
            java.lang.Object ref = opType_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                opType_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int DOMAIN_FIELD_NUMBER = 7;
        @SuppressWarnings("serial")
        private volatile java.lang.Object domain_ = "";
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return Whether the domain field is set.
         */
        @java.lang.Override
        public boolean hasDomain() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return The domain.
         */
        @java.lang.Override
        public java.lang.String getDomain() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    domain_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return The bytes for domain.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDomainBytes() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                domain_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int OVERLOAD_FIELD_NUMBER = 8;
        @SuppressWarnings("serial")
        private volatile java.lang.Object overload_ = "";
        /**
         * <pre>
         * Overload identifier, used only to map this to a model-local function.
         * </pre>
         *
         * <code>optional string overload = 8;</code>
         * @return Whether the overload field is set.
         */
        @java.lang.Override
        public boolean hasOverload() {
            return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * Overload identifier, used only to map this to a model-local function.
         * </pre>
         *
         * <code>optional string overload = 8;</code>
         * @return The overload.
         */
        @java.lang.Override
        public java.lang.String getOverload() {
            java.lang.Object ref = overload_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    overload_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * Overload identifier, used only to map this to a model-local function.
         * </pre>
         *
         * <code>optional string overload = 8;</code>
         * @return The bytes for overload.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getOverloadBytes() {
            java.lang.Object ref = overload_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                overload_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int ATTRIBUTE_FIELD_NUMBER = 5;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto> attribute_;
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.AttributeProto> getAttributeList() {
            return attribute_;
        }
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder>
        getAttributeOrBuilderList() {
            return attribute_;
        }
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
         */
        @java.lang.Override
        public int getAttributeCount() {
            return attribute_.size();
        }
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto getAttribute(int index) {
            return attribute_.get(index);
        }
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder getAttributeOrBuilder(
            int index) {
            return attribute_.get(index);
        }
        
        public static final int DOC_STRING_FIELD_NUMBER = 6;
        @SuppressWarnings("serial")
        private volatile java.lang.Object docString_ = "";
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int METADATA_PROPS_FIELD_NUMBER = 9;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> metadataProps_;
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
         */
        @java.lang.Override
        public int getMetadataPropsCount() {
            return metadataProps_.size();
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
         */
        @java.lang.Override
        public ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
            return metadataProps_.get(index);
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index) {
            return metadataProps_.get(index);
        }
        
        public static final int DEVICE_CONFIGURATIONS_FIELD_NUMBER = 10;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto> deviceConfigurations_;
        /**
         * <pre>
         * Configuration of multi-device annotations.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto> getDeviceConfigurationsList() {
            return deviceConfigurations_;
        }
        /**
         * <pre>
         * Configuration of multi-device annotations.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProtoOrBuilder>
        getDeviceConfigurationsOrBuilderList() {
            return deviceConfigurations_;
        }
        /**
         * <pre>
         * Configuration of multi-device annotations.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
         */
        @java.lang.Override
        public int getDeviceConfigurationsCount() {
            return deviceConfigurations_.size();
        }
        /**
         * <pre>
         * Configuration of multi-device annotations.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto getDeviceConfigurations(int index) {
            return deviceConfigurations_.get(index);
        }
        /**
         * <pre>
         * Configuration of multi-device annotations.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProtoOrBuilder getDeviceConfigurationsOrBuilder(
            int index) {
            return deviceConfigurations_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            for (int i = 0; i < input_.size(); i++) {
                com.google.protobuf.GeneratedMessage.writeString(output, 1, input_.getRaw(i));
            }
            for (int i = 0; i < output_.size(); i++) {
                com.google.protobuf.GeneratedMessage.writeString(output, 2, output_.getRaw(i));
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 3, name_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 4, opType_);
            }
            for (int i = 0; i < attribute_.size(); i++) {
                output.writeMessage(5, attribute_.get(i));
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 6, docString_);
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 7, domain_);
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 8, overload_);
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                output.writeMessage(9, metadataProps_.get(i));
            }
            for (int i = 0; i < deviceConfigurations_.size(); i++) {
                output.writeMessage(10, deviceConfigurations_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            {
                int dataSize = 0;
                for (int i = 0; i < input_.size(); i++) {
                    dataSize += computeStringSizeNoTag(input_.getRaw(i));
                }
                size += dataSize;
                size += 1 * getInputList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < output_.size(); i++) {
                    dataSize += computeStringSizeNoTag(output_.getRaw(i));
                }
                size += dataSize;
                size += 1 * getOutputList().size();
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(3, name_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(4, opType_);
            }
            for (int i = 0; i < attribute_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(5, attribute_.get(i));
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(6, docString_);
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(7, domain_);
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(8, overload_);
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(9, metadataProps_.get(i));
            }
            for (int i = 0; i < deviceConfigurations_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(10, deviceConfigurations_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto) obj;
            
            if (!getInputList()
                .equals(other.getInputList())) return false;
            if (!getOutputList()
                .equals(other.getOutputList())) return false;
            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                    .equals(other.getName())) return false;
            }
            if (hasOpType() != other.hasOpType()) return false;
            if (hasOpType()) {
                if (!getOpType()
                    .equals(other.getOpType())) return false;
            }
            if (hasDomain() != other.hasDomain()) return false;
            if (hasDomain()) {
                if (!getDomain()
                    .equals(other.getDomain())) return false;
            }
            if (hasOverload() != other.hasOverload()) return false;
            if (hasOverload()) {
                if (!getOverload()
                    .equals(other.getOverload())) return false;
            }
            if (!getAttributeList()
                .equals(other.getAttributeList())) return false;
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                    .equals(other.getDocString())) return false;
            }
            if (!getMetadataPropsList()
                .equals(other.getMetadataPropsList())) return false;
            if (!getDeviceConfigurationsList()
                .equals(other.getDeviceConfigurationsList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getInputCount() > 0) {
                hash = (37 * hash) + INPUT_FIELD_NUMBER;
                hash = (53 * hash) + getInputList().hashCode();
            }
            if (getOutputCount() > 0) {
                hash = (37 * hash) + OUTPUT_FIELD_NUMBER;
                hash = (53 * hash) + getOutputList().hashCode();
            }
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (hasOpType()) {
                hash = (37 * hash) + OP_TYPE_FIELD_NUMBER;
                hash = (53 * hash) + getOpType().hashCode();
            }
            if (hasDomain()) {
                hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
                hash = (53 * hash) + getDomain().hashCode();
            }
            if (hasOverload()) {
                hash = (37 * hash) + OVERLOAD_FIELD_NUMBER;
                hash = (53 * hash) + getOverload().hashCode();
            }
            if (getAttributeCount() > 0) {
                hash = (37 * hash) + ATTRIBUTE_FIELD_NUMBER;
                hash = (53 * hash) + getAttributeList().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (getMetadataPropsCount() > 0) {
                hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
                hash = (53 * hash) + getMetadataPropsList().hashCode();
            }
            if (getDeviceConfigurationsCount() > 0) {
                hash = (37 * hash) + DEVICE_CONFIGURATIONS_FIELD_NUMBER;
                hash = (53 * hash) + getDeviceConfigurationsList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.NodeProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.NodeProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static ProtoOnnx.NodeProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ProtoOnnx.NodeProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static ProtoOnnx.NodeProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Nodes
         *
         * Computation graphs are made up of a DAG of nodes, which represent what is
         * commonly called a "layer" or "pipeline stage" in machine learning frameworks.
         *
         * For example, it can be a node of type "Conv" that takes in an image, a filter
         * tensor and a bias tensor, and produces the convolved output.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.NodeProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.NodeProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_NodeProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_NodeProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                input_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                output_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                name_ = "";
                opType_ = "";
                domain_ = "";
                overload_ = "";
                if (attributeBuilder_ == null) {
                    attribute_ = java.util.Collections.emptyList();
                } else {
                    attribute_ = null;
                    attributeBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000040);
                docString_ = "";
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                } else {
                    metadataProps_ = null;
                    metadataPropsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000100);
                if (deviceConfigurationsBuilder_ == null) {
                    deviceConfigurations_ = java.util.Collections.emptyList();
                } else {
                    deviceConfigurations_ = null;
                    deviceConfigurationsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000200);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_NodeProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto result) {
                if (attributeBuilder_ == null) {
                    if (((bitField0_ & 0x00000040) != 0)) {
                        attribute_ = java.util.Collections.unmodifiableList(attribute_);
                        bitField0_ = (bitField0_ & ~0x00000040);
                    }
                    result.attribute_ = attribute_;
                } else {
                    result.attribute_ = attributeBuilder_.build();
                }
                if (metadataPropsBuilder_ == null) {
                    if (((bitField0_ & 0x00000100) != 0)) {
                        metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
                        bitField0_ = (bitField0_ & ~0x00000100);
                    }
                    result.metadataProps_ = metadataProps_;
                } else {
                    result.metadataProps_ = metadataPropsBuilder_.build();
                }
                if (deviceConfigurationsBuilder_ == null) {
                    if (((bitField0_ & 0x00000200) != 0)) {
                        deviceConfigurations_ = java.util.Collections.unmodifiableList(deviceConfigurations_);
                        bitField0_ = (bitField0_ & ~0x00000200);
                    }
                    result.deviceConfigurations_ = deviceConfigurations_;
                } else {
                    result.deviceConfigurations_ = deviceConfigurationsBuilder_.build();
                }
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto result) {
                int from_bitField0_ = bitField0_;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    input_.makeImmutable();
                    result.input_ = input_;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    output_.makeImmutable();
                    result.output_ = output_;
                }
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    result.name_ = name_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000008) != 0)) {
                    result.opType_ = opType_;
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000010) != 0)) {
                    result.domain_ = domain_;
                    to_bitField0_ |= 0x00000004;
                }
                if (((from_bitField0_ & 0x00000020) != 0)) {
                    result.overload_ = overload_;
                    to_bitField0_ |= 0x00000008;
                }
                if (((from_bitField0_ & 0x00000080) != 0)) {
                    result.docString_ = docString_;
                    to_bitField0_ |= 0x00000010;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto other) {
                if (other == ProtoOnnx.NodeProto.getDefaultInstance()) return this;
                if (!other.input_.isEmpty()) {
                    if (input_.isEmpty()) {
                        input_ = other.input_;
                        bitField0_ |= 0x00000001;
                    } else {
                        ensureInputIsMutable();
                        input_.addAll(other.input_);
                    }
                    onChanged();
                }
                if (!other.output_.isEmpty()) {
                    if (output_.isEmpty()) {
                        output_ = other.output_;
                        bitField0_ |= 0x00000002;
                    } else {
                        ensureOutputIsMutable();
                        output_.addAll(other.output_);
                    }
                    onChanged();
                }
                if (other.hasName()) {
                    name_ = other.name_;
                    bitField0_ |= 0x00000004;
                    onChanged();
                }
                if (other.hasOpType()) {
                    opType_ = other.opType_;
                    bitField0_ |= 0x00000008;
                    onChanged();
                }
                if (other.hasDomain()) {
                    domain_ = other.domain_;
                    bitField0_ |= 0x00000010;
                    onChanged();
                }
                if (other.hasOverload()) {
                    overload_ = other.overload_;
                    bitField0_ |= 0x00000020;
                    onChanged();
                }
                if (attributeBuilder_ == null) {
                    if (!other.attribute_.isEmpty()) {
                        if (attribute_.isEmpty()) {
                            attribute_ = other.attribute_;
                            bitField0_ = (bitField0_ & ~0x00000040);
                        } else {
                            ensureAttributeIsMutable();
                            attribute_.addAll(other.attribute_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.attribute_.isEmpty()) {
                        if (attributeBuilder_.isEmpty()) {
                            attributeBuilder_.dispose();
                            attributeBuilder_ = null;
                            attribute_ = other.attribute_;
                            bitField0_ = (bitField0_ & ~0x00000040);
                            attributeBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetAttributeFieldBuilder() : null;
                        } else {
                            attributeBuilder_.addAllMessages(other.attribute_);
                        }
                    }
                }
                if (other.hasDocString()) {
                    docString_ = other.docString_;
                    bitField0_ |= 0x00000080;
                    onChanged();
                }
                if (metadataPropsBuilder_ == null) {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataProps_.isEmpty()) {
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000100);
                        } else {
                            ensureMetadataPropsIsMutable();
                            metadataProps_.addAll(other.metadataProps_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataPropsBuilder_.isEmpty()) {
                            metadataPropsBuilder_.dispose();
                            metadataPropsBuilder_ = null;
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000100);
                            metadataPropsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetMetadataPropsFieldBuilder() : null;
                        } else {
                            metadataPropsBuilder_.addAllMessages(other.metadataProps_);
                        }
                    }
                }
                if (deviceConfigurationsBuilder_ == null) {
                    if (!other.deviceConfigurations_.isEmpty()) {
                        if (deviceConfigurations_.isEmpty()) {
                            deviceConfigurations_ = other.deviceConfigurations_;
                            bitField0_ = (bitField0_ & ~0x00000200);
                        } else {
                            ensureDeviceConfigurationsIsMutable();
                            deviceConfigurations_.addAll(other.deviceConfigurations_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.deviceConfigurations_.isEmpty()) {
                        if (deviceConfigurationsBuilder_.isEmpty()) {
                            deviceConfigurationsBuilder_.dispose();
                            deviceConfigurationsBuilder_ = null;
                            deviceConfigurations_ = other.deviceConfigurations_;
                            bitField0_ = (bitField0_ & ~0x00000200);
                            deviceConfigurationsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetDeviceConfigurationsFieldBuilder() : null;
                        } else {
                            deviceConfigurationsBuilder_.addAllMessages(other.deviceConfigurations_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                ensureInputIsMutable();
                                input_.add(bs);
                                break;
                            } // case 10
                            case 18: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                ensureOutputIsMutable();
                                output_.add(bs);
                                break;
                            } // case 18
                            case 26: {
                                name_ = input.readBytes();
                                bitField0_ |= 0x00000004;
                                break;
                            } // case 26
                            case 34: {
                                opType_ = input.readBytes();
                                bitField0_ |= 0x00000008;
                                break;
                            } // case 34
                            case 42: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.parser(),
                                        extensionRegistry);
                                if (attributeBuilder_ == null) {
                                    ensureAttributeIsMutable();
                                    attribute_.add(m);
                                } else {
                                    attributeBuilder_.addMessage(m);
                                }
                                break;
                            } // case 42
                            case 50: {
                                docString_ = input.readBytes();
                                bitField0_ |= 0x00000080;
                                break;
                            } // case 50
                            case 58: {
                                domain_ = input.readBytes();
                                bitField0_ |= 0x00000010;
                                break;
                            } // case 58
                            case 66: {
                                overload_ = input.readBytes();
                                bitField0_ |= 0x00000020;
                                break;
                            } // case 66
                            case 74: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.parser(),
                                        extensionRegistry);
                                if (metadataPropsBuilder_ == null) {
                                    ensureMetadataPropsIsMutable();
                                    metadataProps_.add(m);
                                } else {
                                    metadataPropsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 74
                            case 82: {
                                ProtoOnnx.NodeDeviceConfigurationProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.parser(),
                                        extensionRegistry);
                                if (deviceConfigurationsBuilder_ == null) {
                                    ensureDeviceConfigurationsIsMutable();
                                    deviceConfigurations_.add(m);
                                } else {
                                    deviceConfigurationsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 82
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private com.google.protobuf.LazyStringArrayList input_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            private void ensureInputIsMutable() {
                if (!input_.isModifiable()) {
                    input_ = new com.google.protobuf.LazyStringArrayList(input_);
                }
                bitField0_ |= 0x00000001;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @return A list containing the input.
             */
            public com.google.protobuf.ProtocolStringList
            getInputList() {
                input_.makeImmutable();
                return input_;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @return The count of input.
             */
            public int getInputCount() {
                return input_.size();
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param index The index of the element to return.
             * @return The input at the given index.
             */
            public java.lang.String getInput(int index) {
                return input_.get(index);
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param index The index of the value to return.
             * @return The bytes of the input at the given index.
             */
            public com.google.protobuf.ByteString
            getInputBytes(int index) {
                return input_.getByteString(index);
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param index The index to set the value at.
             * @param value The input to set.
             * @return This builder for chaining.
             */
            public Builder setInput(
                int index, java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureInputIsMutable();
                input_.set(index, value);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param value The input to add.
             * @return This builder for chaining.
             */
            public Builder addInput(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureInputIsMutable();
                input_.add(value);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param values The input to add.
             * @return This builder for chaining.
             */
            public Builder addAllInput(
                java.lang.Iterable<java.lang.String> values) {
                ensureInputIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, input_);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearInput() {
                input_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                bitField0_ = (bitField0_ & ~0x00000001);;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param value The bytes of the input to add.
             * @return This builder for chaining.
             */
            public Builder addInputBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                ensureInputIsMutable();
                input_.add(value);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            
            private com.google.protobuf.LazyStringArrayList output_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            private void ensureOutputIsMutable() {
                if (!output_.isModifiable()) {
                    output_ = new com.google.protobuf.LazyStringArrayList(output_);
                }
                bitField0_ |= 0x00000002;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @return A list containing the output.
             */
            public com.google.protobuf.ProtocolStringList
            getOutputList() {
                output_.makeImmutable();
                return output_;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @return The count of output.
             */
            public int getOutputCount() {
                return output_.size();
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param index The index of the element to return.
             * @return The output at the given index.
             */
            public java.lang.String getOutput(int index) {
                return output_.get(index);
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param index The index of the value to return.
             * @return The bytes of the output at the given index.
             */
            public com.google.protobuf.ByteString
            getOutputBytes(int index) {
                return output_.getByteString(index);
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param index The index to set the value at.
             * @param value The output to set.
             * @return This builder for chaining.
             */
            public Builder setOutput(
                int index, java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureOutputIsMutable();
                output_.set(index, value);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param value The output to add.
             * @return This builder for chaining.
             */
            public Builder addOutput(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureOutputIsMutable();
                output_.add(value);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param values The output to add.
             * @return This builder for chaining.
             */
            public Builder addAllOutput(
                java.lang.Iterable<java.lang.String> values) {
                ensureOutputIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, output_);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearOutput() {
                output_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                bitField0_ = (bitField0_ & ~0x00000002);;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param value The bytes of the output to add.
             * @return This builder for chaining.
             */
            public Builder addOutputBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                ensureOutputIsMutable();
                output_.add(value);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            
            private java.lang.Object name_ = "";
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                name_ = getDefaultInstance().getName();
                bitField0_ = (bitField0_ & ~0x00000004);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            
            private java.lang.Object opType_ = "";
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @return Whether the opType field is set.
             */
            public boolean hasOpType() {
                return ((bitField0_ & 0x00000008) != 0);
            }
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @return The opType.
             */
            public java.lang.String getOpType() {
                java.lang.Object ref = opType_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        opType_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @return The bytes for opType.
             */
            public com.google.protobuf.ByteString
            getOpTypeBytes() {
                java.lang.Object ref = opType_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    opType_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @param value The opType to set.
             * @return This builder for chaining.
             */
            public Builder setOpType(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                opType_ = value;
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @return This builder for chaining.
             */
            public Builder clearOpType() {
                opType_ = getDefaultInstance().getOpType();
                bitField0_ = (bitField0_ & ~0x00000008);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @param value The bytes for opType to set.
             * @return This builder for chaining.
             */
            public Builder setOpTypeBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                opType_ = value;
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            
            private java.lang.Object domain_ = "";
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @return Whether the domain field is set.
             */
            public boolean hasDomain() {
                return ((bitField0_ & 0x00000010) != 0);
            }
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @return The domain.
             */
            public java.lang.String getDomain() {
                java.lang.Object ref = domain_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        domain_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @return The bytes for domain.
             */
            public com.google.protobuf.ByteString
            getDomainBytes() {
                java.lang.Object ref = domain_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    domain_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @param value The domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomain(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                domain_ = value;
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @return This builder for chaining.
             */
            public Builder clearDomain() {
                domain_ = getDefaultInstance().getDomain();
                bitField0_ = (bitField0_ & ~0x00000010);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @param value The bytes for domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomainBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                domain_ = value;
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }
            
            private java.lang.Object overload_ = "";
            /**
             * <pre>
             * Overload identifier, used only to map this to a model-local function.
             * </pre>
             *
             * <code>optional string overload = 8;</code>
             * @return Whether the overload field is set.
             */
            public boolean hasOverload() {
                return ((bitField0_ & 0x00000020) != 0);
            }
            /**
             * <pre>
             * Overload identifier, used only to map this to a model-local function.
             * </pre>
             *
             * <code>optional string overload = 8;</code>
             * @return The overload.
             */
            public java.lang.String getOverload() {
                java.lang.Object ref = overload_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        overload_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * Overload identifier, used only to map this to a model-local function.
             * </pre>
             *
             * <code>optional string overload = 8;</code>
             * @return The bytes for overload.
             */
            public com.google.protobuf.ByteString
            getOverloadBytes() {
                java.lang.Object ref = overload_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    overload_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * Overload identifier, used only to map this to a model-local function.
             * </pre>
             *
             * <code>optional string overload = 8;</code>
             * @param value The overload to set.
             * @return This builder for chaining.
             */
            public Builder setOverload(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                overload_ = value;
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Overload identifier, used only to map this to a model-local function.
             * </pre>
             *
             * <code>optional string overload = 8;</code>
             * @return This builder for chaining.
             */
            public Builder clearOverload() {
                overload_ = getDefaultInstance().getOverload();
                bitField0_ = (bitField0_ & ~0x00000020);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Overload identifier, used only to map this to a model-local function.
             * </pre>
             *
             * <code>optional string overload = 8;</code>
             * @param value The bytes for overload to set.
             * @return This builder for chaining.
             */
            public Builder setOverloadBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                overload_ = value;
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto> attribute_ =
                java.util.Collections.emptyList();
            private void ensureAttributeIsMutable() {
                if (!((bitField0_ & 0x00000040) != 0)) {
                    attribute_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto>(attribute_);
                    bitField0_ |= 0x00000040;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder> attributeBuilder_;
            
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto> getAttributeList() {
                if (attributeBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(attribute_);
                } else {
                    return attributeBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public int getAttributeCount() {
                if (attributeBuilder_ == null) {
                    return attribute_.size();
                } else {
                    return attributeBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto getAttribute(int index) {
                if (attributeBuilder_ == null) {
                    return attribute_.get(index);
                } else {
                    return attributeBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public Builder setAttribute(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto value) {
                if (attributeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureAttributeIsMutable();
                    attribute_.set(index, value);
                    onChanged();
                } else {
                    attributeBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public Builder setAttribute(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder builderForValue) {
                if (attributeBuilder_ == null) {
                    ensureAttributeIsMutable();
                    attribute_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    attributeBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public Builder addAttribute(ProtoOnnx.AttributeProto value) {
                if (attributeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureAttributeIsMutable();
                    attribute_.add(value);
                    onChanged();
                } else {
                    attributeBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public Builder addAttribute(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto value) {
                if (attributeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureAttributeIsMutable();
                    attribute_.add(index, value);
                    onChanged();
                } else {
                    attributeBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public Builder addAttribute(
                ProtoOnnx.AttributeProto.Builder builderForValue) {
                if (attributeBuilder_ == null) {
                    ensureAttributeIsMutable();
                    attribute_.add(builderForValue.build());
                    onChanged();
                } else {
                    attributeBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public Builder addAttribute(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder builderForValue) {
                if (attributeBuilder_ == null) {
                    ensureAttributeIsMutable();
                    attribute_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    attributeBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public Builder addAllAttribute(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto> values) {
                if (attributeBuilder_ == null) {
                    ensureAttributeIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, attribute_);
                    onChanged();
                } else {
                    attributeBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public Builder clearAttribute() {
                if (attributeBuilder_ == null) {
                    attribute_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000040);
                    onChanged();
                } else {
                    attributeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public Builder removeAttribute(int index) {
                if (attributeBuilder_ == null) {
                    ensureAttributeIsMutable();
                    attribute_.remove(index);
                    onChanged();
                } else {
                    attributeBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public ProtoOnnx.AttributeProto.Builder getAttributeBuilder(
                int index) {
                return internalGetAttributeFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder getAttributeOrBuilder(
                int index) {
                if (attributeBuilder_ == null) {
                    return attribute_.get(index);  } else {
                    return attributeBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder>
            getAttributeOrBuilderList() {
                if (attributeBuilder_ != null) {
                    return attributeBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(attribute_);
                }
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder addAttributeBuilder() {
                return internalGetAttributeFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder addAttributeBuilder(
                int index) {
                return internalGetAttributeFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute = 5;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder>
            getAttributeBuilderList() {
                return internalGetAttributeFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.AttributeProto, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder>
            internalGetAttributeFieldBuilder() {
                if (attributeBuilder_ == null) {
                    attributeBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder>(
                        attribute_,
                        ((bitField0_ & 0x00000040) != 0),
                        getParentForChildren(),
                        isClean());
                    attribute_ = null;
                }
                return attributeBuilder_;
            }
            
            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000080) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000080;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                docString_ = getDefaultInstance().getDocString();
                bitField0_ = (bitField0_ & ~0x00000080);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000080;
                onChanged();
                return this;
            }
            
            private java.util.List<ProtoOnnx.StringStringEntryProto> metadataProps_ =
                java.util.Collections.emptyList();
            private void ensureMetadataPropsIsMutable() {
                if (!((bitField0_ & 0x00000100) != 0)) {
                    metadataProps_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>(metadataProps_);
                    bitField0_ |= 0x00000100;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, ProtoOnnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;
            
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
                if (metadataPropsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                } else {
                    return metadataPropsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public int getMetadataPropsCount() {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.size();
                } else {
                    return metadataPropsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);
                } else {
                    return metadataPropsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public Builder setMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public Builder setMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public Builder addMetadataProps(ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public Builder addMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public Builder addMetadataProps(
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public Builder addMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public Builder addAllMetadataProps(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> values) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, metadataProps_);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public Builder clearMetadataProps() {
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000100);
                    onChanged();
                } else {
                    metadataPropsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public Builder removeMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.remove(index);
                    onChanged();
                } else {
                    metadataPropsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
                int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);  } else {
                    return metadataPropsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            getMetadataPropsOrBuilderList() {
                if (metadataPropsBuilder_ != null) {
                    return metadataPropsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 9;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder>
            getMetadataPropsBuilderList() {
                return internalGetMetadataPropsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, ProtoOnnx.StringStringEntryProtoOrBuilder>
            internalGetMetadataPropsFieldBuilder() {
                if (metadataPropsBuilder_ == null) {
                    metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>(
                        metadataProps_,
                        ((bitField0_ & 0x00000100) != 0),
                        getParentForChildren(),
                        isClean());
                    metadataProps_ = null;
                }
                return metadataPropsBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto> deviceConfigurations_ =
                java.util.Collections.emptyList();
            private void ensureDeviceConfigurationsIsMutable() {
                if (!((bitField0_ & 0x00000200) != 0)) {
                    deviceConfigurations_ = new java.util.ArrayList<ProtoOnnx.NodeDeviceConfigurationProto>(deviceConfigurations_);
                    bitField0_ |= 0x00000200;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProtoOrBuilder> deviceConfigurationsBuilder_;
            
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto> getDeviceConfigurationsList() {
                if (deviceConfigurationsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(deviceConfigurations_);
                } else {
                    return deviceConfigurationsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public int getDeviceConfigurationsCount() {
                if (deviceConfigurationsBuilder_ == null) {
                    return deviceConfigurations_.size();
                } else {
                    return deviceConfigurationsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto getDeviceConfigurations(int index) {
                if (deviceConfigurationsBuilder_ == null) {
                    return deviceConfigurations_.get(index);
                } else {
                    return deviceConfigurationsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public Builder setDeviceConfigurations(
                int index, ProtoOnnx.NodeDeviceConfigurationProto value) {
                if (deviceConfigurationsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureDeviceConfigurationsIsMutable();
                    deviceConfigurations_.set(index, value);
                    onChanged();
                } else {
                    deviceConfigurationsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public Builder setDeviceConfigurations(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder builderForValue) {
                if (deviceConfigurationsBuilder_ == null) {
                    ensureDeviceConfigurationsIsMutable();
                    deviceConfigurations_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    deviceConfigurationsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public Builder addDeviceConfigurations(ProtoOnnx.NodeDeviceConfigurationProto value) {
                if (deviceConfigurationsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureDeviceConfigurationsIsMutable();
                    deviceConfigurations_.add(value);
                    onChanged();
                } else {
                    deviceConfigurationsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public Builder addDeviceConfigurations(
                int index, ProtoOnnx.NodeDeviceConfigurationProto value) {
                if (deviceConfigurationsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureDeviceConfigurationsIsMutable();
                    deviceConfigurations_.add(index, value);
                    onChanged();
                } else {
                    deviceConfigurationsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public Builder addDeviceConfigurations(
                org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder builderForValue) {
                if (deviceConfigurationsBuilder_ == null) {
                    ensureDeviceConfigurationsIsMutable();
                    deviceConfigurations_.add(builderForValue.build());
                    onChanged();
                } else {
                    deviceConfigurationsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public Builder addDeviceConfigurations(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder builderForValue) {
                if (deviceConfigurationsBuilder_ == null) {
                    ensureDeviceConfigurationsIsMutable();
                    deviceConfigurations_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    deviceConfigurationsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public Builder addAllDeviceConfigurations(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto> values) {
                if (deviceConfigurationsBuilder_ == null) {
                    ensureDeviceConfigurationsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, deviceConfigurations_);
                    onChanged();
                } else {
                    deviceConfigurationsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public Builder clearDeviceConfigurations() {
                if (deviceConfigurationsBuilder_ == null) {
                    deviceConfigurations_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000200);
                    onChanged();
                } else {
                    deviceConfigurationsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public Builder removeDeviceConfigurations(int index) {
                if (deviceConfigurationsBuilder_ == null) {
                    ensureDeviceConfigurationsIsMutable();
                    deviceConfigurations_.remove(index);
                    onChanged();
                } else {
                    deviceConfigurationsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder getDeviceConfigurationsBuilder(
                int index) {
                return internalGetDeviceConfigurationsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProtoOrBuilder getDeviceConfigurationsOrBuilder(
                int index) {
                if (deviceConfigurationsBuilder_ == null) {
                    return deviceConfigurations_.get(index);  } else {
                    return deviceConfigurationsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProtoOrBuilder>
            getDeviceConfigurationsOrBuilderList() {
                if (deviceConfigurationsBuilder_ != null) {
                    return deviceConfigurationsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(deviceConfigurations_);
                }
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder addDeviceConfigurationsBuilder() {
                return internalGetDeviceConfigurationsFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public ProtoOnnx.NodeDeviceConfigurationProto.Builder addDeviceConfigurationsBuilder(
                int index) {
                return internalGetDeviceConfigurationsFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Configuration of multi-device annotations.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto device_configurations = 10;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder>
            getDeviceConfigurationsBuilderList() {
                return internalGetDeviceConfigurationsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.NodeDeviceConfigurationProto, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProtoOrBuilder>
            internalGetDeviceConfigurationsFieldBuilder() {
                if (deviceConfigurationsBuilder_ == null) {
                    deviceConfigurationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProtoOrBuilder>(
                        deviceConfigurations_,
                        ((bitField0_ & 0x00000200) != 0),
                        getParentForChildren(),
                        isClean());
                    deviceConfigurations_ = null;
                }
                return deviceConfigurationsBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.NodeProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.NodeProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<NodeProto>
            PARSER = new com.google.protobuf.AbstractParser<NodeProto>() {
            @java.lang.Override
            public NodeProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<NodeProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<NodeProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface IntIntListEntryProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.IntIntListEntryProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <code>optional int64 key = 1;</code>
         * @return Whether the key field is set.
         */
        boolean hasKey();
        /**
         * <code>optional int64 key = 1;</code>
         * @return The key.
         */
        long getKey();
        
        /**
         * <code>repeated int64 value = 2;</code>
         * @return A list containing the value.
         */
        java.util.List<java.lang.Long> getValueList();
        /**
         * <code>repeated int64 value = 2;</code>
         * @return The count of value.
         */
        int getValueCount();
        /**
         * <code>repeated int64 value = 2;</code>
         * @param index The index of the element to return.
         * @return The value at the given index.
         */
        long getValue(int index);
    }
    /**
     * <pre>
     * IntIntListEntryProto follows the pattern for cross-proto-version maps.
     * See https://developers.google.com/protocol-buffers/docs/proto3#maps
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.IntIntListEntryProto}
     */
    public static final class IntIntListEntryProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.IntIntListEntryProto)
        IntIntListEntryProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                IntIntListEntryProto.class.getName());
        }
        // Use IntIntListEntryProto.newBuilder() to construct.
        private IntIntListEntryProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private IntIntListEntryProto() {
            value_ = emptyLongList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_IntIntListEntryProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ProtoOnnx.internal_static_onnx_IntIntListEntryProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.class, ProtoOnnx.IntIntListEntryProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int KEY_FIELD_NUMBER = 1;
        private long key_ = 0L;
        /**
         * <code>optional int64 key = 1;</code>
         * @return Whether the key field is set.
         */
        @java.lang.Override
        public boolean hasKey() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional int64 key = 1;</code>
         * @return The key.
         */
        @java.lang.Override
        public long getKey() {
            return key_;
        }
        
        public static final int VALUE_FIELD_NUMBER = 2;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.LongList value_ =
            emptyLongList();
        /**
         * <code>repeated int64 value = 2;</code>
         * @return A list containing the value.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getValueList() {
            return value_;
        }
        /**
         * <code>repeated int64 value = 2;</code>
         * @return The count of value.
         */
        public int getValueCount() {
            return value_.size();
        }
        /**
         * <code>repeated int64 value = 2;</code>
         * @param index The index of the element to return.
         * @return The value at the given index.
         */
        public long getValue(int index) {
            return value_.getLong(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeInt64(1, key_);
            }
            for (int i = 0; i < value_.size(); i++) {
                output.writeInt64(2, value_.getLong(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt64Size(1, key_);
            }
            {
                int dataSize = 0;
                for (int i = 0; i < value_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                        .computeInt64SizeNoTag(value_.getLong(i));
                }
                size += dataSize;
                size += 1 * getValueList().size();
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto) obj;
            
            if (hasKey() != other.hasKey()) return false;
            if (hasKey()) {
                if (getKey()
                    != other.getKey()) return false;
            }
            if (!getValueList()
                .equals(other.getValueList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasKey()) {
                hash = (37 * hash) + KEY_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                    getKey());
            }
            if (getValueCount() > 0) {
                hash = (37 * hash) + VALUE_FIELD_NUMBER;
                hash = (53 * hash) + getValueList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * IntIntListEntryProto follows the pattern for cross-proto-version maps.
         * See https://developers.google.com/protocol-buffers/docs/proto3#maps
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.IntIntListEntryProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.IntIntListEntryProto)
            ProtoOnnx.IntIntListEntryProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_IntIntListEntryProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_IntIntListEntryProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.class, ProtoOnnx.IntIntListEntryProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                key_ = 0L;
                value_ = emptyLongList();
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_IntIntListEntryProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto getDefaultInstanceForType() {
                return ProtoOnnx.IntIntListEntryProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto(this);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.key_ = key_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    value_.makeImmutable();
                    result.value_ = value_;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(ProtoOnnx.IntIntListEntryProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.getDefaultInstance()) return this;
                if (other.hasKey()) {
                    setKey(other.getKey());
                }
                if (!other.value_.isEmpty()) {
                    if (value_.isEmpty()) {
                        value_ = other.value_;
                        value_.makeImmutable();
                        bitField0_ |= 0x00000002;
                    } else {
                        ensureValueIsMutable();
                        value_.addAll(other.value_);
                    }
                    onChanged();
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 8: {
                                key_ = input.readInt64();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 8
                            case 16: {
                                long v = input.readInt64();
                                ensureValueIsMutable();
                                value_.addLong(v);
                                break;
                            } // case 16
                            case 18: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                ensureValueIsMutable();
                                while (input.getBytesUntilLimit() > 0) {
                                    value_.addLong(input.readInt64());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 18
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private long key_ ;
            /**
             * <code>optional int64 key = 1;</code>
             * @return Whether the key field is set.
             */
            @java.lang.Override
            public boolean hasKey() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <code>optional int64 key = 1;</code>
             * @return The key.
             */
            @java.lang.Override
            public long getKey() {
                return key_;
            }
            /**
             * <code>optional int64 key = 1;</code>
             * @param value The key to set.
             * @return This builder for chaining.
             */
            public Builder setKey(long value) {
                
                key_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <code>optional int64 key = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearKey() {
                bitField0_ = (bitField0_ & ~0x00000001);
                key_ = 0L;
                onChanged();
                return this;
            }
            
            private com.google.protobuf.Internal.LongList value_ = emptyLongList();
            private void ensureValueIsMutable() {
                if (!value_.isModifiable()) {
                    value_ = makeMutableCopy(value_);
                }
                bitField0_ |= 0x00000002;
            }
            /**
             * <code>repeated int64 value = 2;</code>
             * @return A list containing the value.
             */
            public java.util.List<java.lang.Long>
            getValueList() {
                value_.makeImmutable();
                return value_;
            }
            /**
             * <code>repeated int64 value = 2;</code>
             * @return The count of value.
             */
            public int getValueCount() {
                return value_.size();
            }
            /**
             * <code>repeated int64 value = 2;</code>
             * @param index The index of the element to return.
             * @return The value at the given index.
             */
            public long getValue(int index) {
                return value_.getLong(index);
            }
            /**
             * <code>repeated int64 value = 2;</code>
             * @param index The index to set the value at.
             * @param value The value to set.
             * @return This builder for chaining.
             */
            public Builder setValue(
                int index, long value) {
                
                ensureValueIsMutable();
                value_.setLong(index, value);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <code>repeated int64 value = 2;</code>
             * @param value The value to add.
             * @return This builder for chaining.
             */
            public Builder addValue(long value) {
                
                ensureValueIsMutable();
                value_.addLong(value);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <code>repeated int64 value = 2;</code>
             * @param values The value to add.
             * @return This builder for chaining.
             */
            public Builder addAllValue(
                java.lang.Iterable<? extends java.lang.Long> values) {
                ensureValueIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, value_);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <code>repeated int64 value = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearValue() {
                value_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000002);
                onChanged();
                return this;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.IntIntListEntryProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.IntIntListEntryProto)
        private static final ProtoOnnx.IntIntListEntryProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<IntIntListEntryProto>
            PARSER = new com.google.protobuf.AbstractParser<IntIntListEntryProto>() {
            @java.lang.Override
            public IntIntListEntryProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<IntIntListEntryProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<IntIntListEntryProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface NodeDeviceConfigurationProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
         * </pre>
         *
         * <code>optional string configuration_id = 1;</code>
         * @return Whether the configurationId field is set.
         */
        boolean hasConfigurationId();
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
         * </pre>
         *
         * <code>optional string configuration_id = 1;</code>
         * @return The configurationId.
         */
        java.lang.String getConfigurationId();
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
         * </pre>
         *
         * <code>optional string configuration_id = 1;</code>
         * @return The bytes for configurationId.
         */
        com.google.protobuf.ByteString
        getConfigurationIdBytes();
        
        /**
         * <pre>
         * Sharding spec for the node.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto>
        getShardingSpecList();
        /**
         * <pre>
         * Sharding spec for the node.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto getShardingSpec(int index);
        /**
         * <pre>
         * Sharding spec for the node.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
         */
        int getShardingSpecCount();
        /**
         * <pre>
         * Sharding spec for the node.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProtoOrBuilder>
        getShardingSpecOrBuilderList();
        /**
         * <pre>
         * Sharding spec for the node.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProtoOrBuilder getShardingSpecOrBuilder(
            int index);
        
        /**
         * <pre>
         * Pipeline stage of this node.
         * </pre>
         *
         * <code>optional int32 pipeline_stage = 3;</code>
         * @return Whether the pipelineStage field is set.
         */
        boolean hasPipelineStage();
        /**
         * <pre>
         * Pipeline stage of this node.
         * </pre>
         *
         * <code>optional int32 pipeline_stage = 3;</code>
         * @return The pipelineStage.
         */
        int getPipelineStage();
    }
    /**
     * <pre>
     * Multi-device configuration proto for NodeProto.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto}
     */
    public static final class NodeDeviceConfigurationProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto)
        NodeDeviceConfigurationProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                NodeDeviceConfigurationProto.class.getName());
        }
        // Use NodeDeviceConfigurationProto.newBuilder() to construct.
        private NodeDeviceConfigurationProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private NodeDeviceConfigurationProto() {
            configurationId_ = "";
            shardingSpec_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_NodeDeviceConfigurationProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_NodeDeviceConfigurationProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int CONFIGURATION_ID_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private volatile java.lang.Object configurationId_ = "";
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
         * </pre>
         *
         * <code>optional string configuration_id = 1;</code>
         * @return Whether the configurationId field is set.
         */
        @java.lang.Override
        public boolean hasConfigurationId() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
         * </pre>
         *
         * <code>optional string configuration_id = 1;</code>
         * @return The configurationId.
         */
        @java.lang.Override
        public java.lang.String getConfigurationId() {
            java.lang.Object ref = configurationId_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    configurationId_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
         * </pre>
         *
         * <code>optional string configuration_id = 1;</code>
         * @return The bytes for configurationId.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getConfigurationIdBytes() {
            java.lang.Object ref = configurationId_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                configurationId_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int SHARDING_SPEC_FIELD_NUMBER = 2;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto> shardingSpec_;
        /**
         * <pre>
         * Sharding spec for the node.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto> getShardingSpecList() {
            return shardingSpec_;
        }
        /**
         * <pre>
         * Sharding spec for the node.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProtoOrBuilder>
        getShardingSpecOrBuilderList() {
            return shardingSpec_;
        }
        /**
         * <pre>
         * Sharding spec for the node.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
         */
        @java.lang.Override
        public int getShardingSpecCount() {
            return shardingSpec_.size();
        }
        /**
         * <pre>
         * Sharding spec for the node.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto getShardingSpec(int index) {
            return shardingSpec_.get(index);
        }
        /**
         * <pre>
         * Sharding spec for the node.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProtoOrBuilder getShardingSpecOrBuilder(
            int index) {
            return shardingSpec_.get(index);
        }
        
        public static final int PIPELINE_STAGE_FIELD_NUMBER = 3;
        private int pipelineStage_ = 0;
        /**
         * <pre>
         * Pipeline stage of this node.
         * </pre>
         *
         * <code>optional int32 pipeline_stage = 3;</code>
         * @return Whether the pipelineStage field is set.
         */
        @java.lang.Override
        public boolean hasPipelineStage() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Pipeline stage of this node.
         * </pre>
         *
         * <code>optional int32 pipeline_stage = 3;</code>
         * @return The pipelineStage.
         */
        @java.lang.Override
        public int getPipelineStage() {
            return pipelineStage_;
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 1, configurationId_);
            }
            for (int i = 0; i < shardingSpec_.size(); i++) {
                output.writeMessage(2, shardingSpec_.get(i));
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeInt32(3, pipelineStage_);
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(1, configurationId_);
            }
            for (int i = 0; i < shardingSpec_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(2, shardingSpec_.get(i));
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt32Size(3, pipelineStage_);
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ProtoOnnx.NodeDeviceConfigurationProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto) obj;
            
            if (hasConfigurationId() != other.hasConfigurationId()) return false;
            if (hasConfigurationId()) {
                if (!getConfigurationId()
                    .equals(other.getConfigurationId())) return false;
            }
            if (!getShardingSpecList()
                .equals(other.getShardingSpecList())) return false;
            if (hasPipelineStage() != other.hasPipelineStage()) return false;
            if (hasPipelineStage()) {
                if (getPipelineStage()
                    != other.getPipelineStage()) return false;
            }
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasConfigurationId()) {
                hash = (37 * hash) + CONFIGURATION_ID_FIELD_NUMBER;
                hash = (53 * hash) + getConfigurationId().hashCode();
            }
            if (getShardingSpecCount() > 0) {
                hash = (37 * hash) + SHARDING_SPEC_FIELD_NUMBER;
                hash = (53 * hash) + getShardingSpecList().hashCode();
            }
            if (hasPipelineStage()) {
                hash = (37 * hash) + PIPELINE_STAGE_FIELD_NUMBER;
                hash = (53 * hash) + getPipelineStage();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Multi-device configuration proto for NodeProto.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ProtoOnnx.internal_static_onnx_NodeDeviceConfigurationProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_NodeDeviceConfigurationProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                configurationId_ = "";
                if (shardingSpecBuilder_ == null) {
                    shardingSpec_ = java.util.Collections.emptyList();
                } else {
                    shardingSpec_ = null;
                    shardingSpecBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000002);
                pipelineStage_ = 0;
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ProtoOnnx.internal_static_onnx_NodeDeviceConfigurationProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto build() {
                ProtoOnnx.NodeDeviceConfigurationProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(ProtoOnnx.NodeDeviceConfigurationProto result) {
                if (shardingSpecBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0)) {
                        shardingSpec_ = java.util.Collections.unmodifiableList(shardingSpec_);
                        bitField0_ = (bitField0_ & ~0x00000002);
                    }
                    result.shardingSpec_ = shardingSpec_;
                } else {
                    result.shardingSpec_ = shardingSpecBuilder_.build();
                }
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.configurationId_ = configurationId_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    result.pipelineStage_ = pipelineStage_;
                    to_bitField0_ |= 0x00000002;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ProtoOnnx.NodeDeviceConfigurationProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto.getDefaultInstance()) return this;
                if (other.hasConfigurationId()) {
                    configurationId_ = other.configurationId_;
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                if (shardingSpecBuilder_ == null) {
                    if (!other.shardingSpec_.isEmpty()) {
                        if (shardingSpec_.isEmpty()) {
                            shardingSpec_ = other.shardingSpec_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                        } else {
                            ensureShardingSpecIsMutable();
                            shardingSpec_.addAll(other.shardingSpec_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.shardingSpec_.isEmpty()) {
                        if (shardingSpecBuilder_.isEmpty()) {
                            shardingSpecBuilder_.dispose();
                            shardingSpecBuilder_ = null;
                            shardingSpec_ = other.shardingSpec_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                            shardingSpecBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetShardingSpecFieldBuilder() : null;
                        } else {
                            shardingSpecBuilder_.addAllMessages(other.shardingSpec_);
                        }
                    }
                }
                if (other.hasPipelineStage()) {
                    setPipelineStage(other.getPipelineStage());
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                configurationId_ = input.readBytes();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 18: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.parser(),
                                        extensionRegistry);
                                if (shardingSpecBuilder_ == null) {
                                    ensureShardingSpecIsMutable();
                                    shardingSpec_.add(m);
                                } else {
                                    shardingSpecBuilder_.addMessage(m);
                                }
                                break;
                            } // case 18
                            case 24: {
                                pipelineStage_ = input.readInt32();
                                bitField0_ |= 0x00000004;
                                break;
                            } // case 24
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.lang.Object configurationId_ = "";
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
             * </pre>
             *
             * <code>optional string configuration_id = 1;</code>
             * @return Whether the configurationId field is set.
             */
            public boolean hasConfigurationId() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
             * </pre>
             *
             * <code>optional string configuration_id = 1;</code>
             * @return The configurationId.
             */
            public java.lang.String getConfigurationId() {
                java.lang.Object ref = configurationId_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        configurationId_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
             * </pre>
             *
             * <code>optional string configuration_id = 1;</code>
             * @return The bytes for configurationId.
             */
            public com.google.protobuf.ByteString
            getConfigurationIdBytes() {
                java.lang.Object ref = configurationId_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    configurationId_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
             * </pre>
             *
             * <code>optional string configuration_id = 1;</code>
             * @param value The configurationId to set.
             * @return This builder for chaining.
             */
            public Builder setConfigurationId(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                configurationId_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
             * </pre>
             *
             * <code>optional string configuration_id = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearConfigurationId() {
                configurationId_ = getDefaultInstance().getConfigurationId();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
             * </pre>
             *
             * <code>optional string configuration_id = 1;</code>
             * @param value The bytes for configurationId to set.
             * @return This builder for chaining.
             */
            public Builder setConfigurationIdBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                configurationId_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto> shardingSpec_ =
                java.util.Collections.emptyList();
            private void ensureShardingSpecIsMutable() {
                if (!((bitField0_ & 0x00000002) != 0)) {
                    shardingSpec_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto>(shardingSpec_);
                    bitField0_ |= 0x00000002;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProtoOrBuilder> shardingSpecBuilder_;
            
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto> getShardingSpecList() {
                if (shardingSpecBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(shardingSpec_);
                } else {
                    return shardingSpecBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public int getShardingSpecCount() {
                if (shardingSpecBuilder_ == null) {
                    return shardingSpec_.size();
                } else {
                    return shardingSpecBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto getShardingSpec(int index) {
                if (shardingSpecBuilder_ == null) {
                    return shardingSpec_.get(index);
                } else {
                    return shardingSpecBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public Builder setShardingSpec(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto value) {
                if (shardingSpecBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureShardingSpecIsMutable();
                    shardingSpec_.set(index, value);
                    onChanged();
                } else {
                    shardingSpecBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public Builder setShardingSpec(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder builderForValue) {
                if (shardingSpecBuilder_ == null) {
                    ensureShardingSpecIsMutable();
                    shardingSpec_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    shardingSpecBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public Builder addShardingSpec(ProtoOnnx.ShardingSpecProto value) {
                if (shardingSpecBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureShardingSpecIsMutable();
                    shardingSpec_.add(value);
                    onChanged();
                } else {
                    shardingSpecBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public Builder addShardingSpec(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto value) {
                if (shardingSpecBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureShardingSpecIsMutable();
                    shardingSpec_.add(index, value);
                    onChanged();
                } else {
                    shardingSpecBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public Builder addShardingSpec(
                org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder builderForValue) {
                if (shardingSpecBuilder_ == null) {
                    ensureShardingSpecIsMutable();
                    shardingSpec_.add(builderForValue.build());
                    onChanged();
                } else {
                    shardingSpecBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public Builder addShardingSpec(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder builderForValue) {
                if (shardingSpecBuilder_ == null) {
                    ensureShardingSpecIsMutable();
                    shardingSpec_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    shardingSpecBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public Builder addAllShardingSpec(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto> values) {
                if (shardingSpecBuilder_ == null) {
                    ensureShardingSpecIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, shardingSpec_);
                    onChanged();
                } else {
                    shardingSpecBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public Builder clearShardingSpec() {
                if (shardingSpecBuilder_ == null) {
                    shardingSpec_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000002);
                    onChanged();
                } else {
                    shardingSpecBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public Builder removeShardingSpec(int index) {
                if (shardingSpecBuilder_ == null) {
                    ensureShardingSpecIsMutable();
                    shardingSpec_.remove(index);
                    onChanged();
                } else {
                    shardingSpecBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder getShardingSpecBuilder(
                int index) {
                return internalGetShardingSpecFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProtoOrBuilder getShardingSpecOrBuilder(
                int index) {
                if (shardingSpecBuilder_ == null) {
                    return shardingSpec_.get(index);  } else {
                    return shardingSpecBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProtoOrBuilder>
            getShardingSpecOrBuilderList() {
                if (shardingSpecBuilder_ != null) {
                    return shardingSpecBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(shardingSpec_);
                }
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder addShardingSpecBuilder() {
                return internalGetShardingSpecFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder addShardingSpecBuilder(
                int index) {
                return internalGetShardingSpecFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Sharding spec for the node.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardingSpecProto sharding_spec = 2;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder>
            getShardingSpecBuilderList() {
                return internalGetShardingSpecFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto, ProtoOnnx.ShardingSpecProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProtoOrBuilder>
            internalGetShardingSpecFieldBuilder() {
                if (shardingSpecBuilder_ == null) {
                    shardingSpecBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProtoOrBuilder>(
                        shardingSpec_,
                        ((bitField0_ & 0x00000002) != 0),
                        getParentForChildren(),
                        isClean());
                    shardingSpec_ = null;
                }
                return shardingSpecBuilder_;
            }
            
            private int pipelineStage_ ;
            /**
             * <pre>
             * Pipeline stage of this node.
             * </pre>
             *
             * <code>optional int32 pipeline_stage = 3;</code>
             * @return Whether the pipelineStage field is set.
             */
            @java.lang.Override
            public boolean hasPipelineStage() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * Pipeline stage of this node.
             * </pre>
             *
             * <code>optional int32 pipeline_stage = 3;</code>
             * @return The pipelineStage.
             */
            @java.lang.Override
            public int getPipelineStage() {
                return pipelineStage_;
            }
            /**
             * <pre>
             * Pipeline stage of this node.
             * </pre>
             *
             * <code>optional int32 pipeline_stage = 3;</code>
             * @param value The pipelineStage to set.
             * @return This builder for chaining.
             */
            public Builder setPipelineStage(int value) {
                
                pipelineStage_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Pipeline stage of this node.
             * </pre>
             *
             * <code>optional int32 pipeline_stage = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearPipelineStage() {
                bitField0_ = (bitField0_ & ~0x00000004);
                pipelineStage_ = 0;
                onChanged();
                return this;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.NodeDeviceConfigurationProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<NodeDeviceConfigurationProto>
            PARSER = new com.google.protobuf.AbstractParser<NodeDeviceConfigurationProto>() {
            @java.lang.Override
            public NodeDeviceConfigurationProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<NodeDeviceConfigurationProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<NodeDeviceConfigurationProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.NodeDeviceConfigurationProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface ShardingSpecProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.ShardingSpecProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Identifies the input or output of the node that is being sharded.
         * Required to match a name specified in the node's input or output list of ValueInfoProtos.
         * It is called `logical tensor` in subsequent descriptions.
         * </pre>
         *
         * <code>optional string tensor_name = 1;</code>
         * @return Whether the tensorName field is set.
         */
        boolean hasTensorName();
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Identifies the input or output of the node that is being sharded.
         * Required to match a name specified in the node's input or output list of ValueInfoProtos.
         * It is called `logical tensor` in subsequent descriptions.
         * </pre>
         *
         * <code>optional string tensor_name = 1;</code>
         * @return The tensorName.
         */
        java.lang.String getTensorName();
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Identifies the input or output of the node that is being sharded.
         * Required to match a name specified in the node's input or output list of ValueInfoProtos.
         * It is called `logical tensor` in subsequent descriptions.
         * </pre>
         *
         * <code>optional string tensor_name = 1;</code>
         * @return The bytes for tensorName.
         */
        com.google.protobuf.ByteString
        getTensorNameBytes();
        
        /**
         * <pre>
         * The following is the list of devices across which the logical
         * tensor is sharded or replicated.
         * </pre>
         *
         * <code>repeated int64 device = 2;</code>
         * @return A list containing the device.
         */
        java.util.List<java.lang.Long> getDeviceList();
        /**
         * <pre>
         * The following is the list of devices across which the logical
         * tensor is sharded or replicated.
         * </pre>
         *
         * <code>repeated int64 device = 2;</code>
         * @return The count of device.
         */
        int getDeviceCount();
        /**
         * <pre>
         * The following is the list of devices across which the logical
         * tensor is sharded or replicated.
         * </pre>
         *
         * <code>repeated int64 device = 2;</code>
         * @param index The index of the element to return.
         * @return The device at the given index.
         */
        long getDevice(int index);
        
        /**
         * <pre>
         * Each element v in above field devices may represent either a
         * device or a set of devices (when we want the same shard/tensor
         * to be replicated across a subset of devices), as indicated by
         * the following optional map. If the map contains an entry for v,
         * then v represents a device group, and the map indicates the set
         * of devices in that group.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto>
        getIndexToDeviceGroupMapList();
        /**
         * <pre>
         * Each element v in above field devices may represent either a
         * device or a set of devices (when we want the same shard/tensor
         * to be replicated across a subset of devices), as indicated by
         * the following optional map. If the map contains an entry for v,
         * then v represents a device group, and the map indicates the set
         * of devices in that group.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
         */
        ProtoOnnx.IntIntListEntryProto getIndexToDeviceGroupMap(int index);
        /**
         * <pre>
         * Each element v in above field devices may represent either a
         * device or a set of devices (when we want the same shard/tensor
         * to be replicated across a subset of devices), as indicated by
         * the following optional map. If the map contains an entry for v,
         * then v represents a device group, and the map indicates the set
         * of devices in that group.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
         */
        int getIndexToDeviceGroupMapCount();
        /**
         * <pre>
         * Each element v in above field devices may represent either a
         * device or a set of devices (when we want the same shard/tensor
         * to be replicated across a subset of devices), as indicated by
         * the following optional map. If the map contains an entry for v,
         * then v represents a device group, and the map indicates the set
         * of devices in that group.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProtoOrBuilder>
        getIndexToDeviceGroupMapOrBuilderList();
        /**
         * <pre>
         * Each element v in above field devices may represent either a
         * device or a set of devices (when we want the same shard/tensor
         * to be replicated across a subset of devices), as indicated by
         * the following optional map. If the map contains an entry for v,
         * then v represents a device group, and the map indicates the set
         * of devices in that group.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProtoOrBuilder getIndexToDeviceGroupMapOrBuilder(
            int index);
        
        /**
         * <pre>
         * The following is the sharded-shape of the tensor, consisting of
         * the sharding-spec for each axis of the tensor.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto>
        getShardedDimList();
        /**
         * <pre>
         * The following is the sharded-shape of the tensor, consisting of
         * the sharding-spec for each axis of the tensor.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto getShardedDim(int index);
        /**
         * <pre>
         * The following is the sharded-shape of the tensor, consisting of
         * the sharding-spec for each axis of the tensor.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
         */
        int getShardedDimCount();
        /**
         * <pre>
         * The following is the sharded-shape of the tensor, consisting of
         * the sharding-spec for each axis of the tensor.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProtoOrBuilder>
        getShardedDimOrBuilderList();
        /**
         * <pre>
         * The following is the sharded-shape of the tensor, consisting of
         * the sharding-spec for each axis of the tensor.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProtoOrBuilder getShardedDimOrBuilder(
            int index);
    }
    /**
     * <pre>
     * ShardingSpecProto: This describes the sharding spec for a specific
     * input or output tensor of a node.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.ShardingSpecProto}
     */
    public static final class ShardingSpecProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.ShardingSpecProto)
        ShardingSpecProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                ShardingSpecProto.class.getName());
        }
        // Use ShardingSpecProto.newBuilder() to construct.
        private ShardingSpecProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private ShardingSpecProto() {
            tensorName_ = "";
            device_ = emptyLongList();
            indexToDeviceGroupMap_ = java.util.Collections.emptyList();
            shardedDim_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ShardingSpecProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ProtoOnnx.internal_static_onnx_ShardingSpecProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int TENSOR_NAME_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private volatile java.lang.Object tensorName_ = "";
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Identifies the input or output of the node that is being sharded.
         * Required to match a name specified in the node's input or output list of ValueInfoProtos.
         * It is called `logical tensor` in subsequent descriptions.
         * </pre>
         *
         * <code>optional string tensor_name = 1;</code>
         * @return Whether the tensorName field is set.
         */
        @java.lang.Override
        public boolean hasTensorName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Identifies the input or output of the node that is being sharded.
         * Required to match a name specified in the node's input or output list of ValueInfoProtos.
         * It is called `logical tensor` in subsequent descriptions.
         * </pre>
         *
         * <code>optional string tensor_name = 1;</code>
         * @return The tensorName.
         */
        @java.lang.Override
        public java.lang.String getTensorName() {
            java.lang.Object ref = tensorName_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    tensorName_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Identifies the input or output of the node that is being sharded.
         * Required to match a name specified in the node's input or output list of ValueInfoProtos.
         * It is called `logical tensor` in subsequent descriptions.
         * </pre>
         *
         * <code>optional string tensor_name = 1;</code>
         * @return The bytes for tensorName.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getTensorNameBytes() {
            java.lang.Object ref = tensorName_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                tensorName_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int DEVICE_FIELD_NUMBER = 2;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.LongList device_ =
            emptyLongList();
        /**
         * <pre>
         * The following is the list of devices across which the logical
         * tensor is sharded or replicated.
         * </pre>
         *
         * <code>repeated int64 device = 2;</code>
         * @return A list containing the device.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getDeviceList() {
            return device_;
        }
        /**
         * <pre>
         * The following is the list of devices across which the logical
         * tensor is sharded or replicated.
         * </pre>
         *
         * <code>repeated int64 device = 2;</code>
         * @return The count of device.
         */
        public int getDeviceCount() {
            return device_.size();
        }
        /**
         * <pre>
         * The following is the list of devices across which the logical
         * tensor is sharded or replicated.
         * </pre>
         *
         * <code>repeated int64 device = 2;</code>
         * @param index The index of the element to return.
         * @return The device at the given index.
         */
        public long getDevice(int index) {
            return device_.getLong(index);
        }
        
        public static final int INDEX_TO_DEVICE_GROUP_MAP_FIELD_NUMBER = 3;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto> indexToDeviceGroupMap_;
        /**
         * <pre>
         * Each element v in above field devices may represent either a
         * device or a set of devices (when we want the same shard/tensor
         * to be replicated across a subset of devices), as indicated by
         * the following optional map. If the map contains an entry for v,
         * then v represents a device group, and the map indicates the set
         * of devices in that group.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.IntIntListEntryProto> getIndexToDeviceGroupMapList() {
            return indexToDeviceGroupMap_;
        }
        /**
         * <pre>
         * Each element v in above field devices may represent either a
         * device or a set of devices (when we want the same shard/tensor
         * to be replicated across a subset of devices), as indicated by
         * the following optional map. If the map contains an entry for v,
         * then v represents a device group, and the map indicates the set
         * of devices in that group.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ProtoOnnx.IntIntListEntryProtoOrBuilder>
        getIndexToDeviceGroupMapOrBuilderList() {
            return indexToDeviceGroupMap_;
        }
        /**
         * <pre>
         * Each element v in above field devices may represent either a
         * device or a set of devices (when we want the same shard/tensor
         * to be replicated across a subset of devices), as indicated by
         * the following optional map. If the map contains an entry for v,
         * then v represents a device group, and the map indicates the set
         * of devices in that group.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
         */
        @java.lang.Override
        public int getIndexToDeviceGroupMapCount() {
            return indexToDeviceGroupMap_.size();
        }
        /**
         * <pre>
         * Each element v in above field devices may represent either a
         * device or a set of devices (when we want the same shard/tensor
         * to be replicated across a subset of devices), as indicated by
         * the following optional map. If the map contains an entry for v,
         * then v represents a device group, and the map indicates the set
         * of devices in that group.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto getIndexToDeviceGroupMap(int index) {
            return indexToDeviceGroupMap_.get(index);
        }
        /**
         * <pre>
         * Each element v in above field devices may represent either a
         * device or a set of devices (when we want the same shard/tensor
         * to be replicated across a subset of devices), as indicated by
         * the following optional map. If the map contains an entry for v,
         * then v represents a device group, and the map indicates the set
         * of devices in that group.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProtoOrBuilder getIndexToDeviceGroupMapOrBuilder(
            int index) {
            return indexToDeviceGroupMap_.get(index);
        }
        
        public static final int SHARDED_DIM_FIELD_NUMBER = 4;
        @SuppressWarnings("serial")
        private java.util.List<ProtoOnnx.ShardedDimProto> shardedDim_;
        /**
         * <pre>
         * The following is the sharded-shape of the tensor, consisting of
         * the sharding-spec for each axis of the tensor.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto> getShardedDimList() {
            return shardedDim_;
        }
        /**
         * <pre>
         * The following is the sharded-shape of the tensor, consisting of
         * the sharding-spec for each axis of the tensor.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProtoOrBuilder>
        getShardedDimOrBuilderList() {
            return shardedDim_;
        }
        /**
         * <pre>
         * The following is the sharded-shape of the tensor, consisting of
         * the sharding-spec for each axis of the tensor.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
         */
        @java.lang.Override
        public int getShardedDimCount() {
            return shardedDim_.size();
        }
        /**
         * <pre>
         * The following is the sharded-shape of the tensor, consisting of
         * the sharding-spec for each axis of the tensor.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto getShardedDim(int index) {
            return shardedDim_.get(index);
        }
        /**
         * <pre>
         * The following is the sharded-shape of the tensor, consisting of
         * the sharding-spec for each axis of the tensor.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProtoOrBuilder getShardedDimOrBuilder(
            int index) {
            return shardedDim_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 1, tensorName_);
            }
            for (int i = 0; i < device_.size(); i++) {
                output.writeInt64(2, device_.getLong(i));
            }
            for (int i = 0; i < indexToDeviceGroupMap_.size(); i++) {
                output.writeMessage(3, indexToDeviceGroupMap_.get(i));
            }
            for (int i = 0; i < shardedDim_.size(); i++) {
                output.writeMessage(4, shardedDim_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(1, tensorName_);
            }
            {
                int dataSize = 0;
                for (int i = 0; i < device_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                        .computeInt64SizeNoTag(device_.getLong(i));
                }
                size += dataSize;
                size += 1 * getDeviceList().size();
            }
            for (int i = 0; i < indexToDeviceGroupMap_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(3, indexToDeviceGroupMap_.get(i));
            }
            for (int i = 0; i < shardedDim_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(4, shardedDim_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto) obj;
            
            if (hasTensorName() != other.hasTensorName()) return false;
            if (hasTensorName()) {
                if (!getTensorName()
                    .equals(other.getTensorName())) return false;
            }
            if (!getDeviceList()
                .equals(other.getDeviceList())) return false;
            if (!getIndexToDeviceGroupMapList()
                .equals(other.getIndexToDeviceGroupMapList())) return false;
            if (!getShardedDimList()
                .equals(other.getShardedDimList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasTensorName()) {
                hash = (37 * hash) + TENSOR_NAME_FIELD_NUMBER;
                hash = (53 * hash) + getTensorName().hashCode();
            }
            if (getDeviceCount() > 0) {
                hash = (37 * hash) + DEVICE_FIELD_NUMBER;
                hash = (53 * hash) + getDeviceList().hashCode();
            }
            if (getIndexToDeviceGroupMapCount() > 0) {
                hash = (37 * hash) + INDEX_TO_DEVICE_GROUP_MAP_FIELD_NUMBER;
                hash = (53 * hash) + getIndexToDeviceGroupMapList().hashCode();
            }
            if (getShardedDimCount() > 0) {
                hash = (37 * hash) + SHARDED_DIM_FIELD_NUMBER;
                hash = (53 * hash) + getShardedDimList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.ShardingSpecProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ProtoOnnx.ShardingSpecProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * ShardingSpecProto: This describes the sharding spec for a specific
         * input or output tensor of a node.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.ShardingSpecProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.ShardingSpecProto)
            ProtoOnnx.ShardingSpecProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ProtoOnnx.internal_static_onnx_ShardingSpecProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ProtoOnnx.internal_static_onnx_ShardingSpecProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                tensorName_ = "";
                device_ = emptyLongList();
                if (indexToDeviceGroupMapBuilder_ == null) {
                    indexToDeviceGroupMap_ = java.util.Collections.emptyList();
                } else {
                    indexToDeviceGroupMap_ = null;
                    indexToDeviceGroupMapBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000004);
                if (shardedDimBuilder_ == null) {
                    shardedDim_ = java.util.Collections.emptyList();
                } else {
                    shardedDim_ = null;
                    shardedDimBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000008);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ShardingSpecProto_descriptor;
            }
            
            @java.lang.Override
            public ProtoOnnx.ShardingSpecProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public ProtoOnnx.ShardingSpecProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public ProtoOnnx.ShardingSpecProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto result = new ProtoOnnx.ShardingSpecProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto result) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    if (((bitField0_ & 0x00000004) != 0)) {
                        indexToDeviceGroupMap_ = java.util.Collections.unmodifiableList(indexToDeviceGroupMap_);
                        bitField0_ = (bitField0_ & ~0x00000004);
                    }
                    result.indexToDeviceGroupMap_ = indexToDeviceGroupMap_;
                } else {
                    result.indexToDeviceGroupMap_ = indexToDeviceGroupMapBuilder_.build();
                }
                if (shardedDimBuilder_ == null) {
                    if (((bitField0_ & 0x00000008) != 0)) {
                        shardedDim_ = java.util.Collections.unmodifiableList(shardedDim_);
                        bitField0_ = (bitField0_ & ~0x00000008);
                    }
                    result.shardedDim_ = shardedDim_;
                } else {
                    result.shardedDim_ = shardedDimBuilder_.build();
                }
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.tensorName_ = tensorName_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    device_.makeImmutable();
                    result.device_ = device_;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto.getDefaultInstance()) return this;
                if (other.hasTensorName()) {
                    tensorName_ = other.tensorName_;
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                if (!other.device_.isEmpty()) {
                    if (device_.isEmpty()) {
                        device_ = other.device_;
                        device_.makeImmutable();
                        bitField0_ |= 0x00000002;
                    } else {
                        ensureDeviceIsMutable();
                        device_.addAll(other.device_);
                    }
                    onChanged();
                }
                if (indexToDeviceGroupMapBuilder_ == null) {
                    if (!other.indexToDeviceGroupMap_.isEmpty()) {
                        if (indexToDeviceGroupMap_.isEmpty()) {
                            indexToDeviceGroupMap_ = other.indexToDeviceGroupMap_;
                            bitField0_ = (bitField0_ & ~0x00000004);
                        } else {
                            ensureIndexToDeviceGroupMapIsMutable();
                            indexToDeviceGroupMap_.addAll(other.indexToDeviceGroupMap_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.indexToDeviceGroupMap_.isEmpty()) {
                        if (indexToDeviceGroupMapBuilder_.isEmpty()) {
                            indexToDeviceGroupMapBuilder_.dispose();
                            indexToDeviceGroupMapBuilder_ = null;
                            indexToDeviceGroupMap_ = other.indexToDeviceGroupMap_;
                            bitField0_ = (bitField0_ & ~0x00000004);
                            indexToDeviceGroupMapBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetIndexToDeviceGroupMapFieldBuilder() : null;
                        } else {
                            indexToDeviceGroupMapBuilder_.addAllMessages(other.indexToDeviceGroupMap_);
                        }
                    }
                }
                if (shardedDimBuilder_ == null) {
                    if (!other.shardedDim_.isEmpty()) {
                        if (shardedDim_.isEmpty()) {
                            shardedDim_ = other.shardedDim_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                        } else {
                            ensureShardedDimIsMutable();
                            shardedDim_.addAll(other.shardedDim_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.shardedDim_.isEmpty()) {
                        if (shardedDimBuilder_.isEmpty()) {
                            shardedDimBuilder_.dispose();
                            shardedDimBuilder_ = null;
                            shardedDim_ = other.shardedDim_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                            shardedDimBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetShardedDimFieldBuilder() : null;
                        } else {
                            shardedDimBuilder_.addAllMessages(other.shardedDim_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                tensorName_ = input.readBytes();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 16: {
                                long v = input.readInt64();
                                ensureDeviceIsMutable();
                                device_.addLong(v);
                                break;
                            } // case 16
                            case 18: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                ensureDeviceIsMutable();
                                while (input.getBytesUntilLimit() > 0) {
                                    device_.addLong(input.readInt64());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 18
                            case 26: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.parser(),
                                        extensionRegistry);
                                if (indexToDeviceGroupMapBuilder_ == null) {
                                    ensureIndexToDeviceGroupMapIsMutable();
                                    indexToDeviceGroupMap_.add(m);
                                } else {
                                    indexToDeviceGroupMapBuilder_.addMessage(m);
                                }
                                break;
                            } // case 26
                            case 34: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.parser(),
                                        extensionRegistry);
                                if (shardedDimBuilder_ == null) {
                                    ensureShardedDimIsMutable();
                                    shardedDim_.add(m);
                                } else {
                                    shardedDimBuilder_.addMessage(m);
                                }
                                break;
                            } // case 34
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.lang.Object tensorName_ = "";
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Identifies the input or output of the node that is being sharded.
             * Required to match a name specified in the node's input or output list of ValueInfoProtos.
             * It is called `logical tensor` in subsequent descriptions.
             * </pre>
             *
             * <code>optional string tensor_name = 1;</code>
             * @return Whether the tensorName field is set.
             */
            public boolean hasTensorName() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Identifies the input or output of the node that is being sharded.
             * Required to match a name specified in the node's input or output list of ValueInfoProtos.
             * It is called `logical tensor` in subsequent descriptions.
             * </pre>
             *
             * <code>optional string tensor_name = 1;</code>
             * @return The tensorName.
             */
            public java.lang.String getTensorName() {
                java.lang.Object ref = tensorName_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        tensorName_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Identifies the input or output of the node that is being sharded.
             * Required to match a name specified in the node's input or output list of ValueInfoProtos.
             * It is called `logical tensor` in subsequent descriptions.
             * </pre>
             *
             * <code>optional string tensor_name = 1;</code>
             * @return The bytes for tensorName.
             */
            public com.google.protobuf.ByteString
            getTensorNameBytes() {
                java.lang.Object ref = tensorName_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    tensorName_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Identifies the input or output of the node that is being sharded.
             * Required to match a name specified in the node's input or output list of ValueInfoProtos.
             * It is called `logical tensor` in subsequent descriptions.
             * </pre>
             *
             * <code>optional string tensor_name = 1;</code>
             * @param value The tensorName to set.
             * @return This builder for chaining.
             */
            public Builder setTensorName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                tensorName_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Identifies the input or output of the node that is being sharded.
             * Required to match a name specified in the node's input or output list of ValueInfoProtos.
             * It is called `logical tensor` in subsequent descriptions.
             * </pre>
             *
             * <code>optional string tensor_name = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearTensorName() {
                tensorName_ = getDefaultInstance().getTensorName();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Identifies the input or output of the node that is being sharded.
             * Required to match a name specified in the node's input or output list of ValueInfoProtos.
             * It is called `logical tensor` in subsequent descriptions.
             * </pre>
             *
             * <code>optional string tensor_name = 1;</code>
             * @param value The bytes for tensorName to set.
             * @return This builder for chaining.
             */
            public Builder setTensorNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                tensorName_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            
            private com.google.protobuf.Internal.LongList device_ = emptyLongList();
            private void ensureDeviceIsMutable() {
                if (!device_.isModifiable()) {
                    device_ = makeMutableCopy(device_);
                }
                bitField0_ |= 0x00000002;
            }
            /**
             * <pre>
             * The following is the list of devices across which the logical
             * tensor is sharded or replicated.
             * </pre>
             *
             * <code>repeated int64 device = 2;</code>
             * @return A list containing the device.
             */
            public java.util.List<java.lang.Long>
            getDeviceList() {
                device_.makeImmutable();
                return device_;
            }
            /**
             * <pre>
             * The following is the list of devices across which the logical
             * tensor is sharded or replicated.
             * </pre>
             *
             * <code>repeated int64 device = 2;</code>
             * @return The count of device.
             */
            public int getDeviceCount() {
                return device_.size();
            }
            /**
             * <pre>
             * The following is the list of devices across which the logical
             * tensor is sharded or replicated.
             * </pre>
             *
             * <code>repeated int64 device = 2;</code>
             * @param index The index of the element to return.
             * @return The device at the given index.
             */
            public long getDevice(int index) {
                return device_.getLong(index);
            }
            /**
             * <pre>
             * The following is the list of devices across which the logical
             * tensor is sharded or replicated.
             * </pre>
             *
             * <code>repeated int64 device = 2;</code>
             * @param index The index to set the value at.
             * @param value The device to set.
             * @return This builder for chaining.
             */
            public Builder setDevice(
                int index, long value) {
                
                ensureDeviceIsMutable();
                device_.setLong(index, value);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The following is the list of devices across which the logical
             * tensor is sharded or replicated.
             * </pre>
             *
             * <code>repeated int64 device = 2;</code>
             * @param value The device to add.
             * @return This builder for chaining.
             */
            public Builder addDevice(long value) {
                
                ensureDeviceIsMutable();
                device_.addLong(value);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The following is the list of devices across which the logical
             * tensor is sharded or replicated.
             * </pre>
             *
             * <code>repeated int64 device = 2;</code>
             * @param values The device to add.
             * @return This builder for chaining.
             */
            public Builder addAllDevice(
                java.lang.Iterable<? extends java.lang.Long> values) {
                ensureDeviceIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, device_);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The following is the list of devices across which the logical
             * tensor is sharded or replicated.
             * </pre>
             *
             * <code>repeated int64 device = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearDevice() {
                device_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000002);
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto> indexToDeviceGroupMap_ =
                java.util.Collections.emptyList();
            private void ensureIndexToDeviceGroupMapIsMutable() {
                if (!((bitField0_ & 0x00000004) != 0)) {
                    indexToDeviceGroupMap_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto>(indexToDeviceGroupMap_);
                    bitField0_ |= 0x00000004;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProtoOrBuilder> indexToDeviceGroupMapBuilder_;
            
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public java.util.List<ProtoOnnx.IntIntListEntryProto> getIndexToDeviceGroupMapList() {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(indexToDeviceGroupMap_);
                } else {
                    return indexToDeviceGroupMapBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public int getIndexToDeviceGroupMapCount() {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    return indexToDeviceGroupMap_.size();
                } else {
                    return indexToDeviceGroupMapBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto getIndexToDeviceGroupMap(int index) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    return indexToDeviceGroupMap_.get(index);
                } else {
                    return indexToDeviceGroupMapBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public Builder setIndexToDeviceGroupMap(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto value) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureIndexToDeviceGroupMapIsMutable();
                    indexToDeviceGroupMap_.set(index, value);
                    onChanged();
                } else {
                    indexToDeviceGroupMapBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public Builder setIndexToDeviceGroupMap(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.Builder builderForValue) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    ensureIndexToDeviceGroupMapIsMutable();
                    indexToDeviceGroupMap_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    indexToDeviceGroupMapBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public Builder addIndexToDeviceGroupMap(org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto value) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureIndexToDeviceGroupMapIsMutable();
                    indexToDeviceGroupMap_.add(value);
                    onChanged();
                } else {
                    indexToDeviceGroupMapBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public Builder addIndexToDeviceGroupMap(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto value) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureIndexToDeviceGroupMapIsMutable();
                    indexToDeviceGroupMap_.add(index, value);
                    onChanged();
                } else {
                    indexToDeviceGroupMapBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public Builder addIndexToDeviceGroupMap(
                ProtoOnnx.IntIntListEntryProto.Builder builderForValue) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    ensureIndexToDeviceGroupMapIsMutable();
                    indexToDeviceGroupMap_.add(builderForValue.build());
                    onChanged();
                } else {
                    indexToDeviceGroupMapBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public Builder addIndexToDeviceGroupMap(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.Builder builderForValue) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    ensureIndexToDeviceGroupMapIsMutable();
                    indexToDeviceGroupMap_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    indexToDeviceGroupMapBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public Builder addAllIndexToDeviceGroupMap(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto> values) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    ensureIndexToDeviceGroupMapIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, indexToDeviceGroupMap_);
                    onChanged();
                } else {
                    indexToDeviceGroupMapBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public Builder clearIndexToDeviceGroupMap() {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    indexToDeviceGroupMap_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000004);
                    onChanged();
                } else {
                    indexToDeviceGroupMapBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public Builder removeIndexToDeviceGroupMap(int index) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    ensureIndexToDeviceGroupMapIsMutable();
                    indexToDeviceGroupMap_.remove(index);
                    onChanged();
                } else {
                    indexToDeviceGroupMapBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.Builder getIndexToDeviceGroupMapBuilder(
                int index) {
                return internalGetIndexToDeviceGroupMapFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProtoOrBuilder getIndexToDeviceGroupMapOrBuilder(
                int index) {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    return indexToDeviceGroupMap_.get(index);  } else {
                    return indexToDeviceGroupMapBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProtoOrBuilder>
            getIndexToDeviceGroupMapOrBuilderList() {
                if (indexToDeviceGroupMapBuilder_ != null) {
                    return indexToDeviceGroupMapBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(indexToDeviceGroupMap_);
                }
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.Builder addIndexToDeviceGroupMapBuilder() {
                return internalGetIndexToDeviceGroupMapFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.Builder addIndexToDeviceGroupMapBuilder(
                int index) {
                return internalGetIndexToDeviceGroupMapFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Each element v in above field devices may represent either a
             * device or a set of devices (when we want the same shard/tensor
             * to be replicated across a subset of devices), as indicated by
             * the following optional map. If the map contains an entry for v,
             * then v represents a device group, and the map indicates the set
             * of devices in that group.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.IntIntListEntryProto index_to_device_group_map = 3;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.Builder>
            getIndexToDeviceGroupMapBuilderList() {
                return internalGetIndexToDeviceGroupMapFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProtoOrBuilder>
            internalGetIndexToDeviceGroupMapFieldBuilder() {
                if (indexToDeviceGroupMapBuilder_ == null) {
                    indexToDeviceGroupMapBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.IntIntListEntryProto, ProtoOnnx.IntIntListEntryProto.Builder, ProtoOnnx.IntIntListEntryProtoOrBuilder>(
                        indexToDeviceGroupMap_,
                        ((bitField0_ & 0x00000004) != 0),
                        getParentForChildren(),
                        isClean());
                    indexToDeviceGroupMap_ = null;
                }
                return indexToDeviceGroupMapBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto> shardedDim_ =
                java.util.Collections.emptyList();
            private void ensureShardedDimIsMutable() {
                if (!((bitField0_ & 0x00000008) != 0)) {
                    shardedDim_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto>(shardedDim_);
                    bitField0_ |= 0x00000008;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProtoOrBuilder> shardedDimBuilder_;
            
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto> getShardedDimList() {
                if (shardedDimBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(shardedDim_);
                } else {
                    return shardedDimBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public int getShardedDimCount() {
                if (shardedDimBuilder_ == null) {
                    return shardedDim_.size();
                } else {
                    return shardedDimBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto getShardedDim(int index) {
                if (shardedDimBuilder_ == null) {
                    return shardedDim_.get(index);
                } else {
                    return shardedDimBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public Builder setShardedDim(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto value) {
                if (shardedDimBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureShardedDimIsMutable();
                    shardedDim_.set(index, value);
                    onChanged();
                } else {
                    shardedDimBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public Builder setShardedDim(
                int index, ProtoOnnx.ShardedDimProto.Builder builderForValue) {
                if (shardedDimBuilder_ == null) {
                    ensureShardedDimIsMutable();
                    shardedDim_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    shardedDimBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public Builder addShardedDim(org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto value) {
                if (shardedDimBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureShardedDimIsMutable();
                    shardedDim_.add(value);
                    onChanged();
                } else {
                    shardedDimBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public Builder addShardedDim(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto value) {
                if (shardedDimBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureShardedDimIsMutable();
                    shardedDim_.add(index, value);
                    onChanged();
                } else {
                    shardedDimBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public Builder addShardedDim(
                org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.Builder builderForValue) {
                if (shardedDimBuilder_ == null) {
                    ensureShardedDimIsMutable();
                    shardedDim_.add(builderForValue.build());
                    onChanged();
                } else {
                    shardedDimBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public Builder addShardedDim(
                int index, ProtoOnnx.ShardedDimProto.Builder builderForValue) {
                if (shardedDimBuilder_ == null) {
                    ensureShardedDimIsMutable();
                    shardedDim_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    shardedDimBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public Builder addAllShardedDim(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto> values) {
                if (shardedDimBuilder_ == null) {
                    ensureShardedDimIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, shardedDim_);
                    onChanged();
                } else {
                    shardedDimBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public Builder clearShardedDim() {
                if (shardedDimBuilder_ == null) {
                    shardedDim_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000008);
                    onChanged();
                } else {
                    shardedDimBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public Builder removeShardedDim(int index) {
                if (shardedDimBuilder_ == null) {
                    ensureShardedDimIsMutable();
                    shardedDim_.remove(index);
                    onChanged();
                } else {
                    shardedDimBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.Builder getShardedDimBuilder(
                int index) {
                return internalGetShardedDimFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProtoOrBuilder getShardedDimOrBuilder(
                int index) {
                if (shardedDimBuilder_ == null) {
                    return shardedDim_.get(index);  } else {
                    return shardedDimBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProtoOrBuilder>
            getShardedDimOrBuilderList() {
                if (shardedDimBuilder_ != null) {
                    return shardedDimBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(shardedDim_);
                }
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.Builder addShardedDimBuilder() {
                return internalGetShardedDimFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.Builder addShardedDimBuilder(
                int index) {
                return internalGetShardedDimFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The following is the sharded-shape of the tensor, consisting of
             * the sharding-spec for each axis of the tensor.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ShardedDimProto sharded_dim = 4;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.Builder>
            getShardedDimBuilderList() {
                return internalGetShardedDimFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.ShardedDimProto, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProtoOrBuilder>
            internalGetShardedDimFieldBuilder() {
                if (shardedDimBuilder_ == null) {
                    shardedDimBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProtoOrBuilder>(
                        shardedDim_,
                        ((bitField0_ & 0x00000008) != 0),
                        getParentForChildren(),
                        isClean());
                    shardedDim_ = null;
                }
                return shardedDimBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.ShardingSpecProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.ShardingSpecProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto();
        }
        
        public static ProtoOnnx.ShardingSpecProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<ShardingSpecProto>
            PARSER = new com.google.protobuf.AbstractParser<ShardingSpecProto>() {
            @java.lang.Override
            public ShardingSpecProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<ShardingSpecProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<ShardingSpecProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ShardingSpecProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface ShardedDimProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.ShardedDimProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * The axis this sharding corresponds to. Must be in the range of
         * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
         * counting from the back.
         * </pre>
         *
         * <code>optional int64 axis = 1;</code>
         * @return Whether the axis field is set.
         */
        boolean hasAxis();
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * The axis this sharding corresponds to. Must be in the range of
         * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
         * counting from the back.
         * </pre>
         *
         * <code>optional int64 axis = 1;</code>
         * @return The axis.
         */
        long getAxis();
        
        /**
         * <pre>
         * Describes how the tensor on the provided axis is sharded.
         * The common-case is described by a single instance of SimpleShardedDimProto.
         * Multiple instances can be used to handle cases where a sharded
         * tensor is reshaped, fusing multiple axes into one.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto>
        getSimpleShardingList();
        /**
         * <pre>
         * Describes how the tensor on the provided axis is sharded.
         * The common-case is described by a single instance of SimpleShardedDimProto.
         * Multiple instances can be used to handle cases where a sharded
         * tensor is reshaped, fusing multiple axes into one.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto getSimpleSharding(int index);
        /**
         * <pre>
         * Describes how the tensor on the provided axis is sharded.
         * The common-case is described by a single instance of SimpleShardedDimProto.
         * Multiple instances can be used to handle cases where a sharded
         * tensor is reshaped, fusing multiple axes into one.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
         */
        int getSimpleShardingCount();
        /**
         * <pre>
         * Describes how the tensor on the provided axis is sharded.
         * The common-case is described by a single instance of SimpleShardedDimProto.
         * Multiple instances can be used to handle cases where a sharded
         * tensor is reshaped, fusing multiple axes into one.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProtoOrBuilder>
        getSimpleShardingOrBuilderList();
        /**
         * <pre>
         * Describes how the tensor on the provided axis is sharded.
         * The common-case is described by a single instance of SimpleShardedDimProto.
         * Multiple instances can be used to handle cases where a sharded
         * tensor is reshaped, fusing multiple axes into one.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProtoOrBuilder getSimpleShardingOrBuilder(
            int index);
    }
    /**
     * <pre>
     * ShardedDimProto: This describes the sharding spec for a single
     * axis of a sharded tensor.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.ShardedDimProto}
     */
    public static final class ShardedDimProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.ShardedDimProto)
        ShardedDimProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                ShardedDimProto.class.getName());
        }
        // Use ShardedDimProto.newBuilder() to construct.
        private ShardedDimProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private ShardedDimProto() {
            simpleSharding_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ShardedDimProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ShardedDimProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int AXIS_FIELD_NUMBER = 1;
        private long axis_ = 0L;
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * The axis this sharding corresponds to. Must be in the range of
         * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
         * counting from the back.
         * </pre>
         *
         * <code>optional int64 axis = 1;</code>
         * @return Whether the axis field is set.
         */
        @java.lang.Override
        public boolean hasAxis() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * The axis this sharding corresponds to. Must be in the range of
         * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
         * counting from the back.
         * </pre>
         *
         * <code>optional int64 axis = 1;</code>
         * @return The axis.
         */
        @java.lang.Override
        public long getAxis() {
            return axis_;
        }
        
        public static final int SIMPLE_SHARDING_FIELD_NUMBER = 2;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto> simpleSharding_;
        /**
         * <pre>
         * Describes how the tensor on the provided axis is sharded.
         * The common-case is described by a single instance of SimpleShardedDimProto.
         * Multiple instances can be used to handle cases where a sharded
         * tensor is reshaped, fusing multiple axes into one.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.SimpleShardedDimProto> getSimpleShardingList() {
            return simpleSharding_;
        }
        /**
         * <pre>
         * Describes how the tensor on the provided axis is sharded.
         * The common-case is described by a single instance of SimpleShardedDimProto.
         * Multiple instances can be used to handle cases where a sharded
         * tensor is reshaped, fusing multiple axes into one.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProtoOrBuilder>
        getSimpleShardingOrBuilderList() {
            return simpleSharding_;
        }
        /**
         * <pre>
         * Describes how the tensor on the provided axis is sharded.
         * The common-case is described by a single instance of SimpleShardedDimProto.
         * Multiple instances can be used to handle cases where a sharded
         * tensor is reshaped, fusing multiple axes into one.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
         */
        @java.lang.Override
        public int getSimpleShardingCount() {
            return simpleSharding_.size();
        }
        /**
         * <pre>
         * Describes how the tensor on the provided axis is sharded.
         * The common-case is described by a single instance of SimpleShardedDimProto.
         * Multiple instances can be used to handle cases where a sharded
         * tensor is reshaped, fusing multiple axes into one.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
         */
        @java.lang.Override
        public ProtoOnnx.SimpleShardedDimProto getSimpleSharding(int index) {
            return simpleSharding_.get(index);
        }
        /**
         * <pre>
         * Describes how the tensor on the provided axis is sharded.
         * The common-case is described by a single instance of SimpleShardedDimProto.
         * Multiple instances can be used to handle cases where a sharded
         * tensor is reshaped, fusing multiple axes into one.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProtoOrBuilder getSimpleShardingOrBuilder(
            int index) {
            return simpleSharding_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeInt64(1, axis_);
            }
            for (int i = 0; i < simpleSharding_.size(); i++) {
                output.writeMessage(2, simpleSharding_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt64Size(1, axis_);
            }
            for (int i = 0; i < simpleSharding_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(2, simpleSharding_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto) obj;
            
            if (hasAxis() != other.hasAxis()) return false;
            if (hasAxis()) {
                if (getAxis()
                    != other.getAxis()) return false;
            }
            if (!getSimpleShardingList()
                .equals(other.getSimpleShardingList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasAxis()) {
                hash = (37 * hash) + AXIS_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                    getAxis());
            }
            if (getSimpleShardingCount() > 0) {
                hash = (37 * hash) + SIMPLE_SHARDING_FIELD_NUMBER;
                hash = (53 * hash) + getSimpleShardingList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * ShardedDimProto: This describes the sharding spec for a single
         * axis of a sharded tensor.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.ShardedDimProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.ShardedDimProto)
            ProtoOnnx.ShardedDimProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ShardedDimProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ShardedDimProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                axis_ = 0L;
                if (simpleShardingBuilder_ == null) {
                    simpleSharding_ = java.util.Collections.emptyList();
                } else {
                    simpleSharding_ = null;
                    simpleShardingBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000002);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ProtoOnnx.internal_static_onnx_ShardedDimProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public ProtoOnnx.ShardedDimProto buildPartial() {
                ProtoOnnx.ShardedDimProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto result) {
                if (simpleShardingBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0)) {
                        simpleSharding_ = java.util.Collections.unmodifiableList(simpleSharding_);
                        bitField0_ = (bitField0_ & ~0x00000002);
                    }
                    result.simpleSharding_ = simpleSharding_;
                } else {
                    result.simpleSharding_ = simpleShardingBuilder_.build();
                }
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.axis_ = axis_;
                    to_bitField0_ |= 0x00000001;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto other) {
                if (other == ProtoOnnx.ShardedDimProto.getDefaultInstance()) return this;
                if (other.hasAxis()) {
                    setAxis(other.getAxis());
                }
                if (simpleShardingBuilder_ == null) {
                    if (!other.simpleSharding_.isEmpty()) {
                        if (simpleSharding_.isEmpty()) {
                            simpleSharding_ = other.simpleSharding_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                        } else {
                            ensureSimpleShardingIsMutable();
                            simpleSharding_.addAll(other.simpleSharding_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.simpleSharding_.isEmpty()) {
                        if (simpleShardingBuilder_.isEmpty()) {
                            simpleShardingBuilder_.dispose();
                            simpleShardingBuilder_ = null;
                            simpleSharding_ = other.simpleSharding_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                            simpleShardingBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetSimpleShardingFieldBuilder() : null;
                        } else {
                            simpleShardingBuilder_.addAllMessages(other.simpleSharding_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 8: {
                                axis_ = input.readInt64();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 8
                            case 18: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.parser(),
                                        extensionRegistry);
                                if (simpleShardingBuilder_ == null) {
                                    ensureSimpleShardingIsMutable();
                                    simpleSharding_.add(m);
                                } else {
                                    simpleShardingBuilder_.addMessage(m);
                                }
                                break;
                            } // case 18
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private long axis_ ;
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * The axis this sharding corresponds to. Must be in the range of
             * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
             * counting from the back.
             * </pre>
             *
             * <code>optional int64 axis = 1;</code>
             * @return Whether the axis field is set.
             */
            @java.lang.Override
            public boolean hasAxis() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * The axis this sharding corresponds to. Must be in the range of
             * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
             * counting from the back.
             * </pre>
             *
             * <code>optional int64 axis = 1;</code>
             * @return The axis.
             */
            @java.lang.Override
            public long getAxis() {
                return axis_;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * The axis this sharding corresponds to. Must be in the range of
             * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
             * counting from the back.
             * </pre>
             *
             * <code>optional int64 axis = 1;</code>
             * @param value The axis to set.
             * @return This builder for chaining.
             */
            public Builder setAxis(long value) {
                
                axis_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * The axis this sharding corresponds to. Must be in the range of
             * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
             * counting from the back.
             * </pre>
             *
             * <code>optional int64 axis = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearAxis() {
                bitField0_ = (bitField0_ & ~0x00000001);
                axis_ = 0L;
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto> simpleSharding_ =
                java.util.Collections.emptyList();
            private void ensureSimpleShardingIsMutable() {
                if (!((bitField0_ & 0x00000002) != 0)) {
                    simpleSharding_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto>(simpleSharding_);
                    bitField0_ |= 0x00000002;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto, org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProtoOrBuilder> simpleShardingBuilder_;
            
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto> getSimpleShardingList() {
                if (simpleShardingBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(simpleSharding_);
                } else {
                    return simpleShardingBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public int getSimpleShardingCount() {
                if (simpleShardingBuilder_ == null) {
                    return simpleSharding_.size();
                } else {
                    return simpleShardingBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public ProtoOnnx.SimpleShardedDimProto getSimpleSharding(int index) {
                if (simpleShardingBuilder_ == null) {
                    return simpleSharding_.get(index);
                } else {
                    return simpleShardingBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public Builder setSimpleSharding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto value) {
                if (simpleShardingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSimpleShardingIsMutable();
                    simpleSharding_.set(index, value);
                    onChanged();
                } else {
                    simpleShardingBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public Builder setSimpleSharding(
                int index, ProtoOnnx.SimpleShardedDimProto.Builder builderForValue) {
                if (simpleShardingBuilder_ == null) {
                    ensureSimpleShardingIsMutable();
                    simpleSharding_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    simpleShardingBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public Builder addSimpleSharding(org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto value) {
                if (simpleShardingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSimpleShardingIsMutable();
                    simpleSharding_.add(value);
                    onChanged();
                } else {
                    simpleShardingBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public Builder addSimpleSharding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto value) {
                if (simpleShardingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSimpleShardingIsMutable();
                    simpleSharding_.add(index, value);
                    onChanged();
                } else {
                    simpleShardingBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public Builder addSimpleSharding(
                org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.Builder builderForValue) {
                if (simpleShardingBuilder_ == null) {
                    ensureSimpleShardingIsMutable();
                    simpleSharding_.add(builderForValue.build());
                    onChanged();
                } else {
                    simpleShardingBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public Builder addSimpleSharding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.Builder builderForValue) {
                if (simpleShardingBuilder_ == null) {
                    ensureSimpleShardingIsMutable();
                    simpleSharding_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    simpleShardingBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public Builder addAllSimpleSharding(
                java.lang.Iterable<? extends ProtoOnnx.SimpleShardedDimProto> values) {
                if (simpleShardingBuilder_ == null) {
                    ensureSimpleShardingIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, simpleSharding_);
                    onChanged();
                } else {
                    simpleShardingBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public Builder clearSimpleSharding() {
                if (simpleShardingBuilder_ == null) {
                    simpleSharding_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000002);
                    onChanged();
                } else {
                    simpleShardingBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public Builder removeSimpleSharding(int index) {
                if (simpleShardingBuilder_ == null) {
                    ensureSimpleShardingIsMutable();
                    simpleSharding_.remove(index);
                    onChanged();
                } else {
                    simpleShardingBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.Builder getSimpleShardingBuilder(
                int index) {
                return internalGetSimpleShardingFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProtoOrBuilder getSimpleShardingOrBuilder(
                int index) {
                if (simpleShardingBuilder_ == null) {
                    return simpleSharding_.get(index);  } else {
                    return simpleShardingBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public java.util.List<? extends ProtoOnnx.SimpleShardedDimProtoOrBuilder>
            getSimpleShardingOrBuilderList() {
                if (simpleShardingBuilder_ != null) {
                    return simpleShardingBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(simpleSharding_);
                }
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.Builder addSimpleShardingBuilder() {
                return internalGetSimpleShardingFieldBuilder().addBuilder(
                    ProtoOnnx.SimpleShardedDimProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.Builder addSimpleShardingBuilder(
                int index) {
                return internalGetSimpleShardingFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Describes how the tensor on the provided axis is sharded.
             * The common-case is described by a single instance of SimpleShardedDimProto.
             * Multiple instances can be used to handle cases where a sharded
             * tensor is reshaped, fusing multiple axes into one.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SimpleShardedDimProto simple_sharding = 2;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.Builder>
            getSimpleShardingBuilderList() {
                return internalGetSimpleShardingFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto, org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProtoOrBuilder>
            internalGetSimpleShardingFieldBuilder() {
                if (simpleShardingBuilder_ == null) {
                    simpleShardingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto, ProtoOnnx.SimpleShardedDimProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProtoOrBuilder>(
                        simpleSharding_,
                        ((bitField0_ & 0x00000002) != 0),
                        getParentForChildren(),
                        isClean());
                    simpleSharding_ = null;
                }
                return simpleShardingBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.ShardedDimProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.ShardedDimProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ProtoOnnx.ShardedDimProto();
        }
        
        public static ProtoOnnx.ShardedDimProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<ShardedDimProto>
            PARSER = new com.google.protobuf.AbstractParser<ShardedDimProto>() {
            @java.lang.Override
            public ShardedDimProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<ShardedDimProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<ShardedDimProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ShardedDimProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface SimpleShardedDimProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.SimpleShardedDimProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <code>int64 dim_value = 1;</code>
         * @return Whether the dimValue field is set.
         */
        boolean hasDimValue();
        /**
         * <code>int64 dim_value = 1;</code>
         * @return The dimValue.
         */
        long getDimValue();
        
        /**
         * <code>string dim_param = 2;</code>
         * @return Whether the dimParam field is set.
         */
        boolean hasDimParam();
        /**
         * <code>string dim_param = 2;</code>
         * @return The dimParam.
         */
        java.lang.String getDimParam();
        /**
         * <code>string dim_param = 2;</code>
         * @return The bytes for dimParam.
         */
        com.google.protobuf.ByteString
        getDimParamBytes();
        
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Number of shards to split dim into.
         * </pre>
         *
         * <code>optional int64 num_shards = 3;</code>
         * @return Whether the numShards field is set.
         */
        boolean hasNumShards();
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Number of shards to split dim into.
         * </pre>
         *
         * <code>optional int64 num_shards = 3;</code>
         * @return The numShards.
         */
        long getNumShards();
        
        org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.DimCase getDimCase();
    }
    /**
     * <pre>
     * SimpleShardedDimProto: Indicates that N blocks are divided into M shards.
     * N is allowed to be symbolic where M is required to be a constant.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.SimpleShardedDimProto}
     */
    public static final class SimpleShardedDimProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.SimpleShardedDimProto)
        SimpleShardedDimProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                SimpleShardedDimProto.class.getName());
        }
        // Use SimpleShardedDimProto.newBuilder() to construct.
        private SimpleShardedDimProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private SimpleShardedDimProto() {
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ProtoOnnx.internal_static_onnx_SimpleShardedDimProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_SimpleShardedDimProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    ProtoOnnx.SimpleShardedDimProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.Builder.class);
        }
        
        private int bitField0_;
        private int dimCase_ = 0;
        @SuppressWarnings("serial")
        private java.lang.Object dim_;
        public enum DimCase
            implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
            DIM_VALUE(1),
            DIM_PARAM(2),
            DIM_NOT_SET(0);
            private final int value;
            private DimCase(int value) {
                this.value = value;
            }
            /**
             * @param value The number of the enum to look for.
             * @return The enum associated with the given number.
             * @deprecated Use {@link #forNumber(int)} instead.
             */
            @java.lang.Deprecated
            public static DimCase valueOf(int value) {
                return forNumber(value);
            }
            
            public static DimCase forNumber(int value) {
                switch (value) {
                    case 1: return DIM_VALUE;
                    case 2: return DIM_PARAM;
                    case 0: return DIM_NOT_SET;
                    default: return null;
                }
            }
            public int getNumber() {
                return this.value;
            }
        };
        
        public DimCase
        getDimCase() {
            return DimCase.forNumber(
                dimCase_);
        }
        
        public static final int DIM_VALUE_FIELD_NUMBER = 1;
        /**
         * <code>int64 dim_value = 1;</code>
         * @return Whether the dimValue field is set.
         */
        @java.lang.Override
        public boolean hasDimValue() {
            return dimCase_ == 1;
        }
        /**
         * <code>int64 dim_value = 1;</code>
         * @return The dimValue.
         */
        @java.lang.Override
        public long getDimValue() {
            if (dimCase_ == 1) {
                return (java.lang.Long) dim_;
            }
            return 0L;
        }
        
        public static final int DIM_PARAM_FIELD_NUMBER = 2;
        /**
         * <code>string dim_param = 2;</code>
         * @return Whether the dimParam field is set.
         */
        public boolean hasDimParam() {
            return dimCase_ == 2;
        }
        /**
         * <code>string dim_param = 2;</code>
         * @return The dimParam.
         */
        public java.lang.String getDimParam() {
            java.lang.Object ref = "";
            if (dimCase_ == 2) {
                ref = dim_;
            }
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8() && (dimCase_ == 2)) {
                    dim_ = s;
                }
                return s;
            }
        }
        /**
         * <code>string dim_param = 2;</code>
         * @return The bytes for dimParam.
         */
        public com.google.protobuf.ByteString
        getDimParamBytes() {
            java.lang.Object ref = "";
            if (dimCase_ == 2) {
                ref = dim_;
            }
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                if (dimCase_ == 2) {
                    dim_ = b;
                }
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int NUM_SHARDS_FIELD_NUMBER = 3;
        private long numShards_ = 0L;
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Number of shards to split dim into.
         * </pre>
         *
         * <code>optional int64 num_shards = 3;</code>
         * @return Whether the numShards field is set.
         */
        @java.lang.Override
        public boolean hasNumShards() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Number of shards to split dim into.
         * </pre>
         *
         * <code>optional int64 num_shards = 3;</code>
         * @return The numShards.
         */
        @java.lang.Override
        public long getNumShards() {
            return numShards_;
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (dimCase_ == 1) {
                output.writeInt64(
                    1, (long)((java.lang.Long) dim_));
            }
            if (dimCase_ == 2) {
                com.google.protobuf.GeneratedMessage.writeString(output, 2, dim_);
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeInt64(3, numShards_);
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (dimCase_ == 1) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt64Size(
                        1, (long)((java.lang.Long) dim_));
            }
            if (dimCase_ == 2) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(2, dim_);
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt64Size(3, numShards_);
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto)) {
                return super.equals(obj);
            }
            ProtoOnnx.SimpleShardedDimProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto) obj;
            
            if (hasNumShards() != other.hasNumShards()) return false;
            if (hasNumShards()) {
                if (getNumShards()
                    != other.getNumShards()) return false;
            }
            if (!getDimCase().equals(other.getDimCase())) return false;
            switch (dimCase_) {
                case 1:
                    if (getDimValue()
                        != other.getDimValue()) return false;
                    break;
                case 2:
                    if (!getDimParam()
                        .equals(other.getDimParam())) return false;
                    break;
                case 0:
                default:
            }
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasNumShards()) {
                hash = (37 * hash) + NUM_SHARDS_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                    getNumShards());
            }
            switch (dimCase_) {
                case 1:
                    hash = (37 * hash) + DIM_VALUE_FIELD_NUMBER;
                    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                        getDimValue());
                    break;
                case 2:
                    hash = (37 * hash) + DIM_PARAM_FIELD_NUMBER;
                    hash = (53 * hash) + getDimParam().hashCode();
                    break;
                case 0:
                default:
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.SimpleShardedDimProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * SimpleShardedDimProto: Indicates that N blocks are divided into M shards.
         * N is allowed to be symbolic where M is required to be a constant.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.SimpleShardedDimProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.SimpleShardedDimProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_SimpleShardedDimProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_SimpleShardedDimProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.class, ProtoOnnx.SimpleShardedDimProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                numShards_ = 0L;
                dimCase_ = 0;
                dim_ = null;
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_SimpleShardedDimProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto(this);
                if (bitField0_ != 0) { buildPartial0(result); }
                buildPartialOneofs(result);
                onBuilt();
                return result;
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    result.numShards_ = numShards_;
                    to_bitField0_ |= 0x00000001;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            private void buildPartialOneofs(org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto result) {
                result.dimCase_ = dimCase_;
                result.dim_ = this.dim_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(ProtoOnnx.SimpleShardedDimProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto.getDefaultInstance()) return this;
                if (other.hasNumShards()) {
                    setNumShards(other.getNumShards());
                }
                switch (other.getDimCase()) {
                    case DIM_VALUE: {
                        setDimValue(other.getDimValue());
                        break;
                    }
                    case DIM_PARAM: {
                        dimCase_ = 2;
                        dim_ = other.dim_;
                        onChanged();
                        break;
                    }
                    case DIM_NOT_SET: {
                        break;
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 8: {
                                dim_ = input.readInt64();
                                dimCase_ = 1;
                                break;
                            } // case 8
                            case 18: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                dimCase_ = 2;
                                dim_ = bs;
                                break;
                            } // case 18
                            case 24: {
                                numShards_ = input.readInt64();
                                bitField0_ |= 0x00000004;
                                break;
                            } // case 24
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int dimCase_ = 0;
            private java.lang.Object dim_;
            public DimCase
            getDimCase() {
                return DimCase.forNumber(
                    dimCase_);
            }
            
            public Builder clearDim() {
                dimCase_ = 0;
                dim_ = null;
                onChanged();
                return this;
            }
            
            private int bitField0_;
            
            /**
             * <code>int64 dim_value = 1;</code>
             * @return Whether the dimValue field is set.
             */
            public boolean hasDimValue() {
                return dimCase_ == 1;
            }
            /**
             * <code>int64 dim_value = 1;</code>
             * @return The dimValue.
             */
            public long getDimValue() {
                if (dimCase_ == 1) {
                    return (java.lang.Long) dim_;
                }
                return 0L;
            }
            /**
             * <code>int64 dim_value = 1;</code>
             * @param value The dimValue to set.
             * @return This builder for chaining.
             */
            public Builder setDimValue(long value) {
                
                dimCase_ = 1;
                dim_ = value;
                onChanged();
                return this;
            }
            /**
             * <code>int64 dim_value = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearDimValue() {
                if (dimCase_ == 1) {
                    dimCase_ = 0;
                    dim_ = null;
                    onChanged();
                }
                return this;
            }
            
            /**
             * <code>string dim_param = 2;</code>
             * @return Whether the dimParam field is set.
             */
            @java.lang.Override
            public boolean hasDimParam() {
                return dimCase_ == 2;
            }
            /**
             * <code>string dim_param = 2;</code>
             * @return The dimParam.
             */
            @java.lang.Override
            public java.lang.String getDimParam() {
                java.lang.Object ref = "";
                if (dimCase_ == 2) {
                    ref = dim_;
                }
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (dimCase_ == 2) {
                        if (bs.isValidUtf8()) {
                            dim_ = s;
                        }
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <code>string dim_param = 2;</code>
             * @return The bytes for dimParam.
             */
            @java.lang.Override
            public com.google.protobuf.ByteString
            getDimParamBytes() {
                java.lang.Object ref = "";
                if (dimCase_ == 2) {
                    ref = dim_;
                }
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    if (dimCase_ == 2) {
                        dim_ = b;
                    }
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <code>string dim_param = 2;</code>
             * @param value The dimParam to set.
             * @return This builder for chaining.
             */
            public Builder setDimParam(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                dimCase_ = 2;
                dim_ = value;
                onChanged();
                return this;
            }
            /**
             * <code>string dim_param = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearDimParam() {
                if (dimCase_ == 2) {
                    dimCase_ = 0;
                    dim_ = null;
                    onChanged();
                }
                return this;
            }
            /**
             * <code>string dim_param = 2;</code>
             * @param value The bytes for dimParam to set.
             * @return This builder for chaining.
             */
            public Builder setDimParamBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                dimCase_ = 2;
                dim_ = value;
                onChanged();
                return this;
            }
            
            private long numShards_ ;
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Number of shards to split dim into.
             * </pre>
             *
             * <code>optional int64 num_shards = 3;</code>
             * @return Whether the numShards field is set.
             */
            @java.lang.Override
            public boolean hasNumShards() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Number of shards to split dim into.
             * </pre>
             *
             * <code>optional int64 num_shards = 3;</code>
             * @return The numShards.
             */
            @java.lang.Override
            public long getNumShards() {
                return numShards_;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Number of shards to split dim into.
             * </pre>
             *
             * <code>optional int64 num_shards = 3;</code>
             * @param value The numShards to set.
             * @return This builder for chaining.
             */
            public Builder setNumShards(long value) {
                
                numShards_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Number of shards to split dim into.
             * </pre>
             *
             * <code>optional int64 num_shards = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearNumShards() {
                bitField0_ = (bitField0_ & ~0x00000004);
                numShards_ = 0L;
                onChanged();
                return this;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.SimpleShardedDimProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.SimpleShardedDimProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<SimpleShardedDimProto>
            PARSER = new com.google.protobuf.AbstractParser<SimpleShardedDimProto>() {
            @java.lang.Override
            public SimpleShardedDimProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<SimpleShardedDimProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<SimpleShardedDimProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.SimpleShardedDimProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface TrainingInfoProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TrainingInfoProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
         * @return Whether the initialization field is set.
         */
        boolean hasInitialization();
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
         * @return The initialization.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getInitialization();
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder getInitializationOrBuilder();
        
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         *
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         * tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         *
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
         * @return Whether the algorithm field is set.
         */
        boolean hasAlgorithm();
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         *
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         * tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         *
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
         * @return The algorithm.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getAlgorithm();
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         *
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         * tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         *
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
         */
        ProtoOnnx.GraphProtoOrBuilder getAlgorithmOrBuilder();
        
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>
        getInitializationBindingList();
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getInitializationBinding(int index);
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        int getInitializationBindingCount();
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getInitializationBindingOrBuilderList();
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(
            int index);
        
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         *
         * x = x - r * g
         *
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         *
         * y = x - r * g
         * x = y
         *
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         *
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *
         * 1. We have only unique keys in all "update_binding"s so that two
         * variables may not have the same name. This ensures that one
         * variable is assigned up to once.
         * 2. The keys must appear in names of "ModelProto.graph.initializer" or
         * "TrainingInfoProto.algorithm.initializer".
         * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         * 4. Mutable variables are initialized to the value specified by the
         * corresponding initializer, and then potentially updated by
         * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         *
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>
        getUpdateBindingList();
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         *
         * x = x - r * g
         *
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         *
         * y = x - r * g
         * x = y
         *
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         *
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *
         * 1. We have only unique keys in all "update_binding"s so that two
         * variables may not have the same name. This ensures that one
         * variable is assigned up to once.
         * 2. The keys must appear in names of "ModelProto.graph.initializer" or
         * "TrainingInfoProto.algorithm.initializer".
         * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         * 4. Mutable variables are initialized to the value specified by the
         * corresponding initializer, and then potentially updated by
         * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         *
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getUpdateBinding(int index);
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         *
         * x = x - r * g
         *
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         *
         * y = x - r * g
         * x = y
         *
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         *
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *
         * 1. We have only unique keys in all "update_binding"s so that two
         * variables may not have the same name. This ensures that one
         * variable is assigned up to once.
         * 2. The keys must appear in names of "ModelProto.graph.initializer" or
         * "TrainingInfoProto.algorithm.initializer".
         * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         * 4. Mutable variables are initialized to the value specified by the
         * corresponding initializer, and then potentially updated by
         * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         *
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
         */
        int getUpdateBindingCount();
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         *
         * x = x - r * g
         *
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         *
         * y = x - r * g
         * x = y
         *
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         *
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *
         * 1. We have only unique keys in all "update_binding"s so that two
         * variables may not have the same name. This ensures that one
         * variable is assigned up to once.
         * 2. The keys must appear in names of "ModelProto.graph.initializer" or
         * "TrainingInfoProto.algorithm.initializer".
         * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         * 4. Mutable variables are initialized to the value specified by the
         * corresponding initializer, and then potentially updated by
         * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         *
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getUpdateBindingOrBuilderList();
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         *
         * x = x - r * g
         *
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         *
         * y = x - r * g
         * x = y
         *
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         *
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *
         * 1. We have only unique keys in all "update_binding"s so that two
         * variables may not have the same name. This ensures that one
         * variable is assigned up to once.
         * 2. The keys must appear in names of "ModelProto.graph.initializer" or
         * "TrainingInfoProto.algorithm.initializer".
         * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         * 4. Mutable variables are initialized to the value specified by the
         * corresponding initializer, and then potentially updated by
         * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         *
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(
            int index);
    }
    /**
     * <pre>
     * Training information
     * TrainingInfoProto stores information for training a model.
     * In particular, this defines two functionalities: an initialization-step
     * and a training-algorithm-step. Initialization resets the model
     * back to its original state as if no training has been performed.
     * Training algorithm improves the model based on input data.
     *
     * The semantics of the initialization-step is that the initializers
     * in ModelProto.graph and in TrainingInfoProto.algorithm are first
     * initialized as specified by the initializers in the graph, and then
     * updated by the "initialization_binding" in every instance in
     * ModelProto.training_info.
     *
     * The field "algorithm" defines a computation graph which represents a
     * training algorithm's step. After the execution of a
     * TrainingInfoProto.algorithm, the initializers specified by "update_binding"
     * may be immediately updated. If the targeted training algorithm contains
     * consecutive update steps (such as block coordinate descent methods),
     * the user needs to create a TrainingInfoProto for each step.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.TrainingInfoProto}
     */
    public static final class TrainingInfoProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TrainingInfoProto)
        TrainingInfoProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                TrainingInfoProto.class.getName());
        }
        // Use TrainingInfoProto.newBuilder() to construct.
        private TrainingInfoProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private TrainingInfoProto() {
            initializationBinding_ = java.util.Collections.emptyList();
            updateBinding_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TrainingInfoProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TrainingInfoProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.class, ProtoOnnx.TrainingInfoProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int INITIALIZATION_FIELD_NUMBER = 1;
        private org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto initialization_;
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
         * @return Whether the initialization field is set.
         */
        @java.lang.Override
        public boolean hasInitialization() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
         * @return The initialization.
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getInitialization() {
            return initialization_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance() : initialization_;
        }
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder getInitializationOrBuilder() {
            return initialization_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance() : initialization_;
        }
        
        public static final int ALGORITHM_FIELD_NUMBER = 2;
        private org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto algorithm_;
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         *
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         * tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         *
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
         * @return Whether the algorithm field is set.
         */
        @java.lang.Override
        public boolean hasAlgorithm() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         *
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         * tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         *
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
         * @return The algorithm.
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getAlgorithm() {
            return algorithm_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance() : algorithm_;
        }
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         *
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         * tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         *
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         *
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder getAlgorithmOrBuilder() {
            return algorithm_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance() : algorithm_;
        }
        
        public static final int INITIALIZATION_BINDING_FIELD_NUMBER = 3;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> initializationBinding_;
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getInitializationBindingList() {
            return initializationBinding_;
        }
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getInitializationBindingOrBuilderList() {
            return initializationBinding_;
        }
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        @java.lang.Override
        public int getInitializationBindingCount() {
            return initializationBinding_.size();
        }
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        @java.lang.Override
        public ProtoOnnx.StringStringEntryProto getInitializationBinding(int index) {
            return initializationBinding_.get(index);
        }
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(
            int index) {
            return initializationBinding_.get(index);
        }
        
        public static final int UPDATE_BINDING_FIELD_NUMBER = 4;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> updateBinding_;
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         *
         * x = x - r * g
         *
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         *
         * y = x - r * g
         * x = y
         *
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         *
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *
         * 1. We have only unique keys in all "update_binding"s so that two
         * variables may not have the same name. This ensures that one
         * variable is assigned up to once.
         * 2. The keys must appear in names of "ModelProto.graph.initializer" or
         * "TrainingInfoProto.algorithm.initializer".
         * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         * 4. Mutable variables are initialized to the value specified by the
         * corresponding initializer, and then potentially updated by
         * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         *
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.StringStringEntryProto> getUpdateBindingList() {
            return updateBinding_;
        }
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         *
         * x = x - r * g
         *
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         *
         * y = x - r * g
         * x = y
         *
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         *
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *
         * 1. We have only unique keys in all "update_binding"s so that two
         * variables may not have the same name. This ensures that one
         * variable is assigned up to once.
         * 2. The keys must appear in names of "ModelProto.graph.initializer" or
         * "TrainingInfoProto.algorithm.initializer".
         * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         * 4. Mutable variables are initialized to the value specified by the
         * corresponding initializer, and then potentially updated by
         * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         *
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getUpdateBindingOrBuilderList() {
            return updateBinding_;
        }
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         *
         * x = x - r * g
         *
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         *
         * y = x - r * g
         * x = y
         *
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         *
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *
         * 1. We have only unique keys in all "update_binding"s so that two
         * variables may not have the same name. This ensures that one
         * variable is assigned up to once.
         * 2. The keys must appear in names of "ModelProto.graph.initializer" or
         * "TrainingInfoProto.algorithm.initializer".
         * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         * 4. Mutable variables are initialized to the value specified by the
         * corresponding initializer, and then potentially updated by
         * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         *
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
         */
        @java.lang.Override
        public int getUpdateBindingCount() {
            return updateBinding_.size();
        }
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         *
         * x = x - r * g
         *
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         *
         * y = x - r * g
         * x = y
         *
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         *
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *
         * 1. We have only unique keys in all "update_binding"s so that two
         * variables may not have the same name. This ensures that one
         * variable is assigned up to once.
         * 2. The keys must appear in names of "ModelProto.graph.initializer" or
         * "TrainingInfoProto.algorithm.initializer".
         * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         * 4. Mutable variables are initialized to the value specified by the
         * corresponding initializer, and then potentially updated by
         * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         *
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getUpdateBinding(int index) {
            return updateBinding_.get(index);
        }
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         *
         * x = x - r * g
         *
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         *
         * y = x - r * g
         * x = y
         *
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         *
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *
         * 1. We have only unique keys in all "update_binding"s so that two
         * variables may not have the same name. This ensures that one
         * variable is assigned up to once.
         * 2. The keys must appear in names of "ModelProto.graph.initializer" or
         * "TrainingInfoProto.algorithm.initializer".
         * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         * 4. Mutable variables are initialized to the value specified by the
         * corresponding initializer, and then potentially updated by
         * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         *
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         *
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
         */
        @java.lang.Override
        public ProtoOnnx.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(
            int index) {
            return updateBinding_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeMessage(1, getInitialization());
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeMessage(2, getAlgorithm());
            }
            for (int i = 0; i < initializationBinding_.size(); i++) {
                output.writeMessage(3, initializationBinding_.get(i));
            }
            for (int i = 0; i < updateBinding_.size(); i++) {
                output.writeMessage(4, updateBinding_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(1, getInitialization());
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(2, getAlgorithm());
            }
            for (int i = 0; i < initializationBinding_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(3, initializationBinding_.get(i));
            }
            for (int i = 0; i < updateBinding_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(4, updateBinding_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto) obj;
            
            if (hasInitialization() != other.hasInitialization()) return false;
            if (hasInitialization()) {
                if (!getInitialization()
                    .equals(other.getInitialization())) return false;
            }
            if (hasAlgorithm() != other.hasAlgorithm()) return false;
            if (hasAlgorithm()) {
                if (!getAlgorithm()
                    .equals(other.getAlgorithm())) return false;
            }
            if (!getInitializationBindingList()
                .equals(other.getInitializationBindingList())) return false;
            if (!getUpdateBindingList()
                .equals(other.getUpdateBindingList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasInitialization()) {
                hash = (37 * hash) + INITIALIZATION_FIELD_NUMBER;
                hash = (53 * hash) + getInitialization().hashCode();
            }
            if (hasAlgorithm()) {
                hash = (37 * hash) + ALGORITHM_FIELD_NUMBER;
                hash = (53 * hash) + getAlgorithm().hashCode();
            }
            if (getInitializationBindingCount() > 0) {
                hash = (37 * hash) + INITIALIZATION_BINDING_FIELD_NUMBER;
                hash = (53 * hash) + getInitializationBindingList().hashCode();
            }
            if (getUpdateBindingCount() > 0) {
                hash = (37 * hash) + UPDATE_BINDING_FIELD_NUMBER;
                hash = (53 * hash) + getUpdateBindingList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.TrainingInfoProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static ProtoOnnx.TrainingInfoProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Training information
         * TrainingInfoProto stores information for training a model.
         * In particular, this defines two functionalities: an initialization-step
         * and a training-algorithm-step. Initialization resets the model
         * back to its original state as if no training has been performed.
         * Training algorithm improves the model based on input data.
         *
         * The semantics of the initialization-step is that the initializers
         * in ModelProto.graph and in TrainingInfoProto.algorithm are first
         * initialized as specified by the initializers in the graph, and then
         * updated by the "initialization_binding" in every instance in
         * ModelProto.training_info.
         *
         * The field "algorithm" defines a computation graph which represents a
         * training algorithm's step. After the execution of a
         * TrainingInfoProto.algorithm, the initializers specified by "update_binding"
         * may be immediately updated. If the targeted training algorithm contains
         * consecutive update steps (such as block coordinate descent methods),
         * the user needs to create a TrainingInfoProto for each step.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.TrainingInfoProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TrainingInfoProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TrainingInfoProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TrainingInfoProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        ProtoOnnx.TrainingInfoProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessage
                    .alwaysUseFieldBuilders) {
                    internalGetInitializationFieldBuilder();
                    internalGetAlgorithmFieldBuilder();
                    internalGetInitializationBindingFieldBuilder();
                    internalGetUpdateBindingFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                initialization_ = null;
                if (initializationBuilder_ != null) {
                    initializationBuilder_.dispose();
                    initializationBuilder_ = null;
                }
                algorithm_ = null;
                if (algorithmBuilder_ != null) {
                    algorithmBuilder_.dispose();
                    algorithmBuilder_ = null;
                }
                if (initializationBindingBuilder_ == null) {
                    initializationBinding_ = java.util.Collections.emptyList();
                } else {
                    initializationBinding_ = null;
                    initializationBindingBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000004);
                if (updateBindingBuilder_ == null) {
                    updateBinding_ = java.util.Collections.emptyList();
                } else {
                    updateBinding_ = null;
                    updateBindingBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000008);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ProtoOnnx.internal_static_onnx_TrainingInfoProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto result) {
                if (initializationBindingBuilder_ == null) {
                    if (((bitField0_ & 0x00000004) != 0)) {
                        initializationBinding_ = java.util.Collections.unmodifiableList(initializationBinding_);
                        bitField0_ = (bitField0_ & ~0x00000004);
                    }
                    result.initializationBinding_ = initializationBinding_;
                } else {
                    result.initializationBinding_ = initializationBindingBuilder_.build();
                }
                if (updateBindingBuilder_ == null) {
                    if (((bitField0_ & 0x00000008) != 0)) {
                        updateBinding_ = java.util.Collections.unmodifiableList(updateBinding_);
                        bitField0_ = (bitField0_ & ~0x00000008);
                    }
                    result.updateBinding_ = updateBinding_;
                } else {
                    result.updateBinding_ = updateBindingBuilder_.build();
                }
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.initialization_ = initializationBuilder_ == null
                        ? initialization_
                        : initializationBuilder_.build();
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.algorithm_ = algorithmBuilder_ == null
                        ? algorithm_
                        : algorithmBuilder_.build();
                    to_bitField0_ |= 0x00000002;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.getDefaultInstance()) return this;
                if (other.hasInitialization()) {
                    mergeInitialization(other.getInitialization());
                }
                if (other.hasAlgorithm()) {
                    mergeAlgorithm(other.getAlgorithm());
                }
                if (initializationBindingBuilder_ == null) {
                    if (!other.initializationBinding_.isEmpty()) {
                        if (initializationBinding_.isEmpty()) {
                            initializationBinding_ = other.initializationBinding_;
                            bitField0_ = (bitField0_ & ~0x00000004);
                        } else {
                            ensureInitializationBindingIsMutable();
                            initializationBinding_.addAll(other.initializationBinding_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.initializationBinding_.isEmpty()) {
                        if (initializationBindingBuilder_.isEmpty()) {
                            initializationBindingBuilder_.dispose();
                            initializationBindingBuilder_ = null;
                            initializationBinding_ = other.initializationBinding_;
                            bitField0_ = (bitField0_ & ~0x00000004);
                            initializationBindingBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetInitializationBindingFieldBuilder() : null;
                        } else {
                            initializationBindingBuilder_.addAllMessages(other.initializationBinding_);
                        }
                    }
                }
                if (updateBindingBuilder_ == null) {
                    if (!other.updateBinding_.isEmpty()) {
                        if (updateBinding_.isEmpty()) {
                            updateBinding_ = other.updateBinding_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                        } else {
                            ensureUpdateBindingIsMutable();
                            updateBinding_.addAll(other.updateBinding_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.updateBinding_.isEmpty()) {
                        if (updateBindingBuilder_.isEmpty()) {
                            updateBindingBuilder_.dispose();
                            updateBindingBuilder_ = null;
                            updateBinding_ = other.updateBinding_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                            updateBindingBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetUpdateBindingFieldBuilder() : null;
                        } else {
                            updateBindingBuilder_.addAllMessages(other.updateBinding_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                input.readMessage(
                                    internalGetInitializationFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 18: {
                                input.readMessage(
                                    internalGetAlgorithmFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 18
                            case 26: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.parser(),
                                        extensionRegistry);
                                if (initializationBindingBuilder_ == null) {
                                    ensureInitializationBindingIsMutable();
                                    initializationBinding_.add(m);
                                } else {
                                    initializationBindingBuilder_.addMessage(m);
                                }
                                break;
                            } // case 26
                            case 34: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.parser(),
                                        extensionRegistry);
                                if (updateBindingBuilder_ == null) {
                                    ensureUpdateBindingIsMutable();
                                    updateBinding_.add(m);
                                } else {
                                    updateBindingBuilder_.addMessage(m);
                                }
                                break;
                            } // case 34
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto initialization_;
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder> initializationBuilder_;
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
             * @return Whether the initialization field is set.
             */
            public boolean hasInitialization() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
             * @return The initialization.
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getInitialization() {
                if (initializationBuilder_ == null) {
                    return initialization_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance() : initialization_;
                } else {
                    return initializationBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
             */
            public Builder setInitialization(org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto value) {
                if (initializationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    initialization_ = value;
                } else {
                    initializationBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
             */
            public Builder setInitialization(
                org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder builderForValue) {
                if (initializationBuilder_ == null) {
                    initialization_ = builderForValue.build();
                } else {
                    initializationBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
             */
            public Builder mergeInitialization(org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto value) {
                if (initializationBuilder_ == null) {
                    if (((bitField0_ & 0x00000001) != 0) &&
                        initialization_ != null &&
                        initialization_ != org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance()) {
                        getInitializationBuilder().mergeFrom(value);
                    } else {
                        initialization_ = value;
                    }
                } else {
                    initializationBuilder_.mergeFrom(value);
                }
                if (initialization_ != null) {
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                return this;
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
             */
            public Builder clearInitialization() {
                bitField0_ = (bitField0_ & ~0x00000001);
                initialization_ = null;
                if (initializationBuilder_ != null) {
                    initializationBuilder_.dispose();
                    initializationBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder getInitializationBuilder() {
                bitField0_ |= 0x00000001;
                onChanged();
                return internalGetInitializationFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder getInitializationOrBuilder() {
                if (initializationBuilder_ != null) {
                    return initializationBuilder_.getMessageOrBuilder();
                } else {
                    return initialization_ == null ?
                        ProtoOnnx.GraphProto.getDefaultInstance() : initialization_;
                }
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto initialization = 1;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto, ProtoOnnx.GraphProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder>
            internalGetInitializationFieldBuilder() {
                if (initializationBuilder_ == null) {
                    initializationBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder>(
                        getInitialization(),
                        getParentForChildren(),
                        isClean());
                    initialization_ = null;
                }
                return initializationBuilder_;
            }
            
            private org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto algorithm_;
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder, ProtoOnnx.GraphProtoOrBuilder> algorithmBuilder_;
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             *
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             * tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             *
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
             * @return Whether the algorithm field is set.
             */
            public boolean hasAlgorithm() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             *
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             * tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             *
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
             * @return The algorithm.
             */
            public ProtoOnnx.GraphProto getAlgorithm() {
                if (algorithmBuilder_ == null) {
                    return algorithm_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance() : algorithm_;
                } else {
                    return algorithmBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             *
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             * tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             *
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
             */
            public Builder setAlgorithm(org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto value) {
                if (algorithmBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    algorithm_ = value;
                } else {
                    algorithmBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             *
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             * tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             *
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
             */
            public Builder setAlgorithm(
                org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder builderForValue) {
                if (algorithmBuilder_ == null) {
                    algorithm_ = builderForValue.build();
                } else {
                    algorithmBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             *
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             * tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             *
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
             */
            public Builder mergeAlgorithm(org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto value) {
                if (algorithmBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0) &&
                        algorithm_ != null &&
                        algorithm_ != org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance()) {
                        getAlgorithmBuilder().mergeFrom(value);
                    } else {
                        algorithm_ = value;
                    }
                } else {
                    algorithmBuilder_.mergeFrom(value);
                }
                if (algorithm_ != null) {
                    bitField0_ |= 0x00000002;
                    onChanged();
                }
                return this;
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             *
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             * tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             *
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
             */
            public Builder clearAlgorithm() {
                bitField0_ = (bitField0_ & ~0x00000002);
                algorithm_ = null;
                if (algorithmBuilder_ != null) {
                    algorithmBuilder_.dispose();
                    algorithmBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             *
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             * tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             *
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder getAlgorithmBuilder() {
                bitField0_ |= 0x00000002;
                onChanged();
                return internalGetAlgorithmFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             *
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             * tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             *
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
             */
            public ProtoOnnx.GraphProtoOrBuilder getAlgorithmOrBuilder() {
                if (algorithmBuilder_ != null) {
                    return algorithmBuilder_.getMessageOrBuilder();
                } else {
                    return algorithm_ == null ?
                        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance() : algorithm_;
                }
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             *
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             * tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             *
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             *
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto algorithm = 2;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                ProtoOnnx.GraphProto, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder, ProtoOnnx.GraphProtoOrBuilder>
            internalGetAlgorithmFieldBuilder() {
                if (algorithmBuilder_ == null) {
                    algorithmBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder>(
                        getAlgorithm(),
                        getParentForChildren(),
                        isClean());
                    algorithm_ = null;
                }
                return algorithmBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> initializationBinding_ =
                java.util.Collections.emptyList();
            private void ensureInitializationBindingIsMutable() {
                if (!((bitField0_ & 0x00000004) != 0)) {
                    initializationBinding_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>(initializationBinding_);
                    bitField0_ |= 0x00000004;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder> initializationBindingBuilder_;
            
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getInitializationBindingList() {
                if (initializationBindingBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(initializationBinding_);
                } else {
                    return initializationBindingBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public int getInitializationBindingCount() {
                if (initializationBindingBuilder_ == null) {
                    return initializationBinding_.size();
                } else {
                    return initializationBindingBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getInitializationBinding(int index) {
                if (initializationBindingBuilder_ == null) {
                    return initializationBinding_.get(index);
                } else {
                    return initializationBindingBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder setInitializationBinding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (initializationBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.set(index, value);
                    onChanged();
                } else {
                    initializationBindingBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder setInitializationBinding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (initializationBindingBuilder_ == null) {
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    initializationBindingBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder addInitializationBinding(org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (initializationBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.add(value);
                    onChanged();
                } else {
                    initializationBindingBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder addInitializationBinding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (initializationBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.add(index, value);
                    onChanged();
                } else {
                    initializationBindingBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder addInitializationBinding(
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (initializationBindingBuilder_ == null) {
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.add(builderForValue.build());
                    onChanged();
                } else {
                    initializationBindingBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder addInitializationBinding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (initializationBindingBuilder_ == null) {
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    initializationBindingBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder addAllInitializationBinding(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> values) {
                if (initializationBindingBuilder_ == null) {
                    ensureInitializationBindingIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, initializationBinding_);
                    onChanged();
                } else {
                    initializationBindingBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder clearInitializationBinding() {
                if (initializationBindingBuilder_ == null) {
                    initializationBinding_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000004);
                    onChanged();
                } else {
                    initializationBindingBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder removeInitializationBinding(int index) {
                if (initializationBindingBuilder_ == null) {
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.remove(index);
                    onChanged();
                } else {
                    initializationBindingBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder getInitializationBindingBuilder(
                int index) {
                return internalGetInitializationBindingFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public ProtoOnnx.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(
                int index) {
                if (initializationBindingBuilder_ == null) {
                    return initializationBinding_.get(index);  } else {
                    return initializationBindingBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            getInitializationBindingOrBuilderList() {
                if (initializationBindingBuilder_ != null) {
                    return initializationBindingBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(initializationBinding_);
                }
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addInitializationBindingBuilder() {
                return internalGetInitializationBindingFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addInitializationBindingBuilder(
                int index) {
                return internalGetInitializationBindingFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder>
            getInitializationBindingBuilderList() {
                return internalGetInitializationBindingFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            internalGetInitializationBindingFieldBuilder() {
                if (initializationBindingBuilder_ == null) {
                    initializationBindingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>(
                        initializationBinding_,
                        ((bitField0_ & 0x00000004) != 0),
                        getParentForChildren(),
                        isClean());
                    initializationBinding_ = null;
                }
                return initializationBindingBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> updateBinding_ =
                java.util.Collections.emptyList();
            private void ensureUpdateBindingIsMutable() {
                if (!((bitField0_ & 0x00000008) != 0)) {
                    updateBinding_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>(updateBinding_);
                    bitField0_ |= 0x00000008;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder> updateBindingBuilder_;
            
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getUpdateBindingList() {
                if (updateBindingBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(updateBinding_);
                } else {
                    return updateBindingBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public int getUpdateBindingCount() {
                if (updateBindingBuilder_ == null) {
                    return updateBinding_.size();
                } else {
                    return updateBindingBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getUpdateBinding(int index) {
                if (updateBindingBuilder_ == null) {
                    return updateBinding_.get(index);
                } else {
                    return updateBindingBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder setUpdateBinding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (updateBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureUpdateBindingIsMutable();
                    updateBinding_.set(index, value);
                    onChanged();
                } else {
                    updateBindingBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder setUpdateBinding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (updateBindingBuilder_ == null) {
                    ensureUpdateBindingIsMutable();
                    updateBinding_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    updateBindingBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder addUpdateBinding(org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (updateBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureUpdateBindingIsMutable();
                    updateBinding_.add(value);
                    onChanged();
                } else {
                    updateBindingBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder addUpdateBinding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (updateBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureUpdateBindingIsMutable();
                    updateBinding_.add(index, value);
                    onChanged();
                } else {
                    updateBindingBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder addUpdateBinding(
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (updateBindingBuilder_ == null) {
                    ensureUpdateBindingIsMutable();
                    updateBinding_.add(builderForValue.build());
                    onChanged();
                } else {
                    updateBindingBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder addUpdateBinding(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (updateBindingBuilder_ == null) {
                    ensureUpdateBindingIsMutable();
                    updateBinding_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    updateBindingBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder addAllUpdateBinding(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> values) {
                if (updateBindingBuilder_ == null) {
                    ensureUpdateBindingIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, updateBinding_);
                    onChanged();
                } else {
                    updateBindingBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder clearUpdateBinding() {
                if (updateBindingBuilder_ == null) {
                    updateBinding_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000008);
                    onChanged();
                } else {
                    updateBindingBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder removeUpdateBinding(int index) {
                if (updateBindingBuilder_ == null) {
                    ensureUpdateBindingIsMutable();
                    updateBinding_.remove(index);
                    onChanged();
                } else {
                    updateBindingBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder getUpdateBindingBuilder(
                int index) {
                return internalGetUpdateBindingFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(
                int index) {
                if (updateBindingBuilder_ == null) {
                    return updateBinding_.get(index);  } else {
                    return updateBindingBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            getUpdateBindingOrBuilderList() {
                if (updateBindingBuilder_ != null) {
                    return updateBindingBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(updateBinding_);
                }
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addUpdateBindingBuilder() {
                return internalGetUpdateBindingFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addUpdateBindingBuilder(
                int index) {
                return internalGetUpdateBindingFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             *
             * x = x - r * g
             *
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             *
             * y = x - r * g
             * x = y
             *
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             *
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *
             * 1. We have only unique keys in all "update_binding"s so that two
             * variables may not have the same name. This ensures that one
             * variable is assigned up to once.
             * 2. The keys must appear in names of "ModelProto.graph.initializer" or
             * "TrainingInfoProto.algorithm.initializer".
             * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             * 4. Mutable variables are initialized to the value specified by the
             * corresponding initializer, and then potentially updated by
             * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             *
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             *
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder>
            getUpdateBindingBuilderList() {
                return internalGetUpdateBindingFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            internalGetUpdateBindingFieldBuilder() {
                if (updateBindingBuilder_ == null) {
                    updateBindingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, ProtoOnnx.StringStringEntryProtoOrBuilder>(
                        updateBinding_,
                        ((bitField0_ & 0x00000008) != 0),
                        getParentForChildren(),
                        isClean());
                    updateBinding_ = null;
                }
                return updateBindingBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TrainingInfoProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TrainingInfoProto)
        private static final ProtoOnnx.TrainingInfoProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ProtoOnnx.TrainingInfoProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<TrainingInfoProto>
            PARSER = new com.google.protobuf.AbstractParser<TrainingInfoProto>() {
            @java.lang.Override
            public TrainingInfoProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<TrainingInfoProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<TrainingInfoProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface ModelProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.ModelProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * The version of the IR this model targets. See Version enum above.
         * This field MUST be present.
         * </pre>
         *
         * <code>optional int64 ir_version = 1;</code>
         * @return Whether the irVersion field is set.
         */
        boolean hasIrVersion();
        /**
         * <pre>
         * The version of the IR this model targets. See Version enum above.
         * This field MUST be present.
         * </pre>
         *
         * <code>optional int64 ir_version = 1;</code>
         * @return The irVersion.
         */
        long getIrVersion();
        
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         *
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto>
        getOpsetImportList();
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         *
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto getOpsetImport(int index);
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         *
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        int getOpsetImportCount();
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         *
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder>
        getOpsetImportOrBuilderList();
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         *
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
            int index);
        
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return Whether the producerName field is set.
         */
        boolean hasProducerName();
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return The producerName.
         */
        java.lang.String getProducerName();
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return The bytes for producerName.
         */
        com.google.protobuf.ByteString
        getProducerNameBytes();
        
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return Whether the producerVersion field is set.
         */
        boolean hasProducerVersion();
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return The producerVersion.
         */
        java.lang.String getProducerVersion();
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return The bytes for producerVersion.
         */
        com.google.protobuf.ByteString
        getProducerVersionBytes();
        
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         *
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return Whether the domain field is set.
         */
        boolean hasDomain();
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         *
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return The domain.
         */
        java.lang.String getDomain();
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         *
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return The bytes for domain.
         */
        com.google.protobuf.ByteString
        getDomainBytes();
        
        /**
         * <pre>
         * The version of the graph encoded. See Version enum below.
         * </pre>
         *
         * <code>optional int64 model_version = 5;</code>
         * @return Whether the modelVersion field is set.
         */
        boolean hasModelVersion();
        /**
         * <pre>
         * The version of the graph encoded. See Version enum below.
         * </pre>
         *
         * <code>optional int64 model_version = 5;</code>
         * @return The modelVersion.
         */
        long getModelVersion();
        
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();
        
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
         * @return Whether the graph field is set.
         */
        boolean hasGraph();
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
         * @return The graph.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getGraph();
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder getGraphOrBuilder();
        
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        java.util.List<ProtoOnnx.StringStringEntryProto>
        getMetadataPropsList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index);
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        int getMetadataPropsCount();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index);
        
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         *
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto>
        getTrainingInfoList();
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         *
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto getTrainingInfo(int index);
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         *
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
         */
        int getTrainingInfoCount();
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         *
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProtoOrBuilder>
        getTrainingInfoOrBuilderList();
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         *
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(
            int index);
        
        /**
         * <pre>
         * A list of function protos local to the model.
         *
         * The (domain, name, overload) tuple must be unique across the function protos in this list.
         * In case of any conflicts the behavior (whether the model local functions are given higher priority,
         * or standard operator sets are given higher priority or this is treated as error) is defined by
         * the runtimes.
         *
         * The operator sets imported by FunctionProto should be compatible with the ones
         * imported by ModelProto and other model local FunctionProtos.
         * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
         * or by 2 FunctionProtos then versions for the operator set may be different but,
         * the operator schema returned for op_type, domain, version combination
         * for both the versions should be same for every node in the function body.
         *
         * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
         * is not allowed.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto>
        getFunctionsList();
        /**
         * <pre>
         * A list of function protos local to the model.
         *
         * The (domain, name, overload) tuple must be unique across the function protos in this list.
         * In case of any conflicts the behavior (whether the model local functions are given higher priority,
         * or standard operator sets are given higher priority or this is treated as error) is defined by
         * the runtimes.
         *
         * The operator sets imported by FunctionProto should be compatible with the ones
         * imported by ModelProto and other model local FunctionProtos.
         * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
         * or by 2 FunctionProtos then versions for the operator set may be different but,
         * the operator schema returned for op_type, domain, version combination
         * for both the versions should be same for every node in the function body.
         *
         * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
         * is not allowed.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto getFunctions(int index);
        /**
         * <pre>
         * A list of function protos local to the model.
         *
         * The (domain, name, overload) tuple must be unique across the function protos in this list.
         * In case of any conflicts the behavior (whether the model local functions are given higher priority,
         * or standard operator sets are given higher priority or this is treated as error) is defined by
         * the runtimes.
         *
         * The operator sets imported by FunctionProto should be compatible with the ones
         * imported by ModelProto and other model local FunctionProtos.
         * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
         * or by 2 FunctionProtos then versions for the operator set may be different but,
         * the operator schema returned for op_type, domain, version combination
         * for both the versions should be same for every node in the function body.
         *
         * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
         * is not allowed.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
         */
        int getFunctionsCount();
        /**
         * <pre>
         * A list of function protos local to the model.
         *
         * The (domain, name, overload) tuple must be unique across the function protos in this list.
         * In case of any conflicts the behavior (whether the model local functions are given higher priority,
         * or standard operator sets are given higher priority or this is treated as error) is defined by
         * the runtimes.
         *
         * The operator sets imported by FunctionProto should be compatible with the ones
         * imported by ModelProto and other model local FunctionProtos.
         * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
         * or by 2 FunctionProtos then versions for the operator set may be different but,
         * the operator schema returned for op_type, domain, version combination
         * for both the versions should be same for every node in the function body.
         *
         * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
         * is not allowed.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProtoOrBuilder>
        getFunctionsOrBuilderList();
        /**
         * <pre>
         * A list of function protos local to the model.
         *
         * The (domain, name, overload) tuple must be unique across the function protos in this list.
         * In case of any conflicts the behavior (whether the model local functions are given higher priority,
         * or standard operator sets are given higher priority or this is treated as error) is defined by
         * the runtimes.
         *
         * The operator sets imported by FunctionProto should be compatible with the ones
         * imported by ModelProto and other model local FunctionProtos.
         * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
         * or by 2 FunctionProtos then versions for the operator set may be different but,
         * the operator schema returned for op_type, domain, version combination
         * for both the versions should be same for every node in the function body.
         *
         * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
         * is not allowed.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProtoOrBuilder getFunctionsOrBuilder(
            int index);
        
        /**
         * <pre>
         * Describes different target configurations for a multi-device use case.
         * A model MAY describe multiple multi-device configurations for execution.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto>
        getConfigurationList();
        /**
         * <pre>
         * Describes different target configurations for a multi-device use case.
         * A model MAY describe multiple multi-device configurations for execution.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto getConfiguration(int index);
        /**
         * <pre>
         * Describes different target configurations for a multi-device use case.
         * A model MAY describe multiple multi-device configurations for execution.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
         */
        int getConfigurationCount();
        /**
         * <pre>
         * Describes different target configurations for a multi-device use case.
         * A model MAY describe multiple multi-device configurations for execution.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProtoOrBuilder>
        getConfigurationOrBuilderList();
        /**
         * <pre>
         * Describes different target configurations for a multi-device use case.
         * A model MAY describe multiple multi-device configurations for execution.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProtoOrBuilder getConfigurationOrBuilder(
            int index);
    }
    /**
     * <pre>
     * Models
     *
     * ModelProto is a top-level file/container format for bundling a ML model and
     * associating its computation graph with metadata.
     *
     * The semantics of the model are described by the associated GraphProto's.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.ModelProto}
     */
    public static final class ModelProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.ModelProto)
        ModelProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                ModelProto.class.getName());
        }
        // Use ModelProto.newBuilder() to construct.
        private ModelProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private ModelProto() {
            opsetImport_ = java.util.Collections.emptyList();
            producerName_ = "";
            producerVersion_ = "";
            domain_ = "";
            docString_ = "";
            metadataProps_ = java.util.Collections.emptyList();
            trainingInfo_ = java.util.Collections.emptyList();
            functions_ = java.util.Collections.emptyList();
            configuration_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ProtoOnnx.internal_static_onnx_ModelProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ModelProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int IR_VERSION_FIELD_NUMBER = 1;
        private long irVersion_ = 0L;
        /**
         * <pre>
         * The version of the IR this model targets. See Version enum above.
         * This field MUST be present.
         * </pre>
         *
         * <code>optional int64 ir_version = 1;</code>
         * @return Whether the irVersion field is set.
         */
        @java.lang.Override
        public boolean hasIrVersion() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The version of the IR this model targets. See Version enum above.
         * This field MUST be present.
         * </pre>
         *
         * <code>optional int64 ir_version = 1;</code>
         * @return The irVersion.
         */
        @java.lang.Override
        public long getIrVersion() {
            return irVersion_;
        }
        
        public static final int OPSET_IMPORT_FIELD_NUMBER = 8;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto> opsetImport_;
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         *
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.OperatorSetIdProto> getOpsetImportList() {
            return opsetImport_;
        }
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         *
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder>
        getOpsetImportOrBuilderList() {
            return opsetImport_;
        }
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         *
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        @java.lang.Override
        public int getOpsetImportCount() {
            return opsetImport_.size();
        }
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         *
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto getOpsetImport(int index) {
            return opsetImport_.get(index);
        }
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         *
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        @java.lang.Override
        public ProtoOnnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
            int index) {
            return opsetImport_.get(index);
        }
        
        public static final int PRODUCER_NAME_FIELD_NUMBER = 2;
        @SuppressWarnings("serial")
        private volatile java.lang.Object producerName_ = "";
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return Whether the producerName field is set.
         */
        @java.lang.Override
        public boolean hasProducerName() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return The producerName.
         */
        @java.lang.Override
        public java.lang.String getProducerName() {
            java.lang.Object ref = producerName_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    producerName_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return The bytes for producerName.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getProducerNameBytes() {
            java.lang.Object ref = producerName_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                producerName_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int PRODUCER_VERSION_FIELD_NUMBER = 3;
        @SuppressWarnings("serial")
        private volatile java.lang.Object producerVersion_ = "";
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return Whether the producerVersion field is set.
         */
        @java.lang.Override
        public boolean hasProducerVersion() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return The producerVersion.
         */
        @java.lang.Override
        public java.lang.String getProducerVersion() {
            java.lang.Object ref = producerVersion_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    producerVersion_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return The bytes for producerVersion.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getProducerVersionBytes() {
            java.lang.Object ref = producerVersion_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                producerVersion_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int DOMAIN_FIELD_NUMBER = 4;
        @SuppressWarnings("serial")
        private volatile java.lang.Object domain_ = "";
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         *
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return Whether the domain field is set.
         */
        @java.lang.Override
        public boolean hasDomain() {
            return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         *
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return The domain.
         */
        @java.lang.Override
        public java.lang.String getDomain() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    domain_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         *
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return The bytes for domain.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDomainBytes() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                domain_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int MODEL_VERSION_FIELD_NUMBER = 5;
        private long modelVersion_ = 0L;
        /**
         * <pre>
         * The version of the graph encoded. See Version enum below.
         * </pre>
         *
         * <code>optional int64 model_version = 5;</code>
         * @return Whether the modelVersion field is set.
         */
        @java.lang.Override
        public boolean hasModelVersion() {
            return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * The version of the graph encoded. See Version enum below.
         * </pre>
         *
         * <code>optional int64 model_version = 5;</code>
         * @return The modelVersion.
         */
        @java.lang.Override
        public long getModelVersion() {
            return modelVersion_;
        }
        
        public static final int DOC_STRING_FIELD_NUMBER = 6;
        @SuppressWarnings("serial")
        private volatile java.lang.Object docString_ = "";
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int GRAPH_FIELD_NUMBER = 7;
        private org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto graph_;
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
         * @return Whether the graph field is set.
         */
        @java.lang.Override
        public boolean hasGraph() {
            return ((bitField0_ & 0x00000040) != 0);
        }
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
         * @return The graph.
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getGraph() {
            return graph_ == null ? ProtoOnnx.GraphProto.getDefaultInstance() : graph_;
        }
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder getGraphOrBuilder() {
            return graph_ == null ? ProtoOnnx.GraphProto.getDefaultInstance() : graph_;
        }
        
        public static final int METADATA_PROPS_FIELD_NUMBER = 14;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> metadataProps_;
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public int getMetadataPropsCount() {
            return metadataProps_.size();
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
            return metadataProps_.get(index);
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index) {
            return metadataProps_.get(index);
        }
        
        public static final int TRAINING_INFO_FIELD_NUMBER = 20;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto> trainingInfo_;
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         *
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.TrainingInfoProto> getTrainingInfoList() {
            return trainingInfo_;
        }
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         *
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProtoOrBuilder>
        getTrainingInfoOrBuilderList() {
            return trainingInfo_;
        }
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         *
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
         */
        @java.lang.Override
        public int getTrainingInfoCount() {
            return trainingInfo_.size();
        }
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         *
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto getTrainingInfo(int index) {
            return trainingInfo_.get(index);
        }
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         *
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(
            int index) {
            return trainingInfo_.get(index);
        }
        
        public static final int FUNCTIONS_FIELD_NUMBER = 25;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto> functions_;
        /**
         * <pre>
         * A list of function protos local to the model.
         *
         * The (domain, name, overload) tuple must be unique across the function protos in this list.
         * In case of any conflicts the behavior (whether the model local functions are given higher priority,
         * or standard operator sets are given higher priority or this is treated as error) is defined by
         * the runtimes.
         *
         * The operator sets imported by FunctionProto should be compatible with the ones
         * imported by ModelProto and other model local FunctionProtos.
         * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
         * or by 2 FunctionProtos then versions for the operator set may be different but,
         * the operator schema returned for op_type, domain, version combination
         * for both the versions should be same for every node in the function body.
         *
         * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
         * is not allowed.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.FunctionProto> getFunctionsList() {
            return functions_;
        }
        /**
         * <pre>
         * A list of function protos local to the model.
         *
         * The (domain, name, overload) tuple must be unique across the function protos in this list.
         * In case of any conflicts the behavior (whether the model local functions are given higher priority,
         * or standard operator sets are given higher priority or this is treated as error) is defined by
         * the runtimes.
         *
         * The operator sets imported by FunctionProto should be compatible with the ones
         * imported by ModelProto and other model local FunctionProtos.
         * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
         * or by 2 FunctionProtos then versions for the operator set may be different but,
         * the operator schema returned for op_type, domain, version combination
         * for both the versions should be same for every node in the function body.
         *
         * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
         * is not allowed.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProtoOrBuilder>
        getFunctionsOrBuilderList() {
            return functions_;
        }
        /**
         * <pre>
         * A list of function protos local to the model.
         *
         * The (domain, name, overload) tuple must be unique across the function protos in this list.
         * In case of any conflicts the behavior (whether the model local functions are given higher priority,
         * or standard operator sets are given higher priority or this is treated as error) is defined by
         * the runtimes.
         *
         * The operator sets imported by FunctionProto should be compatible with the ones
         * imported by ModelProto and other model local FunctionProtos.
         * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
         * or by 2 FunctionProtos then versions for the operator set may be different but,
         * the operator schema returned for op_type, domain, version combination
         * for both the versions should be same for every node in the function body.
         *
         * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
         * is not allowed.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
         */
        @java.lang.Override
        public int getFunctionsCount() {
            return functions_.size();
        }
        /**
         * <pre>
         * A list of function protos local to the model.
         *
         * The (domain, name, overload) tuple must be unique across the function protos in this list.
         * In case of any conflicts the behavior (whether the model local functions are given higher priority,
         * or standard operator sets are given higher priority or this is treated as error) is defined by
         * the runtimes.
         *
         * The operator sets imported by FunctionProto should be compatible with the ones
         * imported by ModelProto and other model local FunctionProtos.
         * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
         * or by 2 FunctionProtos then versions for the operator set may be different but,
         * the operator schema returned for op_type, domain, version combination
         * for both the versions should be same for every node in the function body.
         *
         * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
         * is not allowed.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto getFunctions(int index) {
            return functions_.get(index);
        }
        /**
         * <pre>
         * A list of function protos local to the model.
         *
         * The (domain, name, overload) tuple must be unique across the function protos in this list.
         * In case of any conflicts the behavior (whether the model local functions are given higher priority,
         * or standard operator sets are given higher priority or this is treated as error) is defined by
         * the runtimes.
         *
         * The operator sets imported by FunctionProto should be compatible with the ones
         * imported by ModelProto and other model local FunctionProtos.
         * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
         * or by 2 FunctionProtos then versions for the operator set may be different but,
         * the operator schema returned for op_type, domain, version combination
         * for both the versions should be same for every node in the function body.
         *
         * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
         * is not allowed.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProtoOrBuilder getFunctionsOrBuilder(
            int index) {
            return functions_.get(index);
        }
        
        public static final int CONFIGURATION_FIELD_NUMBER = 26;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto> configuration_;
        /**
         * <pre>
         * Describes different target configurations for a multi-device use case.
         * A model MAY describe multiple multi-device configurations for execution.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto> getConfigurationList() {
            return configuration_;
        }
        /**
         * <pre>
         * Describes different target configurations for a multi-device use case.
         * A model MAY describe multiple multi-device configurations for execution.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ProtoOnnx.DeviceConfigurationProtoOrBuilder>
        getConfigurationOrBuilderList() {
            return configuration_;
        }
        /**
         * <pre>
         * Describes different target configurations for a multi-device use case.
         * A model MAY describe multiple multi-device configurations for execution.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
         */
        @java.lang.Override
        public int getConfigurationCount() {
            return configuration_.size();
        }
        /**
         * <pre>
         * Describes different target configurations for a multi-device use case.
         * A model MAY describe multiple multi-device configurations for execution.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto getConfiguration(int index) {
            return configuration_.get(index);
        }
        /**
         * <pre>
         * Describes different target configurations for a multi-device use case.
         * A model MAY describe multiple multi-device configurations for execution.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProtoOrBuilder getConfigurationOrBuilder(
            int index) {
            return configuration_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeInt64(1, irVersion_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 2, producerName_);
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 3, producerVersion_);
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 4, domain_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                output.writeInt64(5, modelVersion_);
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 6, docString_);
            }
            if (((bitField0_ & 0x00000040) != 0)) {
                output.writeMessage(7, getGraph());
            }
            for (int i = 0; i < opsetImport_.size(); i++) {
                output.writeMessage(8, opsetImport_.get(i));
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                output.writeMessage(14, metadataProps_.get(i));
            }
            for (int i = 0; i < trainingInfo_.size(); i++) {
                output.writeMessage(20, trainingInfo_.get(i));
            }
            for (int i = 0; i < functions_.size(); i++) {
                output.writeMessage(25, functions_.get(i));
            }
            for (int i = 0; i < configuration_.size(); i++) {
                output.writeMessage(26, configuration_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt64Size(1, irVersion_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(2, producerName_);
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(3, producerVersion_);
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(4, domain_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt64Size(5, modelVersion_);
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(6, docString_);
            }
            if (((bitField0_ & 0x00000040) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(7, getGraph());
            }
            for (int i = 0; i < opsetImport_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(8, opsetImport_.get(i));
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(14, metadataProps_.get(i));
            }
            for (int i = 0; i < trainingInfo_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(20, trainingInfo_.get(i));
            }
            for (int i = 0; i < functions_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(25, functions_.get(i));
            }
            for (int i = 0; i < configuration_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(26, configuration_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto) obj;
            
            if (hasIrVersion() != other.hasIrVersion()) return false;
            if (hasIrVersion()) {
                if (getIrVersion()
                    != other.getIrVersion()) return false;
            }
            if (!getOpsetImportList()
                .equals(other.getOpsetImportList())) return false;
            if (hasProducerName() != other.hasProducerName()) return false;
            if (hasProducerName()) {
                if (!getProducerName()
                    .equals(other.getProducerName())) return false;
            }
            if (hasProducerVersion() != other.hasProducerVersion()) return false;
            if (hasProducerVersion()) {
                if (!getProducerVersion()
                    .equals(other.getProducerVersion())) return false;
            }
            if (hasDomain() != other.hasDomain()) return false;
            if (hasDomain()) {
                if (!getDomain()
                    .equals(other.getDomain())) return false;
            }
            if (hasModelVersion() != other.hasModelVersion()) return false;
            if (hasModelVersion()) {
                if (getModelVersion()
                    != other.getModelVersion()) return false;
            }
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                    .equals(other.getDocString())) return false;
            }
            if (hasGraph() != other.hasGraph()) return false;
            if (hasGraph()) {
                if (!getGraph()
                    .equals(other.getGraph())) return false;
            }
            if (!getMetadataPropsList()
                .equals(other.getMetadataPropsList())) return false;
            if (!getTrainingInfoList()
                .equals(other.getTrainingInfoList())) return false;
            if (!getFunctionsList()
                .equals(other.getFunctionsList())) return false;
            if (!getConfigurationList()
                .equals(other.getConfigurationList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasIrVersion()) {
                hash = (37 * hash) + IR_VERSION_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                    getIrVersion());
            }
            if (getOpsetImportCount() > 0) {
                hash = (37 * hash) + OPSET_IMPORT_FIELD_NUMBER;
                hash = (53 * hash) + getOpsetImportList().hashCode();
            }
            if (hasProducerName()) {
                hash = (37 * hash) + PRODUCER_NAME_FIELD_NUMBER;
                hash = (53 * hash) + getProducerName().hashCode();
            }
            if (hasProducerVersion()) {
                hash = (37 * hash) + PRODUCER_VERSION_FIELD_NUMBER;
                hash = (53 * hash) + getProducerVersion().hashCode();
            }
            if (hasDomain()) {
                hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
                hash = (53 * hash) + getDomain().hashCode();
            }
            if (hasModelVersion()) {
                hash = (37 * hash) + MODEL_VERSION_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                    getModelVersion());
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (hasGraph()) {
                hash = (37 * hash) + GRAPH_FIELD_NUMBER;
                hash = (53 * hash) + getGraph().hashCode();
            }
            if (getMetadataPropsCount() > 0) {
                hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
                hash = (53 * hash) + getMetadataPropsList().hashCode();
            }
            if (getTrainingInfoCount() > 0) {
                hash = (37 * hash) + TRAINING_INFO_FIELD_NUMBER;
                hash = (53 * hash) + getTrainingInfoList().hashCode();
            }
            if (getFunctionsCount() > 0) {
                hash = (37 * hash) + FUNCTIONS_FIELD_NUMBER;
                hash = (53 * hash) + getFunctionsList().hashCode();
            }
            if (getConfigurationCount() > 0) {
                hash = (37 * hash) + CONFIGURATION_FIELD_NUMBER;
                hash = (53 * hash) + getConfigurationList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.ModelProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static ProtoOnnx.ModelProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Models
         *
         * ModelProto is a top-level file/container format for bundling a ML model and
         * associating its computation graph with metadata.
         *
         * The semantics of the model are described by the associated GraphProto's.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.ModelProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.ModelProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.ModelProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ModelProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ModelProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessage
                    .alwaysUseFieldBuilders) {
                    internalGetOpsetImportFieldBuilder();
                    internalGetGraphFieldBuilder();
                    internalGetMetadataPropsFieldBuilder();
                    internalGetTrainingInfoFieldBuilder();
                    internalGetFunctionsFieldBuilder();
                    internalGetConfigurationFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                irVersion_ = 0L;
                if (opsetImportBuilder_ == null) {
                    opsetImport_ = java.util.Collections.emptyList();
                } else {
                    opsetImport_ = null;
                    opsetImportBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000002);
                producerName_ = "";
                producerVersion_ = "";
                domain_ = "";
                modelVersion_ = 0L;
                docString_ = "";
                graph_ = null;
                if (graphBuilder_ != null) {
                    graphBuilder_.dispose();
                    graphBuilder_ = null;
                }
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                } else {
                    metadataProps_ = null;
                    metadataPropsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000100);
                if (trainingInfoBuilder_ == null) {
                    trainingInfo_ = java.util.Collections.emptyList();
                } else {
                    trainingInfo_ = null;
                    trainingInfoBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000200);
                if (functionsBuilder_ == null) {
                    functions_ = java.util.Collections.emptyList();
                } else {
                    functions_ = null;
                    functionsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000400);
                if (configurationBuilder_ == null) {
                    configuration_ = java.util.Collections.emptyList();
                } else {
                    configuration_ = null;
                    configurationBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000800);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_ModelProto_descriptor;
            }
            
            @java.lang.Override
            public ProtoOnnx.ModelProto getDefaultInstanceForType() {
                return ProtoOnnx.ModelProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public ProtoOnnx.ModelProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto result) {
                if (opsetImportBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0)) {
                        opsetImport_ = java.util.Collections.unmodifiableList(opsetImport_);
                        bitField0_ = (bitField0_ & ~0x00000002);
                    }
                    result.opsetImport_ = opsetImport_;
                } else {
                    result.opsetImport_ = opsetImportBuilder_.build();
                }
                if (metadataPropsBuilder_ == null) {
                    if (((bitField0_ & 0x00000100) != 0)) {
                        metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
                        bitField0_ = (bitField0_ & ~0x00000100);
                    }
                    result.metadataProps_ = metadataProps_;
                } else {
                    result.metadataProps_ = metadataPropsBuilder_.build();
                }
                if (trainingInfoBuilder_ == null) {
                    if (((bitField0_ & 0x00000200) != 0)) {
                        trainingInfo_ = java.util.Collections.unmodifiableList(trainingInfo_);
                        bitField0_ = (bitField0_ & ~0x00000200);
                    }
                    result.trainingInfo_ = trainingInfo_;
                } else {
                    result.trainingInfo_ = trainingInfoBuilder_.build();
                }
                if (functionsBuilder_ == null) {
                    if (((bitField0_ & 0x00000400) != 0)) {
                        functions_ = java.util.Collections.unmodifiableList(functions_);
                        bitField0_ = (bitField0_ & ~0x00000400);
                    }
                    result.functions_ = functions_;
                } else {
                    result.functions_ = functionsBuilder_.build();
                }
                if (configurationBuilder_ == null) {
                    if (((bitField0_ & 0x00000800) != 0)) {
                        configuration_ = java.util.Collections.unmodifiableList(configuration_);
                        bitField0_ = (bitField0_ & ~0x00000800);
                    }
                    result.configuration_ = configuration_;
                } else {
                    result.configuration_ = configurationBuilder_.build();
                }
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.irVersion_ = irVersion_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    result.producerName_ = producerName_;
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000008) != 0)) {
                    result.producerVersion_ = producerVersion_;
                    to_bitField0_ |= 0x00000004;
                }
                if (((from_bitField0_ & 0x00000010) != 0)) {
                    result.domain_ = domain_;
                    to_bitField0_ |= 0x00000008;
                }
                if (((from_bitField0_ & 0x00000020) != 0)) {
                    result.modelVersion_ = modelVersion_;
                    to_bitField0_ |= 0x00000010;
                }
                if (((from_bitField0_ & 0x00000040) != 0)) {
                    result.docString_ = docString_;
                    to_bitField0_ |= 0x00000020;
                }
                if (((from_bitField0_ & 0x00000080) != 0)) {
                    result.graph_ = graphBuilder_ == null
                        ? graph_
                        : graphBuilder_.build();
                    to_bitField0_ |= 0x00000040;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto.getDefaultInstance()) return this;
                if (other.hasIrVersion()) {
                    setIrVersion(other.getIrVersion());
                }
                if (opsetImportBuilder_ == null) {
                    if (!other.opsetImport_.isEmpty()) {
                        if (opsetImport_.isEmpty()) {
                            opsetImport_ = other.opsetImport_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                        } else {
                            ensureOpsetImportIsMutable();
                            opsetImport_.addAll(other.opsetImport_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.opsetImport_.isEmpty()) {
                        if (opsetImportBuilder_.isEmpty()) {
                            opsetImportBuilder_.dispose();
                            opsetImportBuilder_ = null;
                            opsetImport_ = other.opsetImport_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                            opsetImportBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetOpsetImportFieldBuilder() : null;
                        } else {
                            opsetImportBuilder_.addAllMessages(other.opsetImport_);
                        }
                    }
                }
                if (other.hasProducerName()) {
                    producerName_ = other.producerName_;
                    bitField0_ |= 0x00000004;
                    onChanged();
                }
                if (other.hasProducerVersion()) {
                    producerVersion_ = other.producerVersion_;
                    bitField0_ |= 0x00000008;
                    onChanged();
                }
                if (other.hasDomain()) {
                    domain_ = other.domain_;
                    bitField0_ |= 0x00000010;
                    onChanged();
                }
                if (other.hasModelVersion()) {
                    setModelVersion(other.getModelVersion());
                }
                if (other.hasDocString()) {
                    docString_ = other.docString_;
                    bitField0_ |= 0x00000040;
                    onChanged();
                }
                if (other.hasGraph()) {
                    mergeGraph(other.getGraph());
                }
                if (metadataPropsBuilder_ == null) {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataProps_.isEmpty()) {
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000100);
                        } else {
                            ensureMetadataPropsIsMutable();
                            metadataProps_.addAll(other.metadataProps_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataPropsBuilder_.isEmpty()) {
                            metadataPropsBuilder_.dispose();
                            metadataPropsBuilder_ = null;
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000100);
                            metadataPropsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetMetadataPropsFieldBuilder() : null;
                        } else {
                            metadataPropsBuilder_.addAllMessages(other.metadataProps_);
                        }
                    }
                }
                if (trainingInfoBuilder_ == null) {
                    if (!other.trainingInfo_.isEmpty()) {
                        if (trainingInfo_.isEmpty()) {
                            trainingInfo_ = other.trainingInfo_;
                            bitField0_ = (bitField0_ & ~0x00000200);
                        } else {
                            ensureTrainingInfoIsMutable();
                            trainingInfo_.addAll(other.trainingInfo_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.trainingInfo_.isEmpty()) {
                        if (trainingInfoBuilder_.isEmpty()) {
                            trainingInfoBuilder_.dispose();
                            trainingInfoBuilder_ = null;
                            trainingInfo_ = other.trainingInfo_;
                            bitField0_ = (bitField0_ & ~0x00000200);
                            trainingInfoBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetTrainingInfoFieldBuilder() : null;
                        } else {
                            trainingInfoBuilder_.addAllMessages(other.trainingInfo_);
                        }
                    }
                }
                if (functionsBuilder_ == null) {
                    if (!other.functions_.isEmpty()) {
                        if (functions_.isEmpty()) {
                            functions_ = other.functions_;
                            bitField0_ = (bitField0_ & ~0x00000400);
                        } else {
                            ensureFunctionsIsMutable();
                            functions_.addAll(other.functions_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.functions_.isEmpty()) {
                        if (functionsBuilder_.isEmpty()) {
                            functionsBuilder_.dispose();
                            functionsBuilder_ = null;
                            functions_ = other.functions_;
                            bitField0_ = (bitField0_ & ~0x00000400);
                            functionsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetFunctionsFieldBuilder() : null;
                        } else {
                            functionsBuilder_.addAllMessages(other.functions_);
                        }
                    }
                }
                if (configurationBuilder_ == null) {
                    if (!other.configuration_.isEmpty()) {
                        if (configuration_.isEmpty()) {
                            configuration_ = other.configuration_;
                            bitField0_ = (bitField0_ & ~0x00000800);
                        } else {
                            ensureConfigurationIsMutable();
                            configuration_.addAll(other.configuration_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.configuration_.isEmpty()) {
                        if (configurationBuilder_.isEmpty()) {
                            configurationBuilder_.dispose();
                            configurationBuilder_ = null;
                            configuration_ = other.configuration_;
                            bitField0_ = (bitField0_ & ~0x00000800);
                            configurationBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetConfigurationFieldBuilder() : null;
                        } else {
                            configurationBuilder_.addAllMessages(other.configuration_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 8: {
                                irVersion_ = input.readInt64();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 8
                            case 18: {
                                producerName_ = input.readBytes();
                                bitField0_ |= 0x00000004;
                                break;
                            } // case 18
                            case 26: {
                                producerVersion_ = input.readBytes();
                                bitField0_ |= 0x00000008;
                                break;
                            } // case 26
                            case 34: {
                                domain_ = input.readBytes();
                                bitField0_ |= 0x00000010;
                                break;
                            } // case 34
                            case 40: {
                                modelVersion_ = input.readInt64();
                                bitField0_ |= 0x00000020;
                                break;
                            } // case 40
                            case 50: {
                                docString_ = input.readBytes();
                                bitField0_ |= 0x00000040;
                                break;
                            } // case 50
                            case 58: {
                                input.readMessage(
                                    internalGetGraphFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000080;
                                break;
                            } // case 58
                            case 66: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.parser(),
                                        extensionRegistry);
                                if (opsetImportBuilder_ == null) {
                                    ensureOpsetImportIsMutable();
                                    opsetImport_.add(m);
                                } else {
                                    opsetImportBuilder_.addMessage(m);
                                }
                                break;
                            } // case 66
                            case 114: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.parser(),
                                        extensionRegistry);
                                if (metadataPropsBuilder_ == null) {
                                    ensureMetadataPropsIsMutable();
                                    metadataProps_.add(m);
                                } else {
                                    metadataPropsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 114
                            case 162: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.parser(),
                                        extensionRegistry);
                                if (trainingInfoBuilder_ == null) {
                                    ensureTrainingInfoIsMutable();
                                    trainingInfo_.add(m);
                                } else {
                                    trainingInfoBuilder_.addMessage(m);
                                }
                                break;
                            } // case 162
                            case 202: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto m =
                                    input.readMessage(
                                        ProtoOnnx.FunctionProto.parser(),
                                        extensionRegistry);
                                if (functionsBuilder_ == null) {
                                    ensureFunctionsIsMutable();
                                    functions_.add(m);
                                } else {
                                    functionsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 202
                            case 210: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto m =
                                    input.readMessage(
                                        ProtoOnnx.DeviceConfigurationProto.parser(),
                                        extensionRegistry);
                                if (configurationBuilder_ == null) {
                                    ensureConfigurationIsMutable();
                                    configuration_.add(m);
                                } else {
                                    configurationBuilder_.addMessage(m);
                                }
                                break;
                            } // case 210
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private long irVersion_ ;
            /**
             * <pre>
             * The version of the IR this model targets. See Version enum above.
             * This field MUST be present.
             * </pre>
             *
             * <code>optional int64 ir_version = 1;</code>
             * @return Whether the irVersion field is set.
             */
            @java.lang.Override
            public boolean hasIrVersion() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The version of the IR this model targets. See Version enum above.
             * This field MUST be present.
             * </pre>
             *
             * <code>optional int64 ir_version = 1;</code>
             * @return The irVersion.
             */
            @java.lang.Override
            public long getIrVersion() {
                return irVersion_;
            }
            /**
             * <pre>
             * The version of the IR this model targets. See Version enum above.
             * This field MUST be present.
             * </pre>
             *
             * <code>optional int64 ir_version = 1;</code>
             * @param value The irVersion to set.
             * @return This builder for chaining.
             */
            public Builder setIrVersion(long value) {
                
                irVersion_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The version of the IR this model targets. See Version enum above.
             * This field MUST be present.
             * </pre>
             *
             * <code>optional int64 ir_version = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearIrVersion() {
                bitField0_ = (bitField0_ & ~0x00000001);
                irVersion_ = 0L;
                onChanged();
                return this;
            }
            
            private java.util.List<ProtoOnnx.OperatorSetIdProto> opsetImport_ =
                java.util.Collections.emptyList();
            private void ensureOpsetImportIsMutable() {
                if (!((bitField0_ & 0x00000002) != 0)) {
                    opsetImport_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto>(opsetImport_);
                    bitField0_ |= 0x00000002;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.OperatorSetIdProto, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder> opsetImportBuilder_;
            
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto> getOpsetImportList() {
                if (opsetImportBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(opsetImport_);
                } else {
                    return opsetImportBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public int getOpsetImportCount() {
                if (opsetImportBuilder_ == null) {
                    return opsetImport_.size();
                } else {
                    return opsetImportBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto getOpsetImport(int index) {
                if (opsetImportBuilder_ == null) {
                    return opsetImport_.get(index);
                } else {
                    return opsetImportBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder setOpsetImport(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto value) {
                if (opsetImportBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOpsetImportIsMutable();
                    opsetImport_.set(index, value);
                    onChanged();
                } else {
                    opsetImportBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder setOpsetImport(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder builderForValue) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    opsetImportBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder addOpsetImport(org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto value) {
                if (opsetImportBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(value);
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder addOpsetImport(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto value) {
                if (opsetImportBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(index, value);
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder addOpsetImport(
                org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder builderForValue) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(builderForValue.build());
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder addOpsetImport(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder builderForValue) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder addAllOpsetImport(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto> values) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, opsetImport_);
                    onChanged();
                } else {
                    opsetImportBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder clearOpsetImport() {
                if (opsetImportBuilder_ == null) {
                    opsetImport_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000002);
                    onChanged();
                } else {
                    opsetImportBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder removeOpsetImport(int index) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.remove(index);
                    onChanged();
                } else {
                    opsetImportBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder getOpsetImportBuilder(
                int index) {
                return internalGetOpsetImportFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public ProtoOnnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
                int index) {
                if (opsetImportBuilder_ == null) {
                    return opsetImport_.get(index);  } else {
                    return opsetImportBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder>
            getOpsetImportOrBuilderList() {
                if (opsetImportBuilder_ != null) {
                    return opsetImportBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(opsetImport_);
                }
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder addOpsetImportBuilder() {
                return internalGetOpsetImportFieldBuilder().addBuilder(
                    ProtoOnnx.OperatorSetIdProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder addOpsetImportBuilder(
                int index) {
                return internalGetOpsetImportFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             *
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder>
            getOpsetImportBuilderList() {
                return internalGetOpsetImportFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder>
            internalGetOpsetImportFieldBuilder() {
                if (opsetImportBuilder_ == null) {
                    opsetImportBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder>(
                        opsetImport_,
                        ((bitField0_ & 0x00000002) != 0),
                        getParentForChildren(),
                        isClean());
                    opsetImport_ = null;
                }
                return opsetImportBuilder_;
            }
            
            private java.lang.Object producerName_ = "";
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @return Whether the producerName field is set.
             */
            public boolean hasProducerName() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @return The producerName.
             */
            public java.lang.String getProducerName() {
                java.lang.Object ref = producerName_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        producerName_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @return The bytes for producerName.
             */
            public com.google.protobuf.ByteString
            getProducerNameBytes() {
                java.lang.Object ref = producerName_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    producerName_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @param value The producerName to set.
             * @return This builder for chaining.
             */
            public Builder setProducerName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                producerName_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearProducerName() {
                producerName_ = getDefaultInstance().getProducerName();
                bitField0_ = (bitField0_ & ~0x00000004);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @param value The bytes for producerName to set.
             * @return This builder for chaining.
             */
            public Builder setProducerNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                producerName_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            
            private java.lang.Object producerVersion_ = "";
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @return Whether the producerVersion field is set.
             */
            public boolean hasProducerVersion() {
                return ((bitField0_ & 0x00000008) != 0);
            }
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @return The producerVersion.
             */
            public java.lang.String getProducerVersion() {
                java.lang.Object ref = producerVersion_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        producerVersion_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @return The bytes for producerVersion.
             */
            public com.google.protobuf.ByteString
            getProducerVersionBytes() {
                java.lang.Object ref = producerVersion_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    producerVersion_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @param value The producerVersion to set.
             * @return This builder for chaining.
             */
            public Builder setProducerVersion(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                producerVersion_ = value;
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearProducerVersion() {
                producerVersion_ = getDefaultInstance().getProducerVersion();
                bitField0_ = (bitField0_ & ~0x00000008);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @param value The bytes for producerVersion to set.
             * @return This builder for chaining.
             */
            public Builder setProducerVersionBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                producerVersion_ = value;
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            
            private java.lang.Object domain_ = "";
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             *
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @return Whether the domain field is set.
             */
            public boolean hasDomain() {
                return ((bitField0_ & 0x00000010) != 0);
            }
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             *
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @return The domain.
             */
            public java.lang.String getDomain() {
                java.lang.Object ref = domain_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        domain_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             *
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @return The bytes for domain.
             */
            public com.google.protobuf.ByteString
            getDomainBytes() {
                java.lang.Object ref = domain_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    domain_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             *
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @param value The domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomain(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                domain_ = value;
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             *
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @return This builder for chaining.
             */
            public Builder clearDomain() {
                domain_ = getDefaultInstance().getDomain();
                bitField0_ = (bitField0_ & ~0x00000010);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             *
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @param value The bytes for domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomainBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                domain_ = value;
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }
            
            private long modelVersion_ ;
            /**
             * <pre>
             * The version of the graph encoded. See Version enum below.
             * </pre>
             *
             * <code>optional int64 model_version = 5;</code>
             * @return Whether the modelVersion field is set.
             */
            @java.lang.Override
            public boolean hasModelVersion() {
                return ((bitField0_ & 0x00000020) != 0);
            }
            /**
             * <pre>
             * The version of the graph encoded. See Version enum below.
             * </pre>
             *
             * <code>optional int64 model_version = 5;</code>
             * @return The modelVersion.
             */
            @java.lang.Override
            public long getModelVersion() {
                return modelVersion_;
            }
            /**
             * <pre>
             * The version of the graph encoded. See Version enum below.
             * </pre>
             *
             * <code>optional int64 model_version = 5;</code>
             * @param value The modelVersion to set.
             * @return This builder for chaining.
             */
            public Builder setModelVersion(long value) {
                
                modelVersion_ = value;
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The version of the graph encoded. See Version enum below.
             * </pre>
             *
             * <code>optional int64 model_version = 5;</code>
             * @return This builder for chaining.
             */
            public Builder clearModelVersion() {
                bitField0_ = (bitField0_ & ~0x00000020);
                modelVersion_ = 0L;
                onChanged();
                return this;
            }
            
            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000040) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000040;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                docString_ = getDefaultInstance().getDocString();
                bitField0_ = (bitField0_ & ~0x00000040);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000040;
                onChanged();
                return this;
            }
            
            private org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto graph_;
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto, ProtoOnnx.GraphProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder> graphBuilder_;
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
             * @return Whether the graph field is set.
             */
            public boolean hasGraph() {
                return ((bitField0_ & 0x00000080) != 0);
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
             * @return The graph.
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getGraph() {
                if (graphBuilder_ == null) {
                    return graph_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance() : graph_;
                } else {
                    return graphBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
             */
            public Builder setGraph(org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto value) {
                if (graphBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    graph_ = value;
                } else {
                    graphBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000080;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
             */
            public Builder setGraph(
                org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder builderForValue) {
                if (graphBuilder_ == null) {
                    graph_ = builderForValue.build();
                } else {
                    graphBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000080;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
             */
            public Builder mergeGraph(org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto value) {
                if (graphBuilder_ == null) {
                    if (((bitField0_ & 0x00000080) != 0) &&
                        graph_ != null &&
                        graph_ != ProtoOnnx.GraphProto.getDefaultInstance()) {
                        getGraphBuilder().mergeFrom(value);
                    } else {
                        graph_ = value;
                    }
                } else {
                    graphBuilder_.mergeFrom(value);
                }
                if (graph_ != null) {
                    bitField0_ |= 0x00000080;
                    onChanged();
                }
                return this;
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
             */
            public Builder clearGraph() {
                bitField0_ = (bitField0_ & ~0x00000080);
                graph_ = null;
                if (graphBuilder_ != null) {
                    graphBuilder_.dispose();
                    graphBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder getGraphBuilder() {
                bitField0_ |= 0x00000080;
                onChanged();
                return internalGetGraphFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder getGraphOrBuilder() {
                if (graphBuilder_ != null) {
                    return graphBuilder_.getMessageOrBuilder();
                } else {
                    return graph_ == null ?
                        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance() : graph_;
                }
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.GraphProto graph = 7;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder>
            internalGetGraphFieldBuilder() {
                if (graphBuilder_ == null) {
                    graphBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder>(
                        getGraph(),
                        getParentForChildren(),
                        isClean());
                    graph_ = null;
                }
                return graphBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> metadataProps_ =
                java.util.Collections.emptyList();
            private void ensureMetadataPropsIsMutable() {
                if (!((bitField0_ & 0x00000100) != 0)) {
                    metadataProps_ = new java.util.ArrayList<ProtoOnnx.StringStringEntryProto>(metadataProps_);
                    bitField0_ |= 0x00000100;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, ProtoOnnx.StringStringEntryProto.Builder, ProtoOnnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;
            
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
                if (metadataPropsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                } else {
                    return metadataPropsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public int getMetadataPropsCount() {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.size();
                } else {
                    return metadataPropsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);
                } else {
                    return metadataPropsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder setMetadataProps(
                int index, ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder setMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(
                int index, ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addAllMetadataProps(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> values) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, metadataProps_);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder clearMetadataProps() {
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000100);
                    onChanged();
                } else {
                    metadataPropsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder removeMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.remove(index);
                    onChanged();
                } else {
                    metadataPropsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
                int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);  } else {
                    return metadataPropsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public java.util.List<? extends ProtoOnnx.StringStringEntryProtoOrBuilder>
            getMetadataPropsOrBuilderList() {
                if (metadataPropsBuilder_ != null) {
                    return metadataPropsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder>
            getMetadataPropsBuilderList() {
                return internalGetMetadataPropsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            internalGetMetadataPropsFieldBuilder() {
                if (metadataPropsBuilder_ == null) {
                    metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>(
                        metadataProps_,
                        ((bitField0_ & 0x00000100) != 0),
                        getParentForChildren(),
                        isClean());
                    metadataProps_ = null;
                }
                return metadataPropsBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto> trainingInfo_ =
                java.util.Collections.emptyList();
            private void ensureTrainingInfoIsMutable() {
                if (!((bitField0_ & 0x00000200) != 0)) {
                    trainingInfo_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto>(trainingInfo_);
                    bitField0_ |= 0x00000200;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProtoOrBuilder> trainingInfoBuilder_;
            
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto> getTrainingInfoList() {
                if (trainingInfoBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(trainingInfo_);
                } else {
                    return trainingInfoBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public int getTrainingInfoCount() {
                if (trainingInfoBuilder_ == null) {
                    return trainingInfo_.size();
                } else {
                    return trainingInfoBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto getTrainingInfo(int index) {
                if (trainingInfoBuilder_ == null) {
                    return trainingInfo_.get(index);
                } else {
                    return trainingInfoBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder setTrainingInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto value) {
                if (trainingInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.set(index, value);
                    onChanged();
                } else {
                    trainingInfoBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder setTrainingInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.Builder builderForValue) {
                if (trainingInfoBuilder_ == null) {
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    trainingInfoBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder addTrainingInfo(org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto value) {
                if (trainingInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.add(value);
                    onChanged();
                } else {
                    trainingInfoBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder addTrainingInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto value) {
                if (trainingInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.add(index, value);
                    onChanged();
                } else {
                    trainingInfoBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder addTrainingInfo(
                ProtoOnnx.TrainingInfoProto.Builder builderForValue) {
                if (trainingInfoBuilder_ == null) {
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.add(builderForValue.build());
                    onChanged();
                } else {
                    trainingInfoBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder addTrainingInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.Builder builderForValue) {
                if (trainingInfoBuilder_ == null) {
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    trainingInfoBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder addAllTrainingInfo(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto> values) {
                if (trainingInfoBuilder_ == null) {
                    ensureTrainingInfoIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, trainingInfo_);
                    onChanged();
                } else {
                    trainingInfoBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder clearTrainingInfo() {
                if (trainingInfoBuilder_ == null) {
                    trainingInfo_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000200);
                    onChanged();
                } else {
                    trainingInfoBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder removeTrainingInfo(int index) {
                if (trainingInfoBuilder_ == null) {
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.remove(index);
                    onChanged();
                } else {
                    trainingInfoBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.Builder getTrainingInfoBuilder(
                int index) {
                return internalGetTrainingInfoFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(
                int index) {
                if (trainingInfoBuilder_ == null) {
                    return trainingInfo_.get(index);  } else {
                    return trainingInfoBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public java.util.List<? extends ProtoOnnx.TrainingInfoProtoOrBuilder>
            getTrainingInfoOrBuilderList() {
                if (trainingInfoBuilder_ != null) {
                    return trainingInfoBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(trainingInfo_);
                }
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.Builder addTrainingInfoBuilder() {
                return internalGetTrainingInfoFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.Builder addTrainingInfoBuilder(
                int index) {
                return internalGetTrainingInfoFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             *
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TrainingInfoProto training_info = 20;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.Builder>
            getTrainingInfoBuilderList() {
                return internalGetTrainingInfoFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProtoOrBuilder>
            internalGetTrainingInfoFieldBuilder() {
                if (trainingInfoBuilder_ == null) {
                    trainingInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TrainingInfoProtoOrBuilder>(
                        trainingInfo_,
                        ((bitField0_ & 0x00000200) != 0),
                        getParentForChildren(),
                        isClean());
                    trainingInfo_ = null;
                }
                return trainingInfoBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto> functions_ =
                java.util.Collections.emptyList();
            private void ensureFunctionsIsMutable() {
                if (!((bitField0_ & 0x00000400) != 0)) {
                    functions_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto>(functions_);
                    bitField0_ |= 0x00000400;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProtoOrBuilder> functionsBuilder_;
            
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto> getFunctionsList() {
                if (functionsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(functions_);
                } else {
                    return functionsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public int getFunctionsCount() {
                if (functionsBuilder_ == null) {
                    return functions_.size();
                } else {
                    return functionsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto getFunctions(int index) {
                if (functionsBuilder_ == null) {
                    return functions_.get(index);
                } else {
                    return functionsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public Builder setFunctions(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto value) {
                if (functionsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureFunctionsIsMutable();
                    functions_.set(index, value);
                    onChanged();
                } else {
                    functionsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public Builder setFunctions(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.Builder builderForValue) {
                if (functionsBuilder_ == null) {
                    ensureFunctionsIsMutable();
                    functions_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    functionsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public Builder addFunctions(ProtoOnnx.FunctionProto value) {
                if (functionsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureFunctionsIsMutable();
                    functions_.add(value);
                    onChanged();
                } else {
                    functionsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public Builder addFunctions(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto value) {
                if (functionsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureFunctionsIsMutable();
                    functions_.add(index, value);
                    onChanged();
                } else {
                    functionsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public Builder addFunctions(
                org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.Builder builderForValue) {
                if (functionsBuilder_ == null) {
                    ensureFunctionsIsMutable();
                    functions_.add(builderForValue.build());
                    onChanged();
                } else {
                    functionsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public Builder addFunctions(
                int index, ProtoOnnx.FunctionProto.Builder builderForValue) {
                if (functionsBuilder_ == null) {
                    ensureFunctionsIsMutable();
                    functions_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    functionsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public Builder addAllFunctions(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto> values) {
                if (functionsBuilder_ == null) {
                    ensureFunctionsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, functions_);
                    onChanged();
                } else {
                    functionsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public Builder clearFunctions() {
                if (functionsBuilder_ == null) {
                    functions_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000400);
                    onChanged();
                } else {
                    functionsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public Builder removeFunctions(int index) {
                if (functionsBuilder_ == null) {
                    ensureFunctionsIsMutable();
                    functions_.remove(index);
                    onChanged();
                } else {
                    functionsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.Builder getFunctionsBuilder(
                int index) {
                return internalGetFunctionsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProtoOrBuilder getFunctionsOrBuilder(
                int index) {
                if (functionsBuilder_ == null) {
                    return functions_.get(index);  } else {
                    return functionsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProtoOrBuilder>
            getFunctionsOrBuilderList() {
                if (functionsBuilder_ != null) {
                    return functionsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(functions_);
                }
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public ProtoOnnx.FunctionProto.Builder addFunctionsBuilder() {
                return internalGetFunctionsFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.getDefaultInstance());
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public ProtoOnnx.FunctionProto.Builder addFunctionsBuilder(
                int index) {
                return internalGetFunctionsFieldBuilder().addBuilder(
                    index, ProtoOnnx.FunctionProto.getDefaultInstance());
            }
            /**
             * <pre>
             * A list of function protos local to the model.
             *
             * The (domain, name, overload) tuple must be unique across the function protos in this list.
             * In case of any conflicts the behavior (whether the model local functions are given higher priority,
             * or standard operator sets are given higher priority or this is treated as error) is defined by
             * the runtimes.
             *
             * The operator sets imported by FunctionProto should be compatible with the ones
             * imported by ModelProto and other model local FunctionProtos.
             * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
             * or by 2 FunctionProtos then versions for the operator set may be different but,
             * the operator schema returned for op_type, domain, version combination
             * for both the versions should be same for every node in the function body.
             *
             * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
             * is not allowed.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.FunctionProto functions = 25;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.Builder>
            getFunctionsBuilderList() {
                return internalGetFunctionsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProtoOrBuilder>
            internalGetFunctionsFieldBuilder() {
                if (functionsBuilder_ == null) {
                    functionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProtoOrBuilder>(
                        functions_,
                        ((bitField0_ & 0x00000400) != 0),
                        getParentForChildren(),
                        isClean());
                    functions_ = null;
                }
                return functionsBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto> configuration_ =
                java.util.Collections.emptyList();
            private void ensureConfigurationIsMutable() {
                if (!((bitField0_ & 0x00000800) != 0)) {
                    configuration_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto>(configuration_);
                    bitField0_ |= 0x00000800;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.DeviceConfigurationProto, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProtoOrBuilder> configurationBuilder_;
            
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto> getConfigurationList() {
                if (configurationBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(configuration_);
                } else {
                    return configurationBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public int getConfigurationCount() {
                if (configurationBuilder_ == null) {
                    return configuration_.size();
                } else {
                    return configurationBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto getConfiguration(int index) {
                if (configurationBuilder_ == null) {
                    return configuration_.get(index);
                } else {
                    return configurationBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public Builder setConfiguration(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto value) {
                if (configurationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureConfigurationIsMutable();
                    configuration_.set(index, value);
                    onChanged();
                } else {
                    configurationBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public Builder setConfiguration(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.Builder builderForValue) {
                if (configurationBuilder_ == null) {
                    ensureConfigurationIsMutable();
                    configuration_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    configurationBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public Builder addConfiguration(org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto value) {
                if (configurationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureConfigurationIsMutable();
                    configuration_.add(value);
                    onChanged();
                } else {
                    configurationBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public Builder addConfiguration(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto value) {
                if (configurationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureConfigurationIsMutable();
                    configuration_.add(index, value);
                    onChanged();
                } else {
                    configurationBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public Builder addConfiguration(
                org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.Builder builderForValue) {
                if (configurationBuilder_ == null) {
                    ensureConfigurationIsMutable();
                    configuration_.add(builderForValue.build());
                    onChanged();
                } else {
                    configurationBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public Builder addConfiguration(
                int index, ProtoOnnx.DeviceConfigurationProto.Builder builderForValue) {
                if (configurationBuilder_ == null) {
                    ensureConfigurationIsMutable();
                    configuration_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    configurationBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public Builder addAllConfiguration(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto> values) {
                if (configurationBuilder_ == null) {
                    ensureConfigurationIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, configuration_);
                    onChanged();
                } else {
                    configurationBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public Builder clearConfiguration() {
                if (configurationBuilder_ == null) {
                    configuration_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000800);
                    onChanged();
                } else {
                    configurationBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public Builder removeConfiguration(int index) {
                if (configurationBuilder_ == null) {
                    ensureConfigurationIsMutable();
                    configuration_.remove(index);
                    onChanged();
                } else {
                    configurationBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.Builder getConfigurationBuilder(
                int index) {
                return internalGetConfigurationFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProtoOrBuilder getConfigurationOrBuilder(
                int index) {
                if (configurationBuilder_ == null) {
                    return configuration_.get(index);  } else {
                    return configurationBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProtoOrBuilder>
            getConfigurationOrBuilderList() {
                if (configurationBuilder_ != null) {
                    return configurationBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(configuration_);
                }
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.Builder addConfigurationBuilder() {
                return internalGetConfigurationFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.Builder addConfigurationBuilder(
                int index) {
                return internalGetConfigurationFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Describes different target configurations for a multi-device use case.
             * A model MAY describe multiple multi-device configurations for execution.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.DeviceConfigurationProto configuration = 26;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.Builder>
            getConfigurationBuilderList() {
                return internalGetConfigurationFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProtoOrBuilder>
            internalGetConfigurationFieldBuilder() {
                if (configurationBuilder_ == null) {
                    configurationBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto, ProtoOnnx.DeviceConfigurationProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProtoOrBuilder>(
                        configuration_,
                        ((bitField0_ & 0x00000800) != 0),
                        getParentForChildren(),
                        isClean());
                    configuration_ = null;
                }
                return configurationBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.ModelProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.ModelProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<ModelProto>
            PARSER = new com.google.protobuf.AbstractParser<ModelProto>() {
            @java.lang.Override
            public ModelProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<ModelProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<ModelProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ModelProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface DeviceConfigurationProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.DeviceConfigurationProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Name of the configuration.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Name of the configuration.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Name of the configuration.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();
        
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Number of devices inside this configuration.
         * </pre>
         *
         * <code>optional int32 num_devices = 2;</code>
         * @return Whether the numDevices field is set.
         */
        boolean hasNumDevices();
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Number of devices inside this configuration.
         * </pre>
         *
         * <code>optional int32 num_devices = 2;</code>
         * @return The numDevices.
         */
        int getNumDevices();
        
        /**
         * <pre>
         * Optional names of the devices. MUST be length of num_devices if provided.
         * </pre>
         *
         * <code>repeated string device = 3;</code>
         * @return A list containing the device.
         */
        java.util.List<java.lang.String>
        getDeviceList();
        /**
         * <pre>
         * Optional names of the devices. MUST be length of num_devices if provided.
         * </pre>
         *
         * <code>repeated string device = 3;</code>
         * @return The count of device.
         */
        int getDeviceCount();
        /**
         * <pre>
         * Optional names of the devices. MUST be length of num_devices if provided.
         * </pre>
         *
         * <code>repeated string device = 3;</code>
         * @param index The index of the element to return.
         * @return The device at the given index.
         */
        java.lang.String getDevice(int index);
        /**
         * <pre>
         * Optional names of the devices. MUST be length of num_devices if provided.
         * </pre>
         *
         * <code>repeated string device = 3;</code>
         * @param index The index of the value to return.
         * @return The bytes of the device at the given index.
         */
        com.google.protobuf.ByteString
        getDeviceBytes(int index);
    }
    /**
     * <pre>
     * DeviceConfigurationProto describes a multi-device configuration for a model.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.DeviceConfigurationProto}
     */
    public static final class DeviceConfigurationProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.DeviceConfigurationProto)
        DeviceConfigurationProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                DeviceConfigurationProto.class.getName());
        }
        // Use DeviceConfigurationProto.newBuilder() to construct.
        private DeviceConfigurationProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private DeviceConfigurationProto() {
            name_ = "";
            device_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_DeviceConfigurationProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_DeviceConfigurationProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int NAME_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private volatile java.lang.Object name_ = "";
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Name of the configuration.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Name of the configuration.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Name of the configuration.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int NUM_DEVICES_FIELD_NUMBER = 2;
        private int numDevices_ = 0;
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Number of devices inside this configuration.
         * </pre>
         *
         * <code>optional int32 num_devices = 2;</code>
         * @return Whether the numDevices field is set.
         */
        @java.lang.Override
        public boolean hasNumDevices() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * Number of devices inside this configuration.
         * </pre>
         *
         * <code>optional int32 num_devices = 2;</code>
         * @return The numDevices.
         */
        @java.lang.Override
        public int getNumDevices() {
            return numDevices_;
        }
        
        public static final int DEVICE_FIELD_NUMBER = 3;
        @SuppressWarnings("serial")
        private com.google.protobuf.LazyStringArrayList device_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        /**
         * <pre>
         * Optional names of the devices. MUST be length of num_devices if provided.
         * </pre>
         *
         * <code>repeated string device = 3;</code>
         * @return A list containing the device.
         */
        public com.google.protobuf.ProtocolStringList
        getDeviceList() {
            return device_;
        }
        /**
         * <pre>
         * Optional names of the devices. MUST be length of num_devices if provided.
         * </pre>
         *
         * <code>repeated string device = 3;</code>
         * @return The count of device.
         */
        public int getDeviceCount() {
            return device_.size();
        }
        /**
         * <pre>
         * Optional names of the devices. MUST be length of num_devices if provided.
         * </pre>
         *
         * <code>repeated string device = 3;</code>
         * @param index The index of the element to return.
         * @return The device at the given index.
         */
        public java.lang.String getDevice(int index) {
            return device_.get(index);
        }
        /**
         * <pre>
         * Optional names of the devices. MUST be length of num_devices if provided.
         * </pre>
         *
         * <code>repeated string device = 3;</code>
         * @param index The index of the value to return.
         * @return The bytes of the device at the given index.
         */
        public com.google.protobuf.ByteString
        getDeviceBytes(int index) {
            return device_.getByteString(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeInt32(2, numDevices_);
            }
            for (int i = 0; i < device_.size(); i++) {
                com.google.protobuf.GeneratedMessage.writeString(output, 3, device_.getRaw(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt32Size(2, numDevices_);
            }
            {
                int dataSize = 0;
                for (int i = 0; i < device_.size(); i++) {
                    dataSize += computeStringSizeNoTag(device_.getRaw(i));
                }
                size += dataSize;
                size += 1 * getDeviceList().size();
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto)) {
                return super.equals(obj);
            }
            ProtoOnnx.DeviceConfigurationProto other = (ProtoOnnx.DeviceConfigurationProto) obj;
            
            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                    .equals(other.getName())) return false;
            }
            if (hasNumDevices() != other.hasNumDevices()) return false;
            if (hasNumDevices()) {
                if (getNumDevices()
                    != other.getNumDevices()) return false;
            }
            if (!getDeviceList()
                .equals(other.getDeviceList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (hasNumDevices()) {
                hash = (37 * hash) + NUM_DEVICES_FIELD_NUMBER;
                hash = (53 * hash) + getNumDevices();
            }
            if (getDeviceCount() > 0) {
                hash = (37 * hash) + DEVICE_FIELD_NUMBER;
                hash = (53 * hash) + getDeviceList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static ProtoOnnx.DeviceConfigurationProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ProtoOnnx.DeviceConfigurationProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * DeviceConfigurationProto describes a multi-device configuration for a model.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.DeviceConfigurationProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.DeviceConfigurationProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_DeviceConfigurationProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_DeviceConfigurationProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                name_ = "";
                numDevices_ = 0;
                device_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_DeviceConfigurationProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto(this);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.name_ = name_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.numDevices_ = numDevices_;
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    device_.makeImmutable();
                    result.device_ = device_;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto.getDefaultInstance()) return this;
                if (other.hasName()) {
                    name_ = other.name_;
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                if (other.hasNumDevices()) {
                    setNumDevices(other.getNumDevices());
                }
                if (!other.device_.isEmpty()) {
                    if (device_.isEmpty()) {
                        device_ = other.device_;
                        bitField0_ |= 0x00000004;
                    } else {
                        ensureDeviceIsMutable();
                        device_.addAll(other.device_);
                    }
                    onChanged();
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                name_ = input.readBytes();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 16: {
                                numDevices_ = input.readInt32();
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 16
                            case 26: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                ensureDeviceIsMutable();
                                device_.add(bs);
                                break;
                            } // case 26
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.lang.Object name_ = "";
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Name of the configuration.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Name of the configuration.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Name of the configuration.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Name of the configuration.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Name of the configuration.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                name_ = getDefaultInstance().getName();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Name of the configuration.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            
            private int numDevices_ ;
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Number of devices inside this configuration.
             * </pre>
             *
             * <code>optional int32 num_devices = 2;</code>
             * @return Whether the numDevices field is set.
             */
            @java.lang.Override
            public boolean hasNumDevices() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Number of devices inside this configuration.
             * </pre>
             *
             * <code>optional int32 num_devices = 2;</code>
             * @return The numDevices.
             */
            @java.lang.Override
            public int getNumDevices() {
                return numDevices_;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Number of devices inside this configuration.
             * </pre>
             *
             * <code>optional int32 num_devices = 2;</code>
             * @param value The numDevices to set.
             * @return This builder for chaining.
             */
            public Builder setNumDevices(int value) {
                
                numDevices_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * Number of devices inside this configuration.
             * </pre>
             *
             * <code>optional int32 num_devices = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearNumDevices() {
                bitField0_ = (bitField0_ & ~0x00000002);
                numDevices_ = 0;
                onChanged();
                return this;
            }
            
            private com.google.protobuf.LazyStringArrayList device_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            private void ensureDeviceIsMutable() {
                if (!device_.isModifiable()) {
                    device_ = new com.google.protobuf.LazyStringArrayList(device_);
                }
                bitField0_ |= 0x00000004;
            }
            /**
             * <pre>
             * Optional names of the devices. MUST be length of num_devices if provided.
             * </pre>
             *
             * <code>repeated string device = 3;</code>
             * @return A list containing the device.
             */
            public com.google.protobuf.ProtocolStringList
            getDeviceList() {
                device_.makeImmutable();
                return device_;
            }
            /**
             * <pre>
             * Optional names of the devices. MUST be length of num_devices if provided.
             * </pre>
             *
             * <code>repeated string device = 3;</code>
             * @return The count of device.
             */
            public int getDeviceCount() {
                return device_.size();
            }
            /**
             * <pre>
             * Optional names of the devices. MUST be length of num_devices if provided.
             * </pre>
             *
             * <code>repeated string device = 3;</code>
             * @param index The index of the element to return.
             * @return The device at the given index.
             */
            public java.lang.String getDevice(int index) {
                return device_.get(index);
            }
            /**
             * <pre>
             * Optional names of the devices. MUST be length of num_devices if provided.
             * </pre>
             *
             * <code>repeated string device = 3;</code>
             * @param index The index of the value to return.
             * @return The bytes of the device at the given index.
             */
            public com.google.protobuf.ByteString
            getDeviceBytes(int index) {
                return device_.getByteString(index);
            }
            /**
             * <pre>
             * Optional names of the devices. MUST be length of num_devices if provided.
             * </pre>
             *
             * <code>repeated string device = 3;</code>
             * @param index The index to set the value at.
             * @param value The device to set.
             * @return This builder for chaining.
             */
            public Builder setDevice(
                int index, java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureDeviceIsMutable();
                device_.set(index, value);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Optional names of the devices. MUST be length of num_devices if provided.
             * </pre>
             *
             * <code>repeated string device = 3;</code>
             * @param value The device to add.
             * @return This builder for chaining.
             */
            public Builder addDevice(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureDeviceIsMutable();
                device_.add(value);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Optional names of the devices. MUST be length of num_devices if provided.
             * </pre>
             *
             * <code>repeated string device = 3;</code>
             * @param values The device to add.
             * @return This builder for chaining.
             */
            public Builder addAllDevice(
                java.lang.Iterable<java.lang.String> values) {
                ensureDeviceIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, device_);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Optional names of the devices. MUST be length of num_devices if provided.
             * </pre>
             *
             * <code>repeated string device = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearDevice() {
                device_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                bitField0_ = (bitField0_ & ~0x00000004);;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Optional names of the devices. MUST be length of num_devices if provided.
             * </pre>
             *
             * <code>repeated string device = 3;</code>
             * @param value The bytes of the device to add.
             * @return This builder for chaining.
             */
            public Builder addDeviceBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                ensureDeviceIsMutable();
                device_.add(value);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.DeviceConfigurationProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.DeviceConfigurationProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<DeviceConfigurationProto>
            PARSER = new com.google.protobuf.AbstractParser<DeviceConfigurationProto>() {
            @java.lang.Override
            public DeviceConfigurationProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<DeviceConfigurationProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<DeviceConfigurationProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.DeviceConfigurationProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface StringStringEntryProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.StringStringEntryProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <code>optional string key = 1;</code>
         * @return Whether the key field is set.
         */
        boolean hasKey();
        /**
         * <code>optional string key = 1;</code>
         * @return The key.
         */
        java.lang.String getKey();
        /**
         * <code>optional string key = 1;</code>
         * @return The bytes for key.
         */
        com.google.protobuf.ByteString
        getKeyBytes();
        
        /**
         * <code>optional string value = 2;</code>
         * @return Whether the value field is set.
         */
        boolean hasValue();
        /**
         * <code>optional string value = 2;</code>
         * @return The value.
         */
        java.lang.String getValue();
        /**
         * <code>optional string value = 2;</code>
         * @return The bytes for value.
         */
        com.google.protobuf.ByteString
        getValueBytes();
    }
    /**
     * <pre>
     * StringStringEntryProto follows the pattern for cross-proto-version maps.
     * See https://developers.google.com/protocol-buffers/docs/proto3#maps
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.StringStringEntryProto}
     */
    public static final class StringStringEntryProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.StringStringEntryProto)
        StringStringEntryProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                StringStringEntryProto.class.getName());
        }
        // Use StringStringEntryProto.newBuilder() to construct.
        private StringStringEntryProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private StringStringEntryProto() {
            key_ = "";
            value_ = "";
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_StringStringEntryProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_StringStringEntryProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int KEY_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private volatile java.lang.Object key_ = "";
        /**
         * <code>optional string key = 1;</code>
         * @return Whether the key field is set.
         */
        @java.lang.Override
        public boolean hasKey() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional string key = 1;</code>
         * @return The key.
         */
        @java.lang.Override
        public java.lang.String getKey() {
            java.lang.Object ref = key_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    key_ = s;
                }
                return s;
            }
        }
        /**
         * <code>optional string key = 1;</code>
         * @return The bytes for key.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getKeyBytes() {
            java.lang.Object ref = key_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                key_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int VALUE_FIELD_NUMBER = 2;
        @SuppressWarnings("serial")
        private volatile java.lang.Object value_ = "";
        /**
         * <code>optional string value = 2;</code>
         * @return Whether the value field is set.
         */
        @java.lang.Override
        public boolean hasValue() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional string value = 2;</code>
         * @return The value.
         */
        @java.lang.Override
        public java.lang.String getValue() {
            java.lang.Object ref = value_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    value_ = s;
                }
                return s;
            }
        }
        /**
         * <code>optional string value = 2;</code>
         * @return The bytes for value.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getValueBytes() {
            java.lang.Object ref = value_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                value_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 1, key_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 2, value_);
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(1, key_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(2, value_);
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto) obj;
            
            if (hasKey() != other.hasKey()) return false;
            if (hasKey()) {
                if (!getKey()
                    .equals(other.getKey())) return false;
            }
            if (hasValue() != other.hasValue()) return false;
            if (hasValue()) {
                if (!getValue()
                    .equals(other.getValue())) return false;
            }
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasKey()) {
                hash = (37 * hash) + KEY_FIELD_NUMBER;
                hash = (53 * hash) + getKey().hashCode();
            }
            if (hasValue()) {
                hash = (37 * hash) + VALUE_FIELD_NUMBER;
                hash = (53 * hash) + getValue().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.StringStringEntryProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * StringStringEntryProto follows the pattern for cross-proto-version maps.
         * See https://developers.google.com/protocol-buffers/docs/proto3#maps
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.StringStringEntryProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.StringStringEntryProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_StringStringEntryProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_StringStringEntryProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                key_ = "";
                value_ = "";
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_StringStringEntryProto_descriptor;
            }
            
            @java.lang.Override
            public ProtoOnnx.StringStringEntryProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public ProtoOnnx.StringStringEntryProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto(this);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.key_ = key_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.value_ = value_;
                    to_bitField0_ |= 0x00000002;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(ProtoOnnx.StringStringEntryProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance()) return this;
                if (other.hasKey()) {
                    key_ = other.key_;
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                if (other.hasValue()) {
                    value_ = other.value_;
                    bitField0_ |= 0x00000002;
                    onChanged();
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                key_ = input.readBytes();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 18: {
                                value_ = input.readBytes();
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 18
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.lang.Object key_ = "";
            /**
             * <code>optional string key = 1;</code>
             * @return Whether the key field is set.
             */
            public boolean hasKey() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <code>optional string key = 1;</code>
             * @return The key.
             */
            public java.lang.String getKey() {
                java.lang.Object ref = key_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        key_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <code>optional string key = 1;</code>
             * @return The bytes for key.
             */
            public com.google.protobuf.ByteString
            getKeyBytes() {
                java.lang.Object ref = key_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    key_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <code>optional string key = 1;</code>
             * @param value The key to set.
             * @return This builder for chaining.
             */
            public Builder setKey(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                key_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <code>optional string key = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearKey() {
                key_ = getDefaultInstance().getKey();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            /**
             * <code>optional string key = 1;</code>
             * @param value The bytes for key to set.
             * @return This builder for chaining.
             */
            public Builder setKeyBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                key_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            
            private java.lang.Object value_ = "";
            /**
             * <code>optional string value = 2;</code>
             * @return Whether the value field is set.
             */
            public boolean hasValue() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <code>optional string value = 2;</code>
             * @return The value.
             */
            public java.lang.String getValue() {
                java.lang.Object ref = value_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        value_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <code>optional string value = 2;</code>
             * @return The bytes for value.
             */
            public com.google.protobuf.ByteString
            getValueBytes() {
                java.lang.Object ref = value_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    value_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <code>optional string value = 2;</code>
             * @param value The value to set.
             * @return This builder for chaining.
             */
            public Builder setValue(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                value_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <code>optional string value = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearValue() {
                value_ = getDefaultInstance().getValue();
                bitField0_ = (bitField0_ & ~0x00000002);
                onChanged();
                return this;
            }
            /**
             * <code>optional string value = 2;</code>
             * @param value The bytes for value to set.
             * @return This builder for chaining.
             */
            public Builder setValueBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                value_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.StringStringEntryProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.StringStringEntryProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<StringStringEntryProto>
            PARSER = new com.google.protobuf.AbstractParser<StringStringEntryProto>() {
            @java.lang.Override
            public StringStringEntryProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<StringStringEntryProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<StringStringEntryProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface TensorAnnotationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TensorAnnotation)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return Whether the tensorName field is set.
         */
        boolean hasTensorName();
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return The tensorName.
         */
        java.lang.String getTensorName();
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return The bytes for tensorName.
         */
        com.google.protobuf.ByteString
        getTensorNameBytes();
        
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>
        getQuantParameterTensorNamesList();
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getQuantParameterTensorNames(int index);
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        int getQuantParameterTensorNamesCount();
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getQuantParameterTensorNamesOrBuilderList();
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(
            int index);
    }
    /**
     * Protobuf type {@code org.brain4j.core.importing.onnx.TensorAnnotation}
     */
    public static final class TensorAnnotation extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TensorAnnotation)
        TensorAnnotationOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                TensorAnnotation.class.getName());
        }
        // Use TensorAnnotation.newBuilder() to construct.
        private TensorAnnotation(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private TensorAnnotation() {
            tensorName_ = "";
            quantParameterTensorNames_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorAnnotation_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorAnnotation_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.class, org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder.class);
        }
        
        private int bitField0_;
        public static final int TENSOR_NAME_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private volatile java.lang.Object tensorName_ = "";
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return Whether the tensorName field is set.
         */
        @java.lang.Override
        public boolean hasTensorName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return The tensorName.
         */
        @java.lang.Override
        public java.lang.String getTensorName() {
            java.lang.Object ref = tensorName_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    tensorName_ = s;
                }
                return s;
            }
        }
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return The bytes for tensorName.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getTensorNameBytes() {
            java.lang.Object ref = tensorName_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                tensorName_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int QUANT_PARAMETER_TENSOR_NAMES_FIELD_NUMBER = 2;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> quantParameterTensorNames_;
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.StringStringEntryProto> getQuantParameterTensorNamesList() {
            return quantParameterTensorNames_;
        }
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getQuantParameterTensorNamesOrBuilderList() {
            return quantParameterTensorNames_;
        }
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        @java.lang.Override
        public int getQuantParameterTensorNamesCount() {
            return quantParameterTensorNames_.size();
        }
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getQuantParameterTensorNames(int index) {
            return quantParameterTensorNames_.get(index);
        }
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(
            int index) {
            return quantParameterTensorNames_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 1, tensorName_);
            }
            for (int i = 0; i < quantParameterTensorNames_.size(); i++) {
                output.writeMessage(2, quantParameterTensorNames_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(1, tensorName_);
            }
            for (int i = 0; i < quantParameterTensorNames_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(2, quantParameterTensorNames_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ProtoOnnx.TensorAnnotation)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation other = (org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation) obj;
            
            if (hasTensorName() != other.hasTensorName()) return false;
            if (hasTensorName()) {
                if (!getTensorName()
                    .equals(other.getTensorName())) return false;
            }
            if (!getQuantParameterTensorNamesList()
                .equals(other.getQuantParameterTensorNamesList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasTensorName()) {
                hash = (37 * hash) + TENSOR_NAME_FIELD_NUMBER;
                hash = (53 * hash) + getTensorName().hashCode();
            }
            if (getQuantParameterTensorNamesCount() > 0) {
                hash = (37 * hash) + QUANT_PARAMETER_TENSOR_NAMES_FIELD_NUMBER;
                hash = (53 * hash) + getQuantParameterTensorNamesList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static ProtoOnnx.TensorAnnotation parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ProtoOnnx.TensorAnnotation prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * Protobuf type {@code org.brain4j.core.importing.onnx.TensorAnnotation}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TensorAnnotation)
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotationOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorAnnotation_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ProtoOnnx.internal_static_onnx_TensorAnnotation_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.class, org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                tensorName_ = "";
                if (quantParameterTensorNamesBuilder_ == null) {
                    quantParameterTensorNames_ = java.util.Collections.emptyList();
                } else {
                    quantParameterTensorNames_ = null;
                    quantParameterTensorNamesBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000002);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorAnnotation_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.getDefaultInstance();
            }
            
            @java.lang.Override
            public ProtoOnnx.TensorAnnotation build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation result = new org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation result) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0)) {
                        quantParameterTensorNames_ = java.util.Collections.unmodifiableList(quantParameterTensorNames_);
                        bitField0_ = (bitField0_ & ~0x00000002);
                    }
                    result.quantParameterTensorNames_ = quantParameterTensorNames_;
                } else {
                    result.quantParameterTensorNames_ = quantParameterTensorNamesBuilder_.build();
                }
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.tensorName_ = tensorName_;
                    to_bitField0_ |= 0x00000001;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.getDefaultInstance()) return this;
                if (other.hasTensorName()) {
                    tensorName_ = other.tensorName_;
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                if (quantParameterTensorNamesBuilder_ == null) {
                    if (!other.quantParameterTensorNames_.isEmpty()) {
                        if (quantParameterTensorNames_.isEmpty()) {
                            quantParameterTensorNames_ = other.quantParameterTensorNames_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                        } else {
                            ensureQuantParameterTensorNamesIsMutable();
                            quantParameterTensorNames_.addAll(other.quantParameterTensorNames_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.quantParameterTensorNames_.isEmpty()) {
                        if (quantParameterTensorNamesBuilder_.isEmpty()) {
                            quantParameterTensorNamesBuilder_.dispose();
                            quantParameterTensorNamesBuilder_ = null;
                            quantParameterTensorNames_ = other.quantParameterTensorNames_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                            quantParameterTensorNamesBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetQuantParameterTensorNamesFieldBuilder() : null;
                        } else {
                            quantParameterTensorNamesBuilder_.addAllMessages(other.quantParameterTensorNames_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                tensorName_ = input.readBytes();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 18: {
                                ProtoOnnx.StringStringEntryProto m =
                                    input.readMessage(
                                        ProtoOnnx.StringStringEntryProto.parser(),
                                        extensionRegistry);
                                if (quantParameterTensorNamesBuilder_ == null) {
                                    ensureQuantParameterTensorNamesIsMutable();
                                    quantParameterTensorNames_.add(m);
                                } else {
                                    quantParameterTensorNamesBuilder_.addMessage(m);
                                }
                                break;
                            } // case 18
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.lang.Object tensorName_ = "";
            /**
             * <code>optional string tensor_name = 1;</code>
             * @return Whether the tensorName field is set.
             */
            public boolean hasTensorName() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <code>optional string tensor_name = 1;</code>
             * @return The tensorName.
             */
            public java.lang.String getTensorName() {
                java.lang.Object ref = tensorName_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        tensorName_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <code>optional string tensor_name = 1;</code>
             * @return The bytes for tensorName.
             */
            public com.google.protobuf.ByteString
            getTensorNameBytes() {
                java.lang.Object ref = tensorName_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    tensorName_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <code>optional string tensor_name = 1;</code>
             * @param value The tensorName to set.
             * @return This builder for chaining.
             */
            public Builder setTensorName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                tensorName_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <code>optional string tensor_name = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearTensorName() {
                tensorName_ = getDefaultInstance().getTensorName();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            /**
             * <code>optional string tensor_name = 1;</code>
             * @param value The bytes for tensorName to set.
             * @return This builder for chaining.
             */
            public Builder setTensorNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                tensorName_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> quantParameterTensorNames_ =
                java.util.Collections.emptyList();
            private void ensureQuantParameterTensorNamesIsMutable() {
                if (!((bitField0_ & 0x00000002) != 0)) {
                    quantParameterTensorNames_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>(quantParameterTensorNames_);
                    bitField0_ |= 0x00000002;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder> quantParameterTensorNamesBuilder_;
            
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getQuantParameterTensorNamesList() {
                if (quantParameterTensorNamesBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(quantParameterTensorNames_);
                } else {
                    return quantParameterTensorNamesBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public int getQuantParameterTensorNamesCount() {
                if (quantParameterTensorNamesBuilder_ == null) {
                    return quantParameterTensorNames_.size();
                } else {
                    return quantParameterTensorNamesBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public ProtoOnnx.StringStringEntryProto getQuantParameterTensorNames(int index) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    return quantParameterTensorNames_.get(index);
                } else {
                    return quantParameterTensorNamesBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder setQuantParameterTensorNames(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.set(index, value);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder setQuantParameterTensorNames(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder addQuantParameterTensorNames(org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.add(value);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder addQuantParameterTensorNames(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.add(index, value);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder addQuantParameterTensorNames(
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.add(builderForValue.build());
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder addQuantParameterTensorNames(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder addAllQuantParameterTensorNames(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> values) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    ensureQuantParameterTensorNamesIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, quantParameterTensorNames_);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder clearQuantParameterTensorNames() {
                if (quantParameterTensorNamesBuilder_ == null) {
                    quantParameterTensorNames_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000002);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder removeQuantParameterTensorNames(int index) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.remove(index);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder getQuantParameterTensorNamesBuilder(
                int index) {
                return internalGetQuantParameterTensorNamesFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(
                int index) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    return quantParameterTensorNames_.get(index);  } else {
                    return quantParameterTensorNamesBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            getQuantParameterTensorNamesOrBuilderList() {
                if (quantParameterTensorNamesBuilder_ != null) {
                    return quantParameterTensorNamesBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(quantParameterTensorNames_);
                }
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addQuantParameterTensorNamesBuilder() {
                return internalGetQuantParameterTensorNamesFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addQuantParameterTensorNamesBuilder(
                int index) {
                return internalGetQuantParameterTensorNamesFieldBuilder().addBuilder(
                    index, ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder>
            getQuantParameterTensorNamesBuilderList() {
                return internalGetQuantParameterTensorNamesFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            internalGetQuantParameterTensorNamesFieldBuilder() {
                if (quantParameterTensorNamesBuilder_ == null) {
                    quantParameterTensorNamesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>(
                        quantParameterTensorNames_,
                        ((bitField0_ & 0x00000002) != 0),
                        getParentForChildren(),
                        isClean());
                    quantParameterTensorNames_ = null;
                }
                return quantParameterTensorNamesBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TensorAnnotation)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TensorAnnotation)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<TensorAnnotation>
            PARSER = new com.google.protobuf.AbstractParser<TensorAnnotation>() {
            @java.lang.Override
            public TensorAnnotation parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<TensorAnnotation> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<TensorAnnotation> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface GraphProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.GraphProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto>
        getNodeList();
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
         */
        ProtoOnnx.NodeProto getNode(int index);
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
         */
        int getNodeCount();
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder>
        getNodeOrBuilderList();
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder getNodeOrBuilder(
            int index);
        
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();
        
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto>
        getInitializerList();
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getInitializer(int index);
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
         */
        int getInitializerCount();
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder>
        getInitializerOrBuilderList();
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder getInitializerOrBuilder(
            int index);
        
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto>
        getSparseInitializerList();
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        ProtoOnnx.SparseTensorProto getSparseInitializer(int index);
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        int getSparseInitializerCount();
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProtoOrBuilder>
        getSparseInitializerOrBuilderList();
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(
            int index);
        
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();
        
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto>
        getInputList();
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getInput(int index);
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
         */
        int getInputCount();
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
        getInputOrBuilderList();
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getInputOrBuilder(
            int index);
        
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
         */
        java.util.List<ProtoOnnx.ValueInfoProto>
        getOutputList();
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getOutput(int index);
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
         */
        int getOutputCount();
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
        getOutputOrBuilderList();
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getOutputOrBuilder(
            int index);
        
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto>
        getValueInfoList();
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getValueInfo(int index);
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
         */
        int getValueInfoCount();
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
        getValueInfoOrBuilderList();
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
         */
        ProtoOnnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
            int index);
        
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation>
        getQuantizationAnnotationList();
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        ProtoOnnx.TensorAnnotation getQuantizationAnnotation(int index);
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        int getQuantizationAnnotationCount();
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotationOrBuilder>
        getQuantizationAnnotationOrBuilderList();
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        ProtoOnnx.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(
            int index);
        
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>
        getMetadataPropsList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index);
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        int getMetadataPropsCount();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index);
    }
    /**
     * <pre>
     * Graphs
     *
     * A graph defines the computational logic of a model and is comprised of a parameterized
     * list of nodes that form a directed acyclic graph based on their inputs and outputs.
     * This is the equivalent of the "network" or "graph" in many deep learning
     * frameworks.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.GraphProto}
     */
    public static final class GraphProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.GraphProto)
        GraphProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                GraphProto.class.getName());
        }
        // Use GraphProto.newBuilder() to construct.
        private GraphProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private GraphProto() {
            node_ = java.util.Collections.emptyList();
            name_ = "";
            initializer_ = java.util.Collections.emptyList();
            sparseInitializer_ = java.util.Collections.emptyList();
            docString_ = "";
            input_ = java.util.Collections.emptyList();
            output_ = java.util.Collections.emptyList();
            valueInfo_ = java.util.Collections.emptyList();
            quantizationAnnotation_ = java.util.Collections.emptyList();
            metadataProps_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_GraphProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ProtoOnnx.internal_static_onnx_GraphProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int NODE_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto> node_;
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto> getNodeList() {
            return node_;
        }
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder>
        getNodeOrBuilderList() {
            return node_;
        }
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
         */
        @java.lang.Override
        public int getNodeCount() {
            return node_.size();
        }
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto getNode(int index) {
            return node_.get(index);
        }
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder getNodeOrBuilder(
            int index) {
            return node_.get(index);
        }
        
        public static final int NAME_FIELD_NUMBER = 2;
        @SuppressWarnings("serial")
        private volatile java.lang.Object name_ = "";
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int INITIALIZER_FIELD_NUMBER = 5;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto> initializer_;
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto> getInitializerList() {
            return initializer_;
        }
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder>
        getInitializerOrBuilderList() {
            return initializer_;
        }
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
         */
        @java.lang.Override
        public int getInitializerCount() {
            return initializer_.size();
        }
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getInitializer(int index) {
            return initializer_.get(index);
        }
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder getInitializerOrBuilder(
            int index) {
            return initializer_.get(index);
        }
        
        public static final int SPARSE_INITIALIZER_FIELD_NUMBER = 15;
        @SuppressWarnings("serial")
        private java.util.List<ProtoOnnx.SparseTensorProto> sparseInitializer_;
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto> getSparseInitializerList() {
            return sparseInitializer_;
        }
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProtoOrBuilder>
        getSparseInitializerOrBuilderList() {
            return sparseInitializer_;
        }
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        @java.lang.Override
        public int getSparseInitializerCount() {
            return sparseInitializer_.size();
        }
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        @java.lang.Override
        public ProtoOnnx.SparseTensorProto getSparseInitializer(int index) {
            return sparseInitializer_.get(index);
        }
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(
            int index) {
            return sparseInitializer_.get(index);
        }
        
        public static final int DOC_STRING_FIELD_NUMBER = 10;
        @SuppressWarnings("serial")
        private volatile java.lang.Object docString_ = "";
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int INPUT_FIELD_NUMBER = 11;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> input_;
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> getInputList() {
            return input_;
        }
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
        getInputOrBuilderList() {
            return input_;
        }
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
         */
        @java.lang.Override
        public int getInputCount() {
            return input_.size();
        }
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getInput(int index) {
            return input_.get(index);
        }
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getInputOrBuilder(
            int index) {
            return input_.get(index);
        }
        
        public static final int OUTPUT_FIELD_NUMBER = 12;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> output_;
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> getOutputList() {
            return output_;
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
        getOutputOrBuilderList() {
            return output_;
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
         */
        @java.lang.Override
        public int getOutputCount() {
            return output_.size();
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
         */
        @java.lang.Override
        public ProtoOnnx.ValueInfoProto getOutput(int index) {
            return output_.get(index);
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getOutputOrBuilder(
            int index) {
            return output_.get(index);
        }
        
        public static final int VALUE_INFO_FIELD_NUMBER = 13;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> valueInfo_;
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> getValueInfoList() {
            return valueInfo_;
        }
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
        getValueInfoOrBuilderList() {
            return valueInfo_;
        }
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
         */
        @java.lang.Override
        public int getValueInfoCount() {
            return valueInfo_.size();
        }
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getValueInfo(int index) {
            return valueInfo_.get(index);
        }
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
            int index) {
            return valueInfo_.get(index);
        }
        
        public static final int QUANTIZATION_ANNOTATION_FIELD_NUMBER = 14;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation> quantizationAnnotation_;
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation> getQuantizationAnnotationList() {
            return quantizationAnnotation_;
        }
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotationOrBuilder>
        getQuantizationAnnotationOrBuilderList() {
            return quantizationAnnotation_;
        }
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        @java.lang.Override
        public int getQuantizationAnnotationCount() {
            return quantizationAnnotation_.size();
        }
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation getQuantizationAnnotation(int index) {
            return quantizationAnnotation_.get(index);
        }
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(
            int index) {
            return quantizationAnnotation_.get(index);
        }
        
        public static final int METADATA_PROPS_FIELD_NUMBER = 16;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> metadataProps_;
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        @java.lang.Override
        public int getMetadataPropsCount() {
            return metadataProps_.size();
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
            return metadataProps_.get(index);
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index) {
            return metadataProps_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            for (int i = 0; i < node_.size(); i++) {
                output.writeMessage(1, node_.get(i));
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 2, name_);
            }
            for (int i = 0; i < initializer_.size(); i++) {
                output.writeMessage(5, initializer_.get(i));
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 10, docString_);
            }
            for (int i = 0; i < input_.size(); i++) {
                output.writeMessage(11, input_.get(i));
            }
            for (int i = 0; i < output_.size(); i++) {
                output.writeMessage(12, output_.get(i));
            }
            for (int i = 0; i < valueInfo_.size(); i++) {
                output.writeMessage(13, valueInfo_.get(i));
            }
            for (int i = 0; i < quantizationAnnotation_.size(); i++) {
                output.writeMessage(14, quantizationAnnotation_.get(i));
            }
            for (int i = 0; i < sparseInitializer_.size(); i++) {
                output.writeMessage(15, sparseInitializer_.get(i));
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                output.writeMessage(16, metadataProps_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            for (int i = 0; i < node_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(1, node_.get(i));
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(2, name_);
            }
            for (int i = 0; i < initializer_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(5, initializer_.get(i));
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(10, docString_);
            }
            for (int i = 0; i < input_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(11, input_.get(i));
            }
            for (int i = 0; i < output_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(12, output_.get(i));
            }
            for (int i = 0; i < valueInfo_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(13, valueInfo_.get(i));
            }
            for (int i = 0; i < quantizationAnnotation_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(14, quantizationAnnotation_.get(i));
            }
            for (int i = 0; i < sparseInitializer_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(15, sparseInitializer_.get(i));
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(16, metadataProps_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto) obj;
            
            if (!getNodeList()
                .equals(other.getNodeList())) return false;
            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                    .equals(other.getName())) return false;
            }
            if (!getInitializerList()
                .equals(other.getInitializerList())) return false;
            if (!getSparseInitializerList()
                .equals(other.getSparseInitializerList())) return false;
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                    .equals(other.getDocString())) return false;
            }
            if (!getInputList()
                .equals(other.getInputList())) return false;
            if (!getOutputList()
                .equals(other.getOutputList())) return false;
            if (!getValueInfoList()
                .equals(other.getValueInfoList())) return false;
            if (!getQuantizationAnnotationList()
                .equals(other.getQuantizationAnnotationList())) return false;
            if (!getMetadataPropsList()
                .equals(other.getMetadataPropsList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getNodeCount() > 0) {
                hash = (37 * hash) + NODE_FIELD_NUMBER;
                hash = (53 * hash) + getNodeList().hashCode();
            }
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (getInitializerCount() > 0) {
                hash = (37 * hash) + INITIALIZER_FIELD_NUMBER;
                hash = (53 * hash) + getInitializerList().hashCode();
            }
            if (getSparseInitializerCount() > 0) {
                hash = (37 * hash) + SPARSE_INITIALIZER_FIELD_NUMBER;
                hash = (53 * hash) + getSparseInitializerList().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (getInputCount() > 0) {
                hash = (37 * hash) + INPUT_FIELD_NUMBER;
                hash = (53 * hash) + getInputList().hashCode();
            }
            if (getOutputCount() > 0) {
                hash = (37 * hash) + OUTPUT_FIELD_NUMBER;
                hash = (53 * hash) + getOutputList().hashCode();
            }
            if (getValueInfoCount() > 0) {
                hash = (37 * hash) + VALUE_INFO_FIELD_NUMBER;
                hash = (53 * hash) + getValueInfoList().hashCode();
            }
            if (getQuantizationAnnotationCount() > 0) {
                hash = (37 * hash) + QUANTIZATION_ANNOTATION_FIELD_NUMBER;
                hash = (53 * hash) + getQuantizationAnnotationList().hashCode();
            }
            if (getMetadataPropsCount() > 0) {
                hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
                hash = (53 * hash) + getMetadataPropsList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ProtoOnnx.GraphProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static ProtoOnnx.GraphProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static ProtoOnnx.GraphProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Graphs
         *
         * A graph defines the computational logic of a model and is comprised of a parameterized
         * list of nodes that form a directed acyclic graph based on their inputs and outputs.
         * This is the equivalent of the "network" or "graph" in many deep learning
         * frameworks.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.GraphProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.GraphProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.GraphProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_GraphProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ProtoOnnx.internal_static_onnx_GraphProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                if (nodeBuilder_ == null) {
                    node_ = java.util.Collections.emptyList();
                } else {
                    node_ = null;
                    nodeBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000001);
                name_ = "";
                if (initializerBuilder_ == null) {
                    initializer_ = java.util.Collections.emptyList();
                } else {
                    initializer_ = null;
                    initializerBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000004);
                if (sparseInitializerBuilder_ == null) {
                    sparseInitializer_ = java.util.Collections.emptyList();
                } else {
                    sparseInitializer_ = null;
                    sparseInitializerBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000008);
                docString_ = "";
                if (inputBuilder_ == null) {
                    input_ = java.util.Collections.emptyList();
                } else {
                    input_ = null;
                    inputBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000020);
                if (outputBuilder_ == null) {
                    output_ = java.util.Collections.emptyList();
                } else {
                    output_ = null;
                    outputBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000040);
                if (valueInfoBuilder_ == null) {
                    valueInfo_ = java.util.Collections.emptyList();
                } else {
                    valueInfo_ = null;
                    valueInfoBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000080);
                if (quantizationAnnotationBuilder_ == null) {
                    quantizationAnnotation_ = java.util.Collections.emptyList();
                } else {
                    quantizationAnnotation_ = null;
                    quantizationAnnotationBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000100);
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                } else {
                    metadataProps_ = null;
                    metadataPropsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000200);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_GraphProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public ProtoOnnx.GraphProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto result) {
                if (nodeBuilder_ == null) {
                    if (((bitField0_ & 0x00000001) != 0)) {
                        node_ = java.util.Collections.unmodifiableList(node_);
                        bitField0_ = (bitField0_ & ~0x00000001);
                    }
                    result.node_ = node_;
                } else {
                    result.node_ = nodeBuilder_.build();
                }
                if (initializerBuilder_ == null) {
                    if (((bitField0_ & 0x00000004) != 0)) {
                        initializer_ = java.util.Collections.unmodifiableList(initializer_);
                        bitField0_ = (bitField0_ & ~0x00000004);
                    }
                    result.initializer_ = initializer_;
                } else {
                    result.initializer_ = initializerBuilder_.build();
                }
                if (sparseInitializerBuilder_ == null) {
                    if (((bitField0_ & 0x00000008) != 0)) {
                        sparseInitializer_ = java.util.Collections.unmodifiableList(sparseInitializer_);
                        bitField0_ = (bitField0_ & ~0x00000008);
                    }
                    result.sparseInitializer_ = sparseInitializer_;
                } else {
                    result.sparseInitializer_ = sparseInitializerBuilder_.build();
                }
                if (inputBuilder_ == null) {
                    if (((bitField0_ & 0x00000020) != 0)) {
                        input_ = java.util.Collections.unmodifiableList(input_);
                        bitField0_ = (bitField0_ & ~0x00000020);
                    }
                    result.input_ = input_;
                } else {
                    result.input_ = inputBuilder_.build();
                }
                if (outputBuilder_ == null) {
                    if (((bitField0_ & 0x00000040) != 0)) {
                        output_ = java.util.Collections.unmodifiableList(output_);
                        bitField0_ = (bitField0_ & ~0x00000040);
                    }
                    result.output_ = output_;
                } else {
                    result.output_ = outputBuilder_.build();
                }
                if (valueInfoBuilder_ == null) {
                    if (((bitField0_ & 0x00000080) != 0)) {
                        valueInfo_ = java.util.Collections.unmodifiableList(valueInfo_);
                        bitField0_ = (bitField0_ & ~0x00000080);
                    }
                    result.valueInfo_ = valueInfo_;
                } else {
                    result.valueInfo_ = valueInfoBuilder_.build();
                }
                if (quantizationAnnotationBuilder_ == null) {
                    if (((bitField0_ & 0x00000100) != 0)) {
                        quantizationAnnotation_ = java.util.Collections.unmodifiableList(quantizationAnnotation_);
                        bitField0_ = (bitField0_ & ~0x00000100);
                    }
                    result.quantizationAnnotation_ = quantizationAnnotation_;
                } else {
                    result.quantizationAnnotation_ = quantizationAnnotationBuilder_.build();
                }
                if (metadataPropsBuilder_ == null) {
                    if (((bitField0_ & 0x00000200) != 0)) {
                        metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
                        bitField0_ = (bitField0_ & ~0x00000200);
                    }
                    result.metadataProps_ = metadataProps_;
                } else {
                    result.metadataProps_ = metadataPropsBuilder_.build();
                }
            }
            
            private void buildPartial0(ProtoOnnx.GraphProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.name_ = name_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000010) != 0)) {
                    result.docString_ = docString_;
                    to_bitField0_ |= 0x00000002;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto.getDefaultInstance()) return this;
                if (nodeBuilder_ == null) {
                    if (!other.node_.isEmpty()) {
                        if (node_.isEmpty()) {
                            node_ = other.node_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                        } else {
                            ensureNodeIsMutable();
                            node_.addAll(other.node_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.node_.isEmpty()) {
                        if (nodeBuilder_.isEmpty()) {
                            nodeBuilder_.dispose();
                            nodeBuilder_ = null;
                            node_ = other.node_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                            nodeBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetNodeFieldBuilder() : null;
                        } else {
                            nodeBuilder_.addAllMessages(other.node_);
                        }
                    }
                }
                if (other.hasName()) {
                    name_ = other.name_;
                    bitField0_ |= 0x00000002;
                    onChanged();
                }
                if (initializerBuilder_ == null) {
                    if (!other.initializer_.isEmpty()) {
                        if (initializer_.isEmpty()) {
                            initializer_ = other.initializer_;
                            bitField0_ = (bitField0_ & ~0x00000004);
                        } else {
                            ensureInitializerIsMutable();
                            initializer_.addAll(other.initializer_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.initializer_.isEmpty()) {
                        if (initializerBuilder_.isEmpty()) {
                            initializerBuilder_.dispose();
                            initializerBuilder_ = null;
                            initializer_ = other.initializer_;
                            bitField0_ = (bitField0_ & ~0x00000004);
                            initializerBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetInitializerFieldBuilder() : null;
                        } else {
                            initializerBuilder_.addAllMessages(other.initializer_);
                        }
                    }
                }
                if (sparseInitializerBuilder_ == null) {
                    if (!other.sparseInitializer_.isEmpty()) {
                        if (sparseInitializer_.isEmpty()) {
                            sparseInitializer_ = other.sparseInitializer_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                        } else {
                            ensureSparseInitializerIsMutable();
                            sparseInitializer_.addAll(other.sparseInitializer_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.sparseInitializer_.isEmpty()) {
                        if (sparseInitializerBuilder_.isEmpty()) {
                            sparseInitializerBuilder_.dispose();
                            sparseInitializerBuilder_ = null;
                            sparseInitializer_ = other.sparseInitializer_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                            sparseInitializerBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetSparseInitializerFieldBuilder() : null;
                        } else {
                            sparseInitializerBuilder_.addAllMessages(other.sparseInitializer_);
                        }
                    }
                }
                if (other.hasDocString()) {
                    docString_ = other.docString_;
                    bitField0_ |= 0x00000010;
                    onChanged();
                }
                if (inputBuilder_ == null) {
                    if (!other.input_.isEmpty()) {
                        if (input_.isEmpty()) {
                            input_ = other.input_;
                            bitField0_ = (bitField0_ & ~0x00000020);
                        } else {
                            ensureInputIsMutable();
                            input_.addAll(other.input_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.input_.isEmpty()) {
                        if (inputBuilder_.isEmpty()) {
                            inputBuilder_.dispose();
                            inputBuilder_ = null;
                            input_ = other.input_;
                            bitField0_ = (bitField0_ & ~0x00000020);
                            inputBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetInputFieldBuilder() : null;
                        } else {
                            inputBuilder_.addAllMessages(other.input_);
                        }
                    }
                }
                if (outputBuilder_ == null) {
                    if (!other.output_.isEmpty()) {
                        if (output_.isEmpty()) {
                            output_ = other.output_;
                            bitField0_ = (bitField0_ & ~0x00000040);
                        } else {
                            ensureOutputIsMutable();
                            output_.addAll(other.output_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.output_.isEmpty()) {
                        if (outputBuilder_.isEmpty()) {
                            outputBuilder_.dispose();
                            outputBuilder_ = null;
                            output_ = other.output_;
                            bitField0_ = (bitField0_ & ~0x00000040);
                            outputBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetOutputFieldBuilder() : null;
                        } else {
                            outputBuilder_.addAllMessages(other.output_);
                        }
                    }
                }
                if (valueInfoBuilder_ == null) {
                    if (!other.valueInfo_.isEmpty()) {
                        if (valueInfo_.isEmpty()) {
                            valueInfo_ = other.valueInfo_;
                            bitField0_ = (bitField0_ & ~0x00000080);
                        } else {
                            ensureValueInfoIsMutable();
                            valueInfo_.addAll(other.valueInfo_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.valueInfo_.isEmpty()) {
                        if (valueInfoBuilder_.isEmpty()) {
                            valueInfoBuilder_.dispose();
                            valueInfoBuilder_ = null;
                            valueInfo_ = other.valueInfo_;
                            bitField0_ = (bitField0_ & ~0x00000080);
                            valueInfoBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetValueInfoFieldBuilder() : null;
                        } else {
                            valueInfoBuilder_.addAllMessages(other.valueInfo_);
                        }
                    }
                }
                if (quantizationAnnotationBuilder_ == null) {
                    if (!other.quantizationAnnotation_.isEmpty()) {
                        if (quantizationAnnotation_.isEmpty()) {
                            quantizationAnnotation_ = other.quantizationAnnotation_;
                            bitField0_ = (bitField0_ & ~0x00000100);
                        } else {
                            ensureQuantizationAnnotationIsMutable();
                            quantizationAnnotation_.addAll(other.quantizationAnnotation_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.quantizationAnnotation_.isEmpty()) {
                        if (quantizationAnnotationBuilder_.isEmpty()) {
                            quantizationAnnotationBuilder_.dispose();
                            quantizationAnnotationBuilder_ = null;
                            quantizationAnnotation_ = other.quantizationAnnotation_;
                            bitField0_ = (bitField0_ & ~0x00000100);
                            quantizationAnnotationBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetQuantizationAnnotationFieldBuilder() : null;
                        } else {
                            quantizationAnnotationBuilder_.addAllMessages(other.quantizationAnnotation_);
                        }
                    }
                }
                if (metadataPropsBuilder_ == null) {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataProps_.isEmpty()) {
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000200);
                        } else {
                            ensureMetadataPropsIsMutable();
                            metadataProps_.addAll(other.metadataProps_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataPropsBuilder_.isEmpty()) {
                            metadataPropsBuilder_.dispose();
                            metadataPropsBuilder_ = null;
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000200);
                            metadataPropsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetMetadataPropsFieldBuilder() : null;
                        } else {
                            metadataPropsBuilder_.addAllMessages(other.metadataProps_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.parser(),
                                        extensionRegistry);
                                if (nodeBuilder_ == null) {
                                    ensureNodeIsMutable();
                                    node_.add(m);
                                } else {
                                    nodeBuilder_.addMessage(m);
                                }
                                break;
                            } // case 10
                            case 18: {
                                name_ = input.readBytes();
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 18
                            case 42: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.parser(),
                                        extensionRegistry);
                                if (initializerBuilder_ == null) {
                                    ensureInitializerIsMutable();
                                    initializer_.add(m);
                                } else {
                                    initializerBuilder_.addMessage(m);
                                }
                                break;
                            } // case 42
                            case 82: {
                                docString_ = input.readBytes();
                                bitField0_ |= 0x00000010;
                                break;
                            } // case 82
                            case 90: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.parser(),
                                        extensionRegistry);
                                if (inputBuilder_ == null) {
                                    ensureInputIsMutable();
                                    input_.add(m);
                                } else {
                                    inputBuilder_.addMessage(m);
                                }
                                break;
                            } // case 90
                            case 98: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.parser(),
                                        extensionRegistry);
                                if (outputBuilder_ == null) {
                                    ensureOutputIsMutable();
                                    output_.add(m);
                                } else {
                                    outputBuilder_.addMessage(m);
                                }
                                break;
                            } // case 98
                            case 106: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.parser(),
                                        extensionRegistry);
                                if (valueInfoBuilder_ == null) {
                                    ensureValueInfoIsMutable();
                                    valueInfo_.add(m);
                                } else {
                                    valueInfoBuilder_.addMessage(m);
                                }
                                break;
                            } // case 106
                            case 114: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation m =
                                    input.readMessage(
                                        ProtoOnnx.TensorAnnotation.parser(),
                                        extensionRegistry);
                                if (quantizationAnnotationBuilder_ == null) {
                                    ensureQuantizationAnnotationIsMutable();
                                    quantizationAnnotation_.add(m);
                                } else {
                                    quantizationAnnotationBuilder_.addMessage(m);
                                }
                                break;
                            } // case 114
                            case 122: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.parser(),
                                        extensionRegistry);
                                if (sparseInitializerBuilder_ == null) {
                                    ensureSparseInitializerIsMutable();
                                    sparseInitializer_.add(m);
                                } else {
                                    sparseInitializerBuilder_.addMessage(m);
                                }
                                break;
                            } // case 122
                            case 130: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto m =
                                    input.readMessage(
                                        ProtoOnnx.StringStringEntryProto.parser(),
                                        extensionRegistry);
                                if (metadataPropsBuilder_ == null) {
                                    ensureMetadataPropsIsMutable();
                                    metadataProps_.add(m);
                                } else {
                                    metadataPropsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 130
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.util.List<ProtoOnnx.NodeProto> node_ =
                java.util.Collections.emptyList();
            private void ensureNodeIsMutable() {
                if (!((bitField0_ & 0x00000001) != 0)) {
                    node_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto>(node_);
                    bitField0_ |= 0x00000001;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder> nodeBuilder_;
            
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public java.util.List<ProtoOnnx.NodeProto> getNodeList() {
                if (nodeBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(node_);
                } else {
                    return nodeBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public int getNodeCount() {
                if (nodeBuilder_ == null) {
                    return node_.size();
                } else {
                    return nodeBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto getNode(int index) {
                if (nodeBuilder_ == null) {
                    return node_.get(index);
                } else {
                    return nodeBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public Builder setNode(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto value) {
                if (nodeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureNodeIsMutable();
                    node_.set(index, value);
                    onChanged();
                } else {
                    nodeBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public Builder setNode(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder builderForValue) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    nodeBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public Builder addNode(org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto value) {
                if (nodeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureNodeIsMutable();
                    node_.add(value);
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public Builder addNode(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto value) {
                if (nodeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureNodeIsMutable();
                    node_.add(index, value);
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public Builder addNode(
                org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder builderForValue) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.add(builderForValue.build());
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public Builder addNode(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder builderForValue) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public Builder addAllNode(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto> values) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, node_);
                    onChanged();
                } else {
                    nodeBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public Builder clearNode() {
                if (nodeBuilder_ == null) {
                    node_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000001);
                    onChanged();
                } else {
                    nodeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public Builder removeNode(int index) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.remove(index);
                    onChanged();
                } else {
                    nodeBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder getNodeBuilder(
                int index) {
                return internalGetNodeFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder getNodeOrBuilder(
                int index) {
                if (nodeBuilder_ == null) {
                    return node_.get(index);  } else {
                    return nodeBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder>
            getNodeOrBuilderList() {
                if (nodeBuilder_ != null) {
                    return nodeBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(node_);
                }
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public ProtoOnnx.NodeProto.Builder addNodeBuilder() {
                return internalGetNodeFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public ProtoOnnx.NodeProto.Builder addNodeBuilder(
                int index) {
                return internalGetNodeFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 1;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder>
            getNodeBuilderList() {
                return internalGetNodeFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder>
            internalGetNodeFieldBuilder() {
                if (nodeBuilder_ == null) {
                    nodeBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.NodeProto, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder>(
                        node_,
                        ((bitField0_ & 0x00000001) != 0),
                        getParentForChildren(),
                        isClean());
                    node_ = null;
                }
                return nodeBuilder_;
            }
            
            private java.lang.Object name_ = "";
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                name_ = getDefaultInstance().getName();
                bitField0_ = (bitField0_ & ~0x00000002);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            
            private java.util.List<ProtoOnnx.TensorProto> initializer_ =
                java.util.Collections.emptyList();
            private void ensureInitializerIsMutable() {
                if (!((bitField0_ & 0x00000004) != 0)) {
                    initializer_ = new java.util.ArrayList<ProtoOnnx.TensorProto>(initializer_);
                    bitField0_ |= 0x00000004;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder> initializerBuilder_;
            
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto> getInitializerList() {
                if (initializerBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(initializer_);
                } else {
                    return initializerBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public int getInitializerCount() {
                if (initializerBuilder_ == null) {
                    return initializer_.size();
                } else {
                    return initializerBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getInitializer(int index) {
                if (initializerBuilder_ == null) {
                    return initializer_.get(index);
                } else {
                    return initializerBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public Builder setInitializer(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto value) {
                if (initializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializerIsMutable();
                    initializer_.set(index, value);
                    onChanged();
                } else {
                    initializerBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public Builder setInitializer(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder builderForValue) {
                if (initializerBuilder_ == null) {
                    ensureInitializerIsMutable();
                    initializer_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    initializerBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public Builder addInitializer(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto value) {
                if (initializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializerIsMutable();
                    initializer_.add(value);
                    onChanged();
                } else {
                    initializerBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public Builder addInitializer(
                int index, ProtoOnnx.TensorProto value) {
                if (initializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializerIsMutable();
                    initializer_.add(index, value);
                    onChanged();
                } else {
                    initializerBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public Builder addInitializer(
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder builderForValue) {
                if (initializerBuilder_ == null) {
                    ensureInitializerIsMutable();
                    initializer_.add(builderForValue.build());
                    onChanged();
                } else {
                    initializerBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public Builder addInitializer(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder builderForValue) {
                if (initializerBuilder_ == null) {
                    ensureInitializerIsMutable();
                    initializer_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    initializerBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public Builder addAllInitializer(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto> values) {
                if (initializerBuilder_ == null) {
                    ensureInitializerIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, initializer_);
                    onChanged();
                } else {
                    initializerBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public Builder clearInitializer() {
                if (initializerBuilder_ == null) {
                    initializer_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000004);
                    onChanged();
                } else {
                    initializerBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public Builder removeInitializer(int index) {
                if (initializerBuilder_ == null) {
                    ensureInitializerIsMutable();
                    initializer_.remove(index);
                    onChanged();
                } else {
                    initializerBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder getInitializerBuilder(
                int index) {
                return internalGetInitializerFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder getInitializerOrBuilder(
                int index) {
                if (initializerBuilder_ == null) {
                    return initializer_.get(index);  } else {
                    return initializerBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public java.util.List<? extends ProtoOnnx.TensorProtoOrBuilder>
            getInitializerOrBuilderList() {
                if (initializerBuilder_ != null) {
                    return initializerBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(initializer_);
                }
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder addInitializerBuilder() {
                return internalGetInitializerFieldBuilder().addBuilder(
                    ProtoOnnx.TensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder addInitializerBuilder(
                int index) {
                return internalGetInitializerFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorProto initializer = 5;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder>
            getInitializerBuilderList() {
                return internalGetInitializerFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder>
            internalGetInitializerFieldBuilder() {
                if (initializerBuilder_ == null) {
                    initializerBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto, ProtoOnnx.TensorProto.Builder, ProtoOnnx.TensorProtoOrBuilder>(
                        initializer_,
                        ((bitField0_ & 0x00000004) != 0),
                        getParentForChildren(),
                        isClean());
                    initializer_ = null;
                }
                return initializerBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto> sparseInitializer_ =
                java.util.Collections.emptyList();
            private void ensureSparseInitializerIsMutable() {
                if (!((bitField0_ & 0x00000008) != 0)) {
                    sparseInitializer_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto>(sparseInitializer_);
                    bitField0_ |= 0x00000008;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto, ProtoOnnx.SparseTensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProtoOrBuilder> sparseInitializerBuilder_;
            
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto> getSparseInitializerList() {
                if (sparseInitializerBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(sparseInitializer_);
                } else {
                    return sparseInitializerBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public int getSparseInitializerCount() {
                if (sparseInitializerBuilder_ == null) {
                    return sparseInitializer_.size();
                } else {
                    return sparseInitializerBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public ProtoOnnx.SparseTensorProto getSparseInitializer(int index) {
                if (sparseInitializerBuilder_ == null) {
                    return sparseInitializer_.get(index);
                } else {
                    return sparseInitializerBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder setSparseInitializer(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto value) {
                if (sparseInitializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.set(index, value);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder setSparseInitializer(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder builderForValue) {
                if (sparseInitializerBuilder_ == null) {
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    sparseInitializerBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder addSparseInitializer(org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto value) {
                if (sparseInitializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.add(value);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder addSparseInitializer(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto value) {
                if (sparseInitializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.add(index, value);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder addSparseInitializer(
                org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder builderForValue) {
                if (sparseInitializerBuilder_ == null) {
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.add(builderForValue.build());
                    onChanged();
                } else {
                    sparseInitializerBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder addSparseInitializer(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder builderForValue) {
                if (sparseInitializerBuilder_ == null) {
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    sparseInitializerBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder addAllSparseInitializer(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto> values) {
                if (sparseInitializerBuilder_ == null) {
                    ensureSparseInitializerIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, sparseInitializer_);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder clearSparseInitializer() {
                if (sparseInitializerBuilder_ == null) {
                    sparseInitializer_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000008);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder removeSparseInitializer(int index) {
                if (sparseInitializerBuilder_ == null) {
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.remove(index);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder getSparseInitializerBuilder(
                int index) {
                return internalGetSparseInitializerFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(
                int index) {
                if (sparseInitializerBuilder_ == null) {
                    return sparseInitializer_.get(index);  } else {
                    return sparseInitializerBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProtoOrBuilder>
            getSparseInitializerOrBuilderList() {
                if (sparseInitializerBuilder_ != null) {
                    return sparseInitializerBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(sparseInitializer_);
                }
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder addSparseInitializerBuilder() {
                return internalGetSparseInitializerFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder addSparseInitializerBuilder(
                int index) {
                return internalGetSparseInitializerFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder>
            getSparseInitializerBuilderList() {
                return internalGetSparseInitializerFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProtoOrBuilder>
            internalGetSparseInitializerFieldBuilder() {
                if (sparseInitializerBuilder_ == null) {
                    sparseInitializerBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProtoOrBuilder>(
                        sparseInitializer_,
                        ((bitField0_ & 0x00000008) != 0),
                        getParentForChildren(),
                        isClean());
                    sparseInitializer_ = null;
                }
                return sparseInitializerBuilder_;
            }
            
            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000010) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                docString_ = getDefaultInstance().getDocString();
                bitField0_ = (bitField0_ & ~0x00000010);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> input_ =
                java.util.Collections.emptyList();
            private void ensureInputIsMutable() {
                if (!((bitField0_ & 0x00000020) != 0)) {
                    input_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto>(input_);
                    bitField0_ |= 0x00000020;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder> inputBuilder_;
            
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> getInputList() {
                if (inputBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(input_);
                } else {
                    return inputBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public int getInputCount() {
                if (inputBuilder_ == null) {
                    return input_.size();
                } else {
                    return inputBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getInput(int index) {
                if (inputBuilder_ == null) {
                    return input_.get(index);
                } else {
                    return inputBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public Builder setInput(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (inputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInputIsMutable();
                    input_.set(index, value);
                    onChanged();
                } else {
                    inputBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public Builder setInput(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (inputBuilder_ == null) {
                    ensureInputIsMutable();
                    input_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    inputBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public Builder addInput(org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (inputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInputIsMutable();
                    input_.add(value);
                    onChanged();
                } else {
                    inputBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public Builder addInput(
                int index, ProtoOnnx.ValueInfoProto value) {
                if (inputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInputIsMutable();
                    input_.add(index, value);
                    onChanged();
                } else {
                    inputBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public Builder addInput(
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (inputBuilder_ == null) {
                    ensureInputIsMutable();
                    input_.add(builderForValue.build());
                    onChanged();
                } else {
                    inputBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public Builder addInput(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (inputBuilder_ == null) {
                    ensureInputIsMutable();
                    input_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    inputBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public Builder addAllInput(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> values) {
                if (inputBuilder_ == null) {
                    ensureInputIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, input_);
                    onChanged();
                } else {
                    inputBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public Builder clearInput() {
                if (inputBuilder_ == null) {
                    input_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000020);
                    onChanged();
                } else {
                    inputBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public Builder removeInput(int index) {
                if (inputBuilder_ == null) {
                    ensureInputIsMutable();
                    input_.remove(index);
                    onChanged();
                } else {
                    inputBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder getInputBuilder(
                int index) {
                return internalGetInputFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getInputOrBuilder(
                int index) {
                if (inputBuilder_ == null) {
                    return input_.get(index);  } else {
                    return inputBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public java.util.List<? extends ProtoOnnx.ValueInfoProtoOrBuilder>
            getInputOrBuilderList() {
                if (inputBuilder_ != null) {
                    return inputBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(input_);
                }
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder addInputBuilder() {
                return internalGetInputFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder addInputBuilder(
                int index) {
                return internalGetInputFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto input = 11;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder>
            getInputBuilderList() {
                return internalGetInputFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder, ProtoOnnx.ValueInfoProtoOrBuilder>
            internalGetInputFieldBuilder() {
                if (inputBuilder_ == null) {
                    inputBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.ValueInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>(
                        input_,
                        ((bitField0_ & 0x00000020) != 0),
                        getParentForChildren(),
                        isClean());
                    input_ = null;
                }
                return inputBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> output_ =
                java.util.Collections.emptyList();
            private void ensureOutputIsMutable() {
                if (!((bitField0_ & 0x00000040) != 0)) {
                    output_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto>(output_);
                    bitField0_ |= 0x00000040;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder> outputBuilder_;
            
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public java.util.List<ProtoOnnx.ValueInfoProto> getOutputList() {
                if (outputBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(output_);
                } else {
                    return outputBuilder_.getMessageList();
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public int getOutputCount() {
                if (outputBuilder_ == null) {
                    return output_.size();
                } else {
                    return outputBuilder_.getCount();
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getOutput(int index) {
                if (outputBuilder_ == null) {
                    return output_.get(index);
                } else {
                    return outputBuilder_.getMessage(index);
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public Builder setOutput(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (outputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOutputIsMutable();
                    output_.set(index, value);
                    onChanged();
                } else {
                    outputBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public Builder setOutput(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (outputBuilder_ == null) {
                    ensureOutputIsMutable();
                    output_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    outputBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public Builder addOutput(org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (outputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOutputIsMutable();
                    output_.add(value);
                    onChanged();
                } else {
                    outputBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public Builder addOutput(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (outputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOutputIsMutable();
                    output_.add(index, value);
                    onChanged();
                } else {
                    outputBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public Builder addOutput(
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (outputBuilder_ == null) {
                    ensureOutputIsMutable();
                    output_.add(builderForValue.build());
                    onChanged();
                } else {
                    outputBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public Builder addOutput(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (outputBuilder_ == null) {
                    ensureOutputIsMutable();
                    output_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    outputBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public Builder addAllOutput(
                java.lang.Iterable<? extends ProtoOnnx.ValueInfoProto> values) {
                if (outputBuilder_ == null) {
                    ensureOutputIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, output_);
                    onChanged();
                } else {
                    outputBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public Builder clearOutput() {
                if (outputBuilder_ == null) {
                    output_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000040);
                    onChanged();
                } else {
                    outputBuilder_.clear();
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public Builder removeOutput(int index) {
                if (outputBuilder_ == null) {
                    ensureOutputIsMutable();
                    output_.remove(index);
                    onChanged();
                } else {
                    outputBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder getOutputBuilder(
                int index) {
                return internalGetOutputFieldBuilder().getBuilder(index);
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getOutputOrBuilder(
                int index) {
                if (outputBuilder_ == null) {
                    return output_.get(index);  } else {
                    return outputBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
            getOutputOrBuilderList() {
                if (outputBuilder_ != null) {
                    return outputBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(output_);
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder addOutputBuilder() {
                return internalGetOutputFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public ProtoOnnx.ValueInfoProto.Builder addOutputBuilder(
                int index) {
                return internalGetOutputFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto output = 12;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder>
            getOutputBuilderList() {
                return internalGetOutputFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
            internalGetOutputFieldBuilder() {
                if (outputBuilder_ == null) {
                    outputBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.ValueInfoProto, ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>(
                        output_,
                        ((bitField0_ & 0x00000040) != 0),
                        getParentForChildren(),
                        isClean());
                    output_ = null;
                }
                return outputBuilder_;
            }
            
            private java.util.List<ProtoOnnx.ValueInfoProto> valueInfo_ =
                java.util.Collections.emptyList();
            private void ensureValueInfoIsMutable() {
                if (!((bitField0_ & 0x00000080) != 0)) {
                    valueInfo_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto>(valueInfo_);
                    bitField0_ |= 0x00000080;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder> valueInfoBuilder_;
            
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> getValueInfoList() {
                if (valueInfoBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(valueInfo_);
                } else {
                    return valueInfoBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public int getValueInfoCount() {
                if (valueInfoBuilder_ == null) {
                    return valueInfo_.size();
                } else {
                    return valueInfoBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getValueInfo(int index) {
                if (valueInfoBuilder_ == null) {
                    return valueInfo_.get(index);
                } else {
                    return valueInfoBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder setValueInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (valueInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureValueInfoIsMutable();
                    valueInfo_.set(index, value);
                    onChanged();
                } else {
                    valueInfoBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder setValueInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    valueInfoBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder addValueInfo(org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (valueInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureValueInfoIsMutable();
                    valueInfo_.add(value);
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder addValueInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (valueInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureValueInfoIsMutable();
                    valueInfo_.add(index, value);
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder addValueInfo(
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.add(builderForValue.build());
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder addValueInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder addAllValueInfo(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> values) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, valueInfo_);
                    onChanged();
                } else {
                    valueInfoBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder clearValueInfo() {
                if (valueInfoBuilder_ == null) {
                    valueInfo_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000080);
                    onChanged();
                } else {
                    valueInfoBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder removeValueInfo(int index) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.remove(index);
                    onChanged();
                } else {
                    valueInfoBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder getValueInfoBuilder(
                int index) {
                return internalGetValueInfoFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
                int index) {
                if (valueInfoBuilder_ == null) {
                    return valueInfo_.get(index);  } else {
                    return valueInfoBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public java.util.List<? extends ProtoOnnx.ValueInfoProtoOrBuilder>
            getValueInfoOrBuilderList() {
                if (valueInfoBuilder_ != null) {
                    return valueInfoBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(valueInfo_);
                }
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder addValueInfoBuilder() {
                return internalGetValueInfoFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder addValueInfoBuilder(
                int index) {
                return internalGetValueInfoFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 13;</code>
             */
            public java.util.List<ProtoOnnx.ValueInfoProto.Builder>
            getValueInfoBuilderList() {
                return internalGetValueInfoFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
            internalGetValueInfoFieldBuilder() {
                if (valueInfoBuilder_ == null) {
                    valueInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.ValueInfoProto, ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>(
                        valueInfo_,
                        ((bitField0_ & 0x00000080) != 0),
                        getParentForChildren(),
                        isClean());
                    valueInfo_ = null;
                }
                return valueInfoBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation> quantizationAnnotation_ =
                java.util.Collections.emptyList();
            private void ensureQuantizationAnnotationIsMutable() {
                if (!((bitField0_ & 0x00000100) != 0)) {
                    quantizationAnnotation_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation>(quantizationAnnotation_);
                    bitField0_ |= 0x00000100;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation, org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotationOrBuilder> quantizationAnnotationBuilder_;
            
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public java.util.List<ProtoOnnx.TensorAnnotation> getQuantizationAnnotationList() {
                if (quantizationAnnotationBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(quantizationAnnotation_);
                } else {
                    return quantizationAnnotationBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public int getQuantizationAnnotationCount() {
                if (quantizationAnnotationBuilder_ == null) {
                    return quantizationAnnotation_.size();
                } else {
                    return quantizationAnnotationBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation getQuantizationAnnotation(int index) {
                if (quantizationAnnotationBuilder_ == null) {
                    return quantizationAnnotation_.get(index);
                } else {
                    return quantizationAnnotationBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder setQuantizationAnnotation(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation value) {
                if (quantizationAnnotationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.set(index, value);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder setQuantizationAnnotation(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder builderForValue) {
                if (quantizationAnnotationBuilder_ == null) {
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder addQuantizationAnnotation(org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation value) {
                if (quantizationAnnotationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.add(value);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder addQuantizationAnnotation(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation value) {
                if (quantizationAnnotationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.add(index, value);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder addQuantizationAnnotation(
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder builderForValue) {
                if (quantizationAnnotationBuilder_ == null) {
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.add(builderForValue.build());
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder addQuantizationAnnotation(
                int index, ProtoOnnx.TensorAnnotation.Builder builderForValue) {
                if (quantizationAnnotationBuilder_ == null) {
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder addAllQuantizationAnnotation(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation> values) {
                if (quantizationAnnotationBuilder_ == null) {
                    ensureQuantizationAnnotationIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, quantizationAnnotation_);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder clearQuantizationAnnotation() {
                if (quantizationAnnotationBuilder_ == null) {
                    quantizationAnnotation_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000100);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder removeQuantizationAnnotation(int index) {
                if (quantizationAnnotationBuilder_ == null) {
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.remove(index);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder getQuantizationAnnotationBuilder(
                int index) {
                return internalGetQuantizationAnnotationFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(
                int index) {
                if (quantizationAnnotationBuilder_ == null) {
                    return quantizationAnnotation_.get(index);  } else {
                    return quantizationAnnotationBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotationOrBuilder>
            getQuantizationAnnotationOrBuilderList() {
                if (quantizationAnnotationBuilder_ != null) {
                    return quantizationAnnotationBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(quantizationAnnotation_);
                }
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder addQuantizationAnnotationBuilder() {
                return internalGetQuantizationAnnotationFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.getDefaultInstance());
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder addQuantizationAnnotationBuilder(
                int index) {
                return internalGetQuantizationAnnotationFieldBuilder().addBuilder(
                    index, ProtoOnnx.TensorAnnotation.getDefaultInstance());
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder>
            getQuantizationAnnotationBuilderList() {
                return internalGetQuantizationAnnotationFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation, org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder, ProtoOnnx.TensorAnnotationOrBuilder>
            internalGetQuantizationAnnotationFieldBuilder() {
                if (quantizationAnnotationBuilder_ == null) {
                    quantizationAnnotationBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation, org.brain4j.core.importing.onnx.ProtoOnnx.TensorAnnotation.Builder, ProtoOnnx.TensorAnnotationOrBuilder>(
                        quantizationAnnotation_,
                        ((bitField0_ & 0x00000100) != 0),
                        getParentForChildren(),
                        isClean());
                    quantizationAnnotation_ = null;
                }
                return quantizationAnnotationBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> metadataProps_ =
                java.util.Collections.emptyList();
            private void ensureMetadataPropsIsMutable() {
                if (!((bitField0_ & 0x00000200) != 0)) {
                    metadataProps_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>(metadataProps_);
                    bitField0_ |= 0x00000200;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;
            
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
                if (metadataPropsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                } else {
                    return metadataPropsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public int getMetadataPropsCount() {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.size();
                } else {
                    return metadataPropsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);
                } else {
                    return metadataPropsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder setMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder setMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder addMetadataProps(org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder addMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder addMetadataProps(
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder addMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder addAllMetadataProps(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> values) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, metadataProps_);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder clearMetadataProps() {
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000200);
                    onChanged();
                } else {
                    metadataPropsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder removeMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.remove(index);
                    onChanged();
                } else {
                    metadataPropsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
                int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);  } else {
                    return metadataPropsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            getMetadataPropsOrBuilderList() {
                if (metadataPropsBuilder_ != null) {
                    return metadataPropsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder>
            getMetadataPropsBuilderList() {
                return internalGetMetadataPropsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            internalGetMetadataPropsFieldBuilder() {
                if (metadataPropsBuilder_ == null) {
                    metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>(
                        metadataProps_,
                        ((bitField0_ & 0x00000200) != 0),
                        getParentForChildren(),
                        isClean());
                    metadataProps_ = null;
                }
                return metadataPropsBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.GraphProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.GraphProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<GraphProto>
            PARSER = new com.google.protobuf.AbstractParser<GraphProto>() {
            @java.lang.Override
            public GraphProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<GraphProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<GraphProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.GraphProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface TensorProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TensorProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @return A list containing the dims.
         */
        java.util.List<java.lang.Long> getDimsList();
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @return The count of dims.
         */
        int getDimsCount();
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @param index The index of the element to return.
         * @return The dims at the given index.
         */
        long getDims(int index);
        
        /**
         * <pre>
         * The data type of the tensor.
         * This field MUST have a valid TensorProto.DataType value
         * </pre>
         *
         * <code>optional int32 data_type = 2;</code>
         * @return Whether the dataType field is set.
         */
        boolean hasDataType();
        /**
         * <pre>
         * The data type of the tensor.
         * This field MUST have a valid TensorProto.DataType value
         * </pre>
         *
         * <code>optional int32 data_type = 2;</code>
         * @return The dataType.
         */
        int getDataType();
        
        /**
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
         * @return Whether the segment field is set.
         */
        boolean hasSegment();
        /**
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
         * @return The segment.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment getSegment();
        /**
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.SegmentOrBuilder getSegmentOrBuilder();
        
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @return A list containing the floatData.
         */
        java.util.List<java.lang.Float> getFloatDataList();
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @return The count of floatData.
         */
        int getFloatDataCount();
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The floatData at the given index.
         */
        float getFloatData(int index);
        
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
         * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
         * representation before being written to the buffer.
         * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
         * The first element is stored in the 4 least significant bits (LSB),
         * and the second element is stored in the 4 most significant bits (MSB).
         *
         * Consequently:
         * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
         * - For 4-bit data types, each `int32_data` stores two elements.
         *
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @return A list containing the int32Data.
         */
        java.util.List<java.lang.Integer> getInt32DataList();
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
         * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
         * representation before being written to the buffer.
         * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
         * The first element is stored in the 4 least significant bits (LSB),
         * and the second element is stored in the 4 most significant bits (MSB).
         *
         * Consequently:
         * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
         * - For 4-bit data types, each `int32_data` stores two elements.
         *
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @return The count of int32Data.
         */
        int getInt32DataCount();
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
         * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
         * representation before being written to the buffer.
         * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
         * The first element is stored in the 4 least significant bits (LSB),
         * and the second element is stored in the 4 most significant bits (MSB).
         *
         * Consequently:
         * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
         * - For 4-bit data types, each `int32_data` stores two elements.
         *
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The int32Data at the given index.
         */
        int getInt32Data(int index);
        
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @return A list containing the stringData.
         */
        java.util.List<com.google.protobuf.ByteString> getStringDataList();
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @return The count of stringData.
         */
        int getStringDataCount();
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @param index The index of the element to return.
         * @return The stringData at the given index.
         */
        com.google.protobuf.ByteString getStringData(int index);
        
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @return A list containing the int64Data.
         */
        java.util.List<java.lang.Long> getInt64DataList();
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @return The count of int64Data.
         */
        int getInt64DataCount();
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The int64Data at the given index.
         */
        long getInt64Data(int index);
        
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();
        
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();
        
        /**
         * <pre>
         * Serializations can either use one of the fields above, or use this
         * raw bytes field. The only exception is the string case, where one is
         * required to store the content in the repeated bytes string_data field.
         *
         * When this raw_data field is used to store tensor value, elements MUST
         * be stored in as fixed-width, little-endian order.
         * Floating-point data types MUST be stored in IEEE 754 format.
         * Complex64 elements must be written as two consecutive FLOAT values, real component first.
         * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
         * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
         * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
         *
         * Note: the advantage of specific field rather than the raw_data field is
         * that in some cases (e.g. int data), protobuf does a better packing via
         * variable length storage, and may lead to smaller binary footprint.
         * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
         * </pre>
         *
         * <code>optional bytes raw_data = 9;</code>
         * @return Whether the rawData field is set.
         */
        boolean hasRawData();
        /**
         * <pre>
         * Serializations can either use one of the fields above, or use this
         * raw bytes field. The only exception is the string case, where one is
         * required to store the content in the repeated bytes string_data field.
         *
         * When this raw_data field is used to store tensor value, elements MUST
         * be stored in as fixed-width, little-endian order.
         * Floating-point data types MUST be stored in IEEE 754 format.
         * Complex64 elements must be written as two consecutive FLOAT values, real component first.
         * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
         * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
         * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
         *
         * Note: the advantage of specific field rather than the raw_data field is
         * that in some cases (e.g. int data), protobuf does a better packing via
         * variable length storage, and may lead to smaller binary footprint.
         * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
         * </pre>
         *
         * <code>optional bytes raw_data = 9;</code>
         * @return The rawData.
         */
        com.google.protobuf.ByteString getRawData();
        
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         * protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>
        getExternalDataList();
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         * protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getExternalData(int index);
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         * protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
         */
        int getExternalDataCount();
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         * protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getExternalDataOrBuilderList();
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         * protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
         */
        ProtoOnnx.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
            int index);
        
        /**
         * <pre>
         * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto.DataLocation data_location = 14;</code>
         * @return Whether the dataLocation field is set.
         */
        boolean hasDataLocation();
        /**
         * <pre>
         * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto.DataLocation data_location = 14;</code>
         * @return The dataLocation.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation getDataLocation();
        
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @return A list containing the doubleData.
         */
        java.util.List<java.lang.Double> getDoubleDataList();
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @return The count of doubleData.
         */
        int getDoubleDataCount();
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The doubleData at the given index.
         */
        double getDoubleData(int index);
        
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @return A list containing the uint64Data.
         */
        java.util.List<java.lang.Long> getUint64DataList();
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @return The count of uint64Data.
         */
        int getUint64DataCount();
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The uint64Data at the given index.
         */
        long getUint64Data(int index);
        
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>
        getMetadataPropsList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index);
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        int getMetadataPropsCount();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index);
    }
    /**
     * <pre>
     * Tensors
     *
     * A serialized tensor value.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.TensorProto}
     */
    public static final class TensorProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TensorProto)
        TensorProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                TensorProto.class.getName());
        }
        // Use TensorProto.newBuilder() to construct.
        private TensorProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private TensorProto() {
            dims_ = emptyLongList();
            floatData_ = emptyFloatList();
            int32Data_ = emptyIntList();
            stringData_ = emptyList(com.google.protobuf.ByteString.class);
            int64Data_ = emptyLongList();
            name_ = "";
            docString_ = "";
            rawData_ = com.google.protobuf.ByteString.EMPTY;
            externalData_ = java.util.Collections.emptyList();
            dataLocation_ = 0;
            doubleData_ = emptyDoubleList();
            uint64Data_ = emptyLongList();
            metadataProps_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ProtoOnnx.internal_static_onnx_TensorProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    ProtoOnnx.TensorProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder.class);
        }
        
        /**
         * Protobuf enum {@code org.brain4j.core.importing.onnx.TensorProto.DataType}
         */
        public enum DataType
            implements com.google.protobuf.ProtocolMessageEnum {
            /**
             * <code>UNDEFINED = 0;</code>
             */
            UNDEFINED(0),
            /**
             * <pre>
             * Basic types.
             * </pre>
             *
             * <code>FLOAT = 1;</code>
             */
            FLOAT(1),
            /**
             * <pre>
             * uint8_t
             * </pre>
             *
             * <code>UINT8 = 2;</code>
             */
            UINT8(2),
            /**
             * <pre>
             * int8_t
             * </pre>
             *
             * <code>INT8 = 3;</code>
             */
            INT8(3),
            /**
             * <pre>
             * uint16_t
             * </pre>
             *
             * <code>UINT16 = 4;</code>
             */
            UINT16(4),
            /**
             * <pre>
             * int16_t
             * </pre>
             *
             * <code>INT16 = 5;</code>
             */
            INT16(5),
            /**
             * <pre>
             * int32_t
             * </pre>
             *
             * <code>INT32 = 6;</code>
             */
            INT32(6),
            /**
             * <pre>
             * int64_t
             * </pre>
             *
             * <code>INT64 = 7;</code>
             */
            INT64(7),
            /**
             * <pre>
             * string
             * </pre>
             *
             * <code>STRING = 8;</code>
             */
            STRING(8),
            /**
             * <pre>
             * bool
             * </pre>
             *
             * <code>BOOL = 9;</code>
             */
            BOOL(9),
            /**
             * <pre>
             * IEEE754 half-precision floating-point format (16 bits wide).
             * This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
             * </pre>
             *
             * <code>FLOAT16 = 10;</code>
             */
            FLOAT16(10),
            /**
             * <code>DOUBLE = 11;</code>
             */
            DOUBLE(11),
            /**
             * <code>UINT32 = 12;</code>
             */
            UINT32(12),
            /**
             * <code>UINT64 = 13;</code>
             */
            UINT64(13),
            /**
             * <pre>
             * complex with float32 real and imaginary components
             * </pre>
             *
             * <code>COMPLEX64 = 14;</code>
             */
            COMPLEX64(14),
            /**
             * <pre>
             * complex with float64 real and imaginary components
             * </pre>
             *
             * <code>COMPLEX128 = 15;</code>
             */
            COMPLEX128(15),
            /**
             * <pre>
             * Non-IEEE floating-point format based on IEEE754 single-precision
             * floating-point number truncated to 16 bits.
             * This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
             * </pre>
             *
             * <code>BFLOAT16 = 16;</code>
             */
            BFLOAT16(16),
            /**
             * <pre>
             * Non-IEEE floating-point format based on papers
             * FP8 Formats for Deep Learning, https://arxiv.org/abs/2209.05433,
             * 8-bit Numerical Formats For Deep Neural Networks, https://arxiv.org/pdf/2206.02915.pdf.
             * Operators supported FP8 are Cast, CastLike, QuantizeLinear, DequantizeLinear.
             * The computation usually happens inside a block quantize / dequantize
             * fused by the runtime.
             * </pre>
             *
             * <code>FLOAT8E4M3FN = 17;</code>
             */
            FLOAT8E4M3FN(17),
            /**
             * <pre>
             * float 8, mostly used for coefficients, supports nan, not inf, no negative zero
             * </pre>
             *
             * <code>FLOAT8E4M3FNUZ = 18;</code>
             */
            FLOAT8E4M3FNUZ(18),
            /**
             * <pre>
             * follows IEEE 754, supports nan, inf, mostly used for gradients
             * </pre>
             *
             * <code>FLOAT8E5M2 = 19;</code>
             */
            FLOAT8E5M2(19),
            /**
             * <pre>
             * follows IEEE 754, supports nan, not inf, mostly used for gradients, no negative zero
             * </pre>
             *
             * <code>FLOAT8E5M2FNUZ = 20;</code>
             */
            FLOAT8E5M2FNUZ(20),
            /**
             * <pre>
             * 4-bit integer data types
             * </pre>
             *
             * <code>UINT4 = 21;</code>
             */
            UINT4(21),
            /**
             * <pre>
             * Signed integer in range [-8, 7], using two's-complement representation
             * </pre>
             *
             * <code>INT4 = 22;</code>
             */
            INT4(22),
            /**
             * <pre>
             * 4-bit floating point data types
             * </pre>
             *
             * <code>FLOAT4E2M1 = 23;</code>
             */
            FLOAT4E2M1(23),
            ;
            
            static {
                com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                    com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 31,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    DataType.class.getName());
            }
            /**
             * <code>UNDEFINED = 0;</code>
             */
            public static final int UNDEFINED_VALUE = 0;
            /**
             * <pre>
             * Basic types.
             * </pre>
             *
             * <code>FLOAT = 1;</code>
             */
            public static final int FLOAT_VALUE = 1;
            /**
             * <pre>
             * uint8_t
             * </pre>
             *
             * <code>UINT8 = 2;</code>
             */
            public static final int UINT8_VALUE = 2;
            /**
             * <pre>
             * int8_t
             * </pre>
             *
             * <code>INT8 = 3;</code>
             */
            public static final int INT8_VALUE = 3;
            /**
             * <pre>
             * uint16_t
             * </pre>
             *
             * <code>UINT16 = 4;</code>
             */
            public static final int UINT16_VALUE = 4;
            /**
             * <pre>
             * int16_t
             * </pre>
             *
             * <code>INT16 = 5;</code>
             */
            public static final int INT16_VALUE = 5;
            /**
             * <pre>
             * int32_t
             * </pre>
             *
             * <code>INT32 = 6;</code>
             */
            public static final int INT32_VALUE = 6;
            /**
             * <pre>
             * int64_t
             * </pre>
             *
             * <code>INT64 = 7;</code>
             */
            public static final int INT64_VALUE = 7;
            /**
             * <pre>
             * string
             * </pre>
             *
             * <code>STRING = 8;</code>
             */
            public static final int STRING_VALUE = 8;
            /**
             * <pre>
             * bool
             * </pre>
             *
             * <code>BOOL = 9;</code>
             */
            public static final int BOOL_VALUE = 9;
            /**
             * <pre>
             * IEEE754 half-precision floating-point format (16 bits wide).
             * This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
             * </pre>
             *
             * <code>FLOAT16 = 10;</code>
             */
            public static final int FLOAT16_VALUE = 10;
            /**
             * <code>DOUBLE = 11;</code>
             */
            public static final int DOUBLE_VALUE = 11;
            /**
             * <code>UINT32 = 12;</code>
             */
            public static final int UINT32_VALUE = 12;
            /**
             * <code>UINT64 = 13;</code>
             */
            public static final int UINT64_VALUE = 13;
            /**
             * <pre>
             * complex with float32 real and imaginary components
             * </pre>
             *
             * <code>COMPLEX64 = 14;</code>
             */
            public static final int COMPLEX64_VALUE = 14;
            /**
             * <pre>
             * complex with float64 real and imaginary components
             * </pre>
             *
             * <code>COMPLEX128 = 15;</code>
             */
            public static final int COMPLEX128_VALUE = 15;
            /**
             * <pre>
             * Non-IEEE floating-point format based on IEEE754 single-precision
             * floating-point number truncated to 16 bits.
             * This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
             * </pre>
             *
             * <code>BFLOAT16 = 16;</code>
             */
            public static final int BFLOAT16_VALUE = 16;
            /**
             * <pre>
             * Non-IEEE floating-point format based on papers
             * FP8 Formats for Deep Learning, https://arxiv.org/abs/2209.05433,
             * 8-bit Numerical Formats For Deep Neural Networks, https://arxiv.org/pdf/2206.02915.pdf.
             * Operators supported FP8 are Cast, CastLike, QuantizeLinear, DequantizeLinear.
             * The computation usually happens inside a block quantize / dequantize
             * fused by the runtime.
             * </pre>
             *
             * <code>FLOAT8E4M3FN = 17;</code>
             */
            public static final int FLOAT8E4M3FN_VALUE = 17;
            /**
             * <pre>
             * float 8, mostly used for coefficients, supports nan, not inf, no negative zero
             * </pre>
             *
             * <code>FLOAT8E4M3FNUZ = 18;</code>
             */
            public static final int FLOAT8E4M3FNUZ_VALUE = 18;
            /**
             * <pre>
             * follows IEEE 754, supports nan, inf, mostly used for gradients
             * </pre>
             *
             * <code>FLOAT8E5M2 = 19;</code>
             */
            public static final int FLOAT8E5M2_VALUE = 19;
            /**
             * <pre>
             * follows IEEE 754, supports nan, not inf, mostly used for gradients, no negative zero
             * </pre>
             *
             * <code>FLOAT8E5M2FNUZ = 20;</code>
             */
            public static final int FLOAT8E5M2FNUZ_VALUE = 20;
            /**
             * <pre>
             * 4-bit integer data types
             * </pre>
             *
             * <code>UINT4 = 21;</code>
             */
            public static final int UINT4_VALUE = 21;
            /**
             * <pre>
             * Signed integer in range [-8, 7], using two's-complement representation
             * </pre>
             *
             * <code>INT4 = 22;</code>
             */
            public static final int INT4_VALUE = 22;
            /**
             * <pre>
             * 4-bit floating point data types
             * </pre>
             *
             * <code>FLOAT4E2M1 = 23;</code>
             */
            public static final int FLOAT4E2M1_VALUE = 23;
            
            
            public final int getNumber() {
                return value;
            }
            
            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             * @deprecated Use {@link #forNumber(int)} instead.
             */
            @java.lang.Deprecated
            public static DataType valueOf(int value) {
                return forNumber(value);
            }
            
            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             */
            public static DataType forNumber(int value) {
                switch (value) {
                    case 0: return UNDEFINED;
                    case 1: return FLOAT;
                    case 2: return UINT8;
                    case 3: return INT8;
                    case 4: return UINT16;
                    case 5: return INT16;
                    case 6: return INT32;
                    case 7: return INT64;
                    case 8: return STRING;
                    case 9: return BOOL;
                    case 10: return FLOAT16;
                    case 11: return DOUBLE;
                    case 12: return UINT32;
                    case 13: return UINT64;
                    case 14: return COMPLEX64;
                    case 15: return COMPLEX128;
                    case 16: return BFLOAT16;
                    case 17: return FLOAT8E4M3FN;
                    case 18: return FLOAT8E4M3FNUZ;
                    case 19: return FLOAT8E5M2;
                    case 20: return FLOAT8E5M2FNUZ;
                    case 21: return UINT4;
                    case 22: return INT4;
                    case 23: return FLOAT4E2M1;
                    default: return null;
                }
            }
            
            public static com.google.protobuf.Internal.EnumLiteMap<DataType>
            internalGetValueMap() {
                return internalValueMap;
            }
            private static final com.google.protobuf.Internal.EnumLiteMap<
                DataType> internalValueMap =
                new com.google.protobuf.Internal.EnumLiteMap<DataType>() {
                    public DataType findValueByNumber(int number) {
                        return DataType.forNumber(number);
                    }
                };
            
            public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
                return getDescriptor().getValues().get(ordinal());
            }
            public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
                return getDescriptor();
            }
            public static com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDescriptor().getEnumTypes().get(0);
            }
            
            private static final DataType[] VALUES = values();
            
            public static DataType valueOf(
                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
                if (desc.getType() != getDescriptor()) {
                    throw new java.lang.IllegalArgumentException(
                        "EnumValueDescriptor is not for this type.");
                }
                return VALUES[desc.getIndex()];
            }
            
            private final int value;
            
            private DataType(int value) {
                this.value = value;
            }
            
            // @@protoc_insertion_point(enum_scope:org.brain4j.core.importing.onnx.TensorProto.DataType)
        }
        
        /**
         * <pre>
         * Location of the data for this tensor. MUST be one of:
         * - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
         * - EXTERNAL - data stored in an external location as described by external_data field.
         * </pre>
         *
         * Protobuf enum {@code org.brain4j.core.importing.onnx.TensorProto.DataLocation}
         */
        public enum DataLocation
            implements com.google.protobuf.ProtocolMessageEnum {
            /**
             * <code>DEFAULT = 0;</code>
             */
            DEFAULT(0),
            /**
             * <code>EXTERNAL = 1;</code>
             */
            EXTERNAL(1),
            ;
            
            static {
                com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                    com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 31,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    DataLocation.class.getName());
            }
            /**
             * <code>DEFAULT = 0;</code>
             */
            public static final int DEFAULT_VALUE = 0;
            /**
             * <code>EXTERNAL = 1;</code>
             */
            public static final int EXTERNAL_VALUE = 1;
            
            
            public final int getNumber() {
                return value;
            }
            
            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             * @deprecated Use {@link #forNumber(int)} instead.
             */
            @java.lang.Deprecated
            public static DataLocation valueOf(int value) {
                return forNumber(value);
            }
            
            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             */
            public static DataLocation forNumber(int value) {
                switch (value) {
                    case 0: return DEFAULT;
                    case 1: return EXTERNAL;
                    default: return null;
                }
            }
            
            public static com.google.protobuf.Internal.EnumLiteMap<DataLocation>
            internalGetValueMap() {
                return internalValueMap;
            }
            private static final com.google.protobuf.Internal.EnumLiteMap<
                DataLocation> internalValueMap =
                new com.google.protobuf.Internal.EnumLiteMap<DataLocation>() {
                    public DataLocation findValueByNumber(int number) {
                        return DataLocation.forNumber(number);
                    }
                };
            
            public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
                return getDescriptor().getValues().get(ordinal());
            }
            public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
                return getDescriptor();
            }
            public static com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDescriptor().getEnumTypes().get(1);
            }
            
            private static final DataLocation[] VALUES = values();
            
            public static DataLocation valueOf(
                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
                if (desc.getType() != getDescriptor()) {
                    throw new java.lang.IllegalArgumentException(
                        "EnumValueDescriptor is not for this type.");
                }
                return VALUES[desc.getIndex()];
            }
            
            private final int value;
            
            private DataLocation(int value) {
                this.value = value;
            }
            
            // @@protoc_insertion_point(enum_scope:org.brain4j.core.importing.onnx.TensorProto.DataLocation)
        }
        
        public interface SegmentOrBuilder extends
            // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TensorProto.Segment)
            com.google.protobuf.MessageOrBuilder {
            
            /**
             * <code>optional int64 begin = 1;</code>
             * @return Whether the begin field is set.
             */
            boolean hasBegin();
            /**
             * <code>optional int64 begin = 1;</code>
             * @return The begin.
             */
            long getBegin();
            
            /**
             * <code>optional int64 end = 2;</code>
             * @return Whether the end field is set.
             */
            boolean hasEnd();
            /**
             * <code>optional int64 end = 2;</code>
             * @return The end.
             */
            long getEnd();
        }
        /**
         * <pre>
         * For very large tensors, we may want to store them in chunks, in which
         * case the following fields will specify the segment that is stored in
         * the current TensorProto.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.TensorProto.Segment}
         */
        public static final class Segment extends
            com.google.protobuf.GeneratedMessage implements
            // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TensorProto.Segment)
            SegmentOrBuilder {
            private static final long serialVersionUID = 0L;
            static {
                com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                    com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 31,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    Segment.class.getName());
            }
            // Use Segment.newBuilder() to construct.
            private Segment(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
                super(builder);
            }
            private Segment() {
            }
            
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ProtoOnnx.internal_static_onnx_TensorProto_Segment_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorProto_Segment_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.class, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.Builder.class);
            }
            
            private int bitField0_;
            public static final int BEGIN_FIELD_NUMBER = 1;
            private long begin_ = 0L;
            /**
             * <code>optional int64 begin = 1;</code>
             * @return Whether the begin field is set.
             */
            @java.lang.Override
            public boolean hasBegin() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <code>optional int64 begin = 1;</code>
             * @return The begin.
             */
            @java.lang.Override
            public long getBegin() {
                return begin_;
            }
            
            public static final int END_FIELD_NUMBER = 2;
            private long end_ = 0L;
            /**
             * <code>optional int64 end = 2;</code>
             * @return Whether the end field is set.
             */
            @java.lang.Override
            public boolean hasEnd() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <code>optional int64 end = 2;</code>
             * @return The end.
             */
            @java.lang.Override
            public long getEnd() {
                return end_;
            }
            
            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;
                
                memoizedIsInitialized = 1;
                return true;
            }
            
            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeInt64(1, begin_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    output.writeInt64(2, end_);
                }
                getUnknownFields().writeTo(output);
            }
            
            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;
                
                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt64Size(1, begin_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt64Size(2, end_);
                }
                size += getUnknownFields().getSerializedSize();
                memoizedSize = size;
                return size;
            }
            
            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof ProtoOnnx.TensorProto.Segment)) {
                    return super.equals(obj);
                }
                ProtoOnnx.TensorProto.Segment other = (org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment) obj;
                
                if (hasBegin() != other.hasBegin()) return false;
                if (hasBegin()) {
                    if (getBegin()
                        != other.getBegin()) return false;
                }
                if (hasEnd() != other.hasEnd()) return false;
                if (hasEnd()) {
                    if (getEnd()
                        != other.getEnd()) return false;
                }
                if (!getUnknownFields().equals(other.getUnknownFields())) return false;
                return true;
            }
            
            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasBegin()) {
                    hash = (37 * hash) + BEGIN_FIELD_NUMBER;
                    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                        getBegin());
                }
                if (hasEnd()) {
                    hash = (37 * hash) + END_FIELD_NUMBER;
                    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                        getEnd());
                }
                hash = (29 * hash) + getUnknownFields().hashCode();
                memoizedHashCode = hash;
                return hash;
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ProtoOnnx.TensorProto.Segment parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment parseFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static ProtoOnnx.TensorProto.Segment parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            public static ProtoOnnx.TensorProto.Segment parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
            }
            
            @java.lang.Override
            protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * <pre>
             * For very large tensors, we may want to store them in chunks, in which
             * case the following fields will specify the segment that is stored in
             * the current TensorProto.
             * </pre>
             *
             * Protobuf type {@code org.brain4j.core.importing.onnx.TensorProto.Segment}
             */
            public static final class Builder extends
                com.google.protobuf.GeneratedMessage.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TensorProto.Segment)
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.SegmentOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorProto_Segment_descriptor;
                }
                
                @java.lang.Override
                protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorProto_Segment_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                            org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.class, ProtoOnnx.TensorProto.Segment.Builder.class);
                }
                
                // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.newBuilder()
                private Builder() {
                
                }
                
                private Builder(
                    com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                    super(parent);
                    
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    bitField0_ = 0;
                    begin_ = 0L;
                    end_ = 0L;
                    return this;
                }
                
                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorProto_Segment_descriptor;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment getDefaultInstanceForType() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.getDefaultInstance();
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment build() {
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }
                
                @java.lang.Override
                public ProtoOnnx.TensorProto.Segment buildPartial() {
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment result = new org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment(this);
                    if (bitField0_ != 0) { buildPartial0(result); }
                    onBuilt();
                    return result;
                }
                
                private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment result) {
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        result.begin_ = begin_;
                        to_bitField0_ |= 0x00000001;
                    }
                    if (((from_bitField0_ & 0x00000002) != 0)) {
                        result.end_ = end_;
                        to_bitField0_ |= 0x00000002;
                    }
                    result.bitField0_ |= to_bitField0_;
                }
                
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment) {
                        return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }
                
                public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment other) {
                    if (other == org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.getDefaultInstance()) return this;
                    if (other.hasBegin()) {
                        setBegin(other.getBegin());
                    }
                    if (other.hasEnd()) {
                        setEnd(other.getEnd());
                    }
                    this.mergeUnknownFields(other.getUnknownFields());
                    onChanged();
                    return this;
                }
                
                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }
                
                @java.lang.Override
                public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                    if (extensionRegistry == null) {
                        throw new java.lang.NullPointerException();
                    }
                    try {
                        boolean done = false;
                        while (!done) {
                            int tag = input.readTag();
                            switch (tag) {
                                case 0:
                                    done = true;
                                    break;
                                case 8: {
                                    begin_ = input.readInt64();
                                    bitField0_ |= 0x00000001;
                                    break;
                                } // case 8
                                case 16: {
                                    end_ = input.readInt64();
                                    bitField0_ |= 0x00000002;
                                    break;
                                } // case 16
                                default: {
                                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                        done = true; // was an endgroup tag
                                    }
                                    break;
                                } // default:
                            } // switch (tag)
                        } // while (!done)
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.unwrapIOException();
                    } finally {
                        onChanged();
                    } // finally
                    return this;
                }
                private int bitField0_;
                
                private long begin_ ;
                /**
                 * <code>optional int64 begin = 1;</code>
                 * @return Whether the begin field is set.
                 */
                @java.lang.Override
                public boolean hasBegin() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <code>optional int64 begin = 1;</code>
                 * @return The begin.
                 */
                @java.lang.Override
                public long getBegin() {
                    return begin_;
                }
                /**
                 * <code>optional int64 begin = 1;</code>
                 * @param value The begin to set.
                 * @return This builder for chaining.
                 */
                public Builder setBegin(long value) {
                    
                    begin_ = value;
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }
                /**
                 * <code>optional int64 begin = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearBegin() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    begin_ = 0L;
                    onChanged();
                    return this;
                }
                
                private long end_ ;
                /**
                 * <code>optional int64 end = 2;</code>
                 * @return Whether the end field is set.
                 */
                @java.lang.Override
                public boolean hasEnd() {
                    return ((bitField0_ & 0x00000002) != 0);
                }
                /**
                 * <code>optional int64 end = 2;</code>
                 * @return The end.
                 */
                @java.lang.Override
                public long getEnd() {
                    return end_;
                }
                /**
                 * <code>optional int64 end = 2;</code>
                 * @param value The end to set.
                 * @return This builder for chaining.
                 */
                public Builder setEnd(long value) {
                    
                    end_ = value;
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return this;
                }
                /**
                 * <code>optional int64 end = 2;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearEnd() {
                    bitField0_ = (bitField0_ & ~0x00000002);
                    end_ = 0L;
                    onChanged();
                    return this;
                }
                
                // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TensorProto.Segment)
            }
            
            // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TensorProto.Segment)
            private static final ProtoOnnx.TensorProto.Segment DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new ProtoOnnx.TensorProto.Segment();
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }
            
            private static final com.google.protobuf.Parser<Segment>
                PARSER = new com.google.protobuf.AbstractParser<Segment>() {
                @java.lang.Override
                public Segment parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                    Builder builder = newBuilder();
                    try {
                        builder.mergeFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.setUnfinishedMessage(builder.buildPartial());
                    } catch (com.google.protobuf.UninitializedMessageException e) {
                        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                    } catch (java.io.IOException e) {
                        throw new com.google.protobuf.InvalidProtocolBufferException(e)
                            .setUnfinishedMessage(builder.buildPartial());
                    }
                    return builder.buildPartial();
                }
            };
            
            public static com.google.protobuf.Parser<Segment> parser() {
                return PARSER;
            }
            
            @java.lang.Override
            public com.google.protobuf.Parser<Segment> getParserForType() {
                return PARSER;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }
            
        }
        
        private int bitField0_;
        public static final int DIMS_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.LongList dims_ =
            emptyLongList();
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @return A list containing the dims.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getDimsList() {
            return dims_;
        }
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @return The count of dims.
         */
        public int getDimsCount() {
            return dims_.size();
        }
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @param index The index of the element to return.
         * @return The dims at the given index.
         */
        public long getDims(int index) {
            return dims_.getLong(index);
        }
        
        public static final int DATA_TYPE_FIELD_NUMBER = 2;
        private int dataType_ = 0;
        /**
         * <pre>
         * The data type of the tensor.
         * This field MUST have a valid TensorProto.DataType value
         * </pre>
         *
         * <code>optional int32 data_type = 2;</code>
         * @return Whether the dataType field is set.
         */
        @java.lang.Override
        public boolean hasDataType() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The data type of the tensor.
         * This field MUST have a valid TensorProto.DataType value
         * </pre>
         *
         * <code>optional int32 data_type = 2;</code>
         * @return The dataType.
         */
        @java.lang.Override
        public int getDataType() {
            return dataType_;
        }
        
        public static final int SEGMENT_FIELD_NUMBER = 3;
        private org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment segment_;
        /**
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
         * @return Whether the segment field is set.
         */
        @java.lang.Override
        public boolean hasSegment() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
         * @return The segment.
         */
        @java.lang.Override
        public ProtoOnnx.TensorProto.Segment getSegment() {
            return segment_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.getDefaultInstance() : segment_;
        }
        /**
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
         */
        @java.lang.Override
        public ProtoOnnx.TensorProto.SegmentOrBuilder getSegmentOrBuilder() {
            return segment_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.getDefaultInstance() : segment_;
        }
        
        public static final int FLOAT_DATA_FIELD_NUMBER = 4;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.FloatList floatData_ =
            emptyFloatList();
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @return A list containing the floatData.
         */
        @java.lang.Override
        public java.util.List<java.lang.Float>
        getFloatDataList() {
            return floatData_;
        }
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @return The count of floatData.
         */
        public int getFloatDataCount() {
            return floatData_.size();
        }
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The floatData at the given index.
         */
        public float getFloatData(int index) {
            return floatData_.getFloat(index);
        }
        private int floatDataMemoizedSerializedSize = -1;
        
        public static final int INT32_DATA_FIELD_NUMBER = 5;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.IntList int32Data_ =
            emptyIntList();
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
         * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
         * representation before being written to the buffer.
         * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
         * The first element is stored in the 4 least significant bits (LSB),
         * and the second element is stored in the 4 most significant bits (MSB).
         *
         * Consequently:
         * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
         * - For 4-bit data types, each `int32_data` stores two elements.
         *
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @return A list containing the int32Data.
         */
        @java.lang.Override
        public java.util.List<java.lang.Integer>
        getInt32DataList() {
            return int32Data_;
        }
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
         * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
         * representation before being written to the buffer.
         * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
         * The first element is stored in the 4 least significant bits (LSB),
         * and the second element is stored in the 4 most significant bits (MSB).
         *
         * Consequently:
         * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
         * - For 4-bit data types, each `int32_data` stores two elements.
         *
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @return The count of int32Data.
         */
        public int getInt32DataCount() {
            return int32Data_.size();
        }
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
         * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
         * representation before being written to the buffer.
         * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
         * The first element is stored in the 4 least significant bits (LSB),
         * and the second element is stored in the 4 most significant bits (MSB).
         *
         * Consequently:
         * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
         * - For 4-bit data types, each `int32_data` stores two elements.
         *
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The int32Data at the given index.
         */
        public int getInt32Data(int index) {
            return int32Data_.getInt(index);
        }
        private int int32DataMemoizedSerializedSize = -1;
        
        public static final int STRING_DATA_FIELD_NUMBER = 6;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> stringData_ =
            emptyList(com.google.protobuf.ByteString.class);
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @return A list containing the stringData.
         */
        @java.lang.Override
        public java.util.List<com.google.protobuf.ByteString>
        getStringDataList() {
            return stringData_;
        }
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @return The count of stringData.
         */
        public int getStringDataCount() {
            return stringData_.size();
        }
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @param index The index of the element to return.
         * @return The stringData at the given index.
         */
        public com.google.protobuf.ByteString getStringData(int index) {
            return stringData_.get(index);
        }
        
        public static final int INT64_DATA_FIELD_NUMBER = 7;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.LongList int64Data_ =
            emptyLongList();
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @return A list containing the int64Data.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getInt64DataList() {
            return int64Data_;
        }
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @return The count of int64Data.
         */
        public int getInt64DataCount() {
            return int64Data_.size();
        }
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The int64Data at the given index.
         */
        public long getInt64Data(int index) {
            return int64Data_.getLong(index);
        }
        private int int64DataMemoizedSerializedSize = -1;
        
        public static final int NAME_FIELD_NUMBER = 8;
        @SuppressWarnings("serial")
        private volatile java.lang.Object name_ = "";
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int DOC_STRING_FIELD_NUMBER = 12;
        @SuppressWarnings("serial")
        private volatile java.lang.Object docString_ = "";
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int RAW_DATA_FIELD_NUMBER = 9;
        private com.google.protobuf.ByteString rawData_ = com.google.protobuf.ByteString.EMPTY;
        /**
         * <pre>
         * Serializations can either use one of the fields above, or use this
         * raw bytes field. The only exception is the string case, where one is
         * required to store the content in the repeated bytes string_data field.
         *
         * When this raw_data field is used to store tensor value, elements MUST
         * be stored in as fixed-width, little-endian order.
         * Floating-point data types MUST be stored in IEEE 754 format.
         * Complex64 elements must be written as two consecutive FLOAT values, real component first.
         * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
         * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
         * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
         *
         * Note: the advantage of specific field rather than the raw_data field is
         * that in some cases (e.g. int data), protobuf does a better packing via
         * variable length storage, and may lead to smaller binary footprint.
         * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
         * </pre>
         *
         * <code>optional bytes raw_data = 9;</code>
         * @return Whether the rawData field is set.
         */
        @java.lang.Override
        public boolean hasRawData() {
            return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Serializations can either use one of the fields above, or use this
         * raw bytes field. The only exception is the string case, where one is
         * required to store the content in the repeated bytes string_data field.
         *
         * When this raw_data field is used to store tensor value, elements MUST
         * be stored in as fixed-width, little-endian order.
         * Floating-point data types MUST be stored in IEEE 754 format.
         * Complex64 elements must be written as two consecutive FLOAT values, real component first.
         * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
         * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
         * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
         *
         * Note: the advantage of specific field rather than the raw_data field is
         * that in some cases (e.g. int data), protobuf does a better packing via
         * variable length storage, and may lead to smaller binary footprint.
         * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
         * </pre>
         *
         * <code>optional bytes raw_data = 9;</code>
         * @return The rawData.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getRawData() {
            return rawData_;
        }
        
        public static final int EXTERNAL_DATA_FIELD_NUMBER = 13;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> externalData_;
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         * protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getExternalDataList() {
            return externalData_;
        }
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         * protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getExternalDataOrBuilderList() {
            return externalData_;
        }
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         * protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
         */
        @java.lang.Override
        public int getExternalDataCount() {
            return externalData_.size();
        }
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         * protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getExternalData(int index) {
            return externalData_.get(index);
        }
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         * protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
         */
        @java.lang.Override
        public ProtoOnnx.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
            int index) {
            return externalData_.get(index);
        }
        
        public static final int DATA_LOCATION_FIELD_NUMBER = 14;
        private int dataLocation_ = 0;
        /**
         * <pre>
         * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto.DataLocation data_location = 14;</code>
         * @return Whether the dataLocation field is set.
         */
        @java.lang.Override public boolean hasDataLocation() {
            return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto.DataLocation data_location = 14;</code>
         * @return The dataLocation.
         */
        @java.lang.Override public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation getDataLocation() {
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation result = ProtoOnnx.TensorProto.DataLocation.forNumber(dataLocation_);
            return result == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation.DEFAULT : result;
        }
        
        public static final int DOUBLE_DATA_FIELD_NUMBER = 10;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.DoubleList doubleData_ =
            emptyDoubleList();
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @return A list containing the doubleData.
         */
        @java.lang.Override
        public java.util.List<java.lang.Double>
        getDoubleDataList() {
            return doubleData_;
        }
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @return The count of doubleData.
         */
        public int getDoubleDataCount() {
            return doubleData_.size();
        }
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The doubleData at the given index.
         */
        public double getDoubleData(int index) {
            return doubleData_.getDouble(index);
        }
        private int doubleDataMemoizedSerializedSize = -1;
        
        public static final int UINT64_DATA_FIELD_NUMBER = 11;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.LongList uint64Data_ =
            emptyLongList();
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @return A list containing the uint64Data.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getUint64DataList() {
            return uint64Data_;
        }
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @return The count of uint64Data.
         */
        public int getUint64DataCount() {
            return uint64Data_.size();
        }
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The uint64Data at the given index.
         */
        public long getUint64Data(int index) {
            return uint64Data_.getLong(index);
        }
        private int uint64DataMemoizedSerializedSize = -1;
        
        public static final int METADATA_PROPS_FIELD_NUMBER = 16;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> metadataProps_;
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        @java.lang.Override
        public int getMetadataPropsCount() {
            return metadataProps_.size();
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
            return metadataProps_.get(index);
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index) {
            return metadataProps_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            getSerializedSize();
            for (int i = 0; i < dims_.size(); i++) {
                output.writeInt64(1, dims_.getLong(i));
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeInt32(2, dataType_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeMessage(3, getSegment());
            }
            if (getFloatDataList().size() > 0) {
                output.writeUInt32NoTag(34);
                output.writeUInt32NoTag(floatDataMemoizedSerializedSize);
            }
            for (int i = 0; i < floatData_.size(); i++) {
                output.writeFloatNoTag(floatData_.getFloat(i));
            }
            if (getInt32DataList().size() > 0) {
                output.writeUInt32NoTag(42);
                output.writeUInt32NoTag(int32DataMemoizedSerializedSize);
            }
            for (int i = 0; i < int32Data_.size(); i++) {
                output.writeInt32NoTag(int32Data_.getInt(i));
            }
            for (int i = 0; i < stringData_.size(); i++) {
                output.writeBytes(6, stringData_.get(i));
            }
            if (getInt64DataList().size() > 0) {
                output.writeUInt32NoTag(58);
                output.writeUInt32NoTag(int64DataMemoizedSerializedSize);
            }
            for (int i = 0; i < int64Data_.size(); i++) {
                output.writeInt64NoTag(int64Data_.getLong(i));
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 8, name_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                output.writeBytes(9, rawData_);
            }
            if (getDoubleDataList().size() > 0) {
                output.writeUInt32NoTag(82);
                output.writeUInt32NoTag(doubleDataMemoizedSerializedSize);
            }
            for (int i = 0; i < doubleData_.size(); i++) {
                output.writeDoubleNoTag(doubleData_.getDouble(i));
            }
            if (getUint64DataList().size() > 0) {
                output.writeUInt32NoTag(90);
                output.writeUInt32NoTag(uint64DataMemoizedSerializedSize);
            }
            for (int i = 0; i < uint64Data_.size(); i++) {
                output.writeUInt64NoTag(uint64Data_.getLong(i));
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 12, docString_);
            }
            for (int i = 0; i < externalData_.size(); i++) {
                output.writeMessage(13, externalData_.get(i));
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                output.writeEnum(14, dataLocation_);
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                output.writeMessage(16, metadataProps_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            {
                int dataSize = 0;
                for (int i = 0; i < dims_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                        .computeInt64SizeNoTag(dims_.getLong(i));
                }
                size += dataSize;
                size += 1 * getDimsList().size();
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt32Size(2, dataType_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(3, getSegment());
            }
            {
                int dataSize = 0;
                dataSize = 4 * getFloatDataList().size();
                size += dataSize;
                if (!getFloatDataList().isEmpty()) {
                    size += 1;
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt32SizeNoTag(dataSize);
                }
                floatDataMemoizedSerializedSize = dataSize;
            }
            {
                int dataSize = 0;
                for (int i = 0; i < int32Data_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                        .computeInt32SizeNoTag(int32Data_.getInt(i));
                }
                size += dataSize;
                if (!getInt32DataList().isEmpty()) {
                    size += 1;
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt32SizeNoTag(dataSize);
                }
                int32DataMemoizedSerializedSize = dataSize;
            }
            {
                int dataSize = 0;
                for (int i = 0; i < stringData_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                        .computeBytesSizeNoTag(stringData_.get(i));
                }
                size += dataSize;
                size += 1 * getStringDataList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < int64Data_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                        .computeInt64SizeNoTag(int64Data_.getLong(i));
                }
                size += dataSize;
                if (!getInt64DataList().isEmpty()) {
                    size += 1;
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt32SizeNoTag(dataSize);
                }
                int64DataMemoizedSerializedSize = dataSize;
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(8, name_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeBytesSize(9, rawData_);
            }
            {
                int dataSize = 0;
                dataSize = 8 * getDoubleDataList().size();
                size += dataSize;
                if (!getDoubleDataList().isEmpty()) {
                    size += 1;
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt32SizeNoTag(dataSize);
                }
                doubleDataMemoizedSerializedSize = dataSize;
            }
            {
                int dataSize = 0;
                for (int i = 0; i < uint64Data_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                        .computeUInt64SizeNoTag(uint64Data_.getLong(i));
                }
                size += dataSize;
                if (!getUint64DataList().isEmpty()) {
                    size += 1;
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt32SizeNoTag(dataSize);
                }
                uint64DataMemoizedSerializedSize = dataSize;
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(12, docString_);
            }
            for (int i = 0; i < externalData_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(13, externalData_.get(i));
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeEnumSize(14, dataLocation_);
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(16, metadataProps_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ProtoOnnx.TensorProto)) {
                return super.equals(obj);
            }
            ProtoOnnx.TensorProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto) obj;
            
            if (!getDimsList()
                .equals(other.getDimsList())) return false;
            if (hasDataType() != other.hasDataType()) return false;
            if (hasDataType()) {
                if (getDataType()
                    != other.getDataType()) return false;
            }
            if (hasSegment() != other.hasSegment()) return false;
            if (hasSegment()) {
                if (!getSegment()
                    .equals(other.getSegment())) return false;
            }
            if (!getFloatDataList()
                .equals(other.getFloatDataList())) return false;
            if (!getInt32DataList()
                .equals(other.getInt32DataList())) return false;
            if (!getStringDataList()
                .equals(other.getStringDataList())) return false;
            if (!getInt64DataList()
                .equals(other.getInt64DataList())) return false;
            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                    .equals(other.getName())) return false;
            }
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                    .equals(other.getDocString())) return false;
            }
            if (hasRawData() != other.hasRawData()) return false;
            if (hasRawData()) {
                if (!getRawData()
                    .equals(other.getRawData())) return false;
            }
            if (!getExternalDataList()
                .equals(other.getExternalDataList())) return false;
            if (hasDataLocation() != other.hasDataLocation()) return false;
            if (hasDataLocation()) {
                if (dataLocation_ != other.dataLocation_) return false;
            }
            if (!getDoubleDataList()
                .equals(other.getDoubleDataList())) return false;
            if (!getUint64DataList()
                .equals(other.getUint64DataList())) return false;
            if (!getMetadataPropsList()
                .equals(other.getMetadataPropsList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getDimsCount() > 0) {
                hash = (37 * hash) + DIMS_FIELD_NUMBER;
                hash = (53 * hash) + getDimsList().hashCode();
            }
            if (hasDataType()) {
                hash = (37 * hash) + DATA_TYPE_FIELD_NUMBER;
                hash = (53 * hash) + getDataType();
            }
            if (hasSegment()) {
                hash = (37 * hash) + SEGMENT_FIELD_NUMBER;
                hash = (53 * hash) + getSegment().hashCode();
            }
            if (getFloatDataCount() > 0) {
                hash = (37 * hash) + FLOAT_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getFloatDataList().hashCode();
            }
            if (getInt32DataCount() > 0) {
                hash = (37 * hash) + INT32_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getInt32DataList().hashCode();
            }
            if (getStringDataCount() > 0) {
                hash = (37 * hash) + STRING_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getStringDataList().hashCode();
            }
            if (getInt64DataCount() > 0) {
                hash = (37 * hash) + INT64_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getInt64DataList().hashCode();
            }
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (hasRawData()) {
                hash = (37 * hash) + RAW_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getRawData().hashCode();
            }
            if (getExternalDataCount() > 0) {
                hash = (37 * hash) + EXTERNAL_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getExternalDataList().hashCode();
            }
            if (hasDataLocation()) {
                hash = (37 * hash) + DATA_LOCATION_FIELD_NUMBER;
                hash = (53 * hash) + dataLocation_;
            }
            if (getDoubleDataCount() > 0) {
                hash = (37 * hash) + DOUBLE_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getDoubleDataList().hashCode();
            }
            if (getUint64DataCount() > 0) {
                hash = (37 * hash) + UINT64_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getUint64DataList().hashCode();
            }
            if (getMetadataPropsCount() > 0) {
                hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
                hash = (53 * hash) + getMetadataPropsList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static ProtoOnnx.TensorProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Tensors
         *
         * A serialized tensor value.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.TensorProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TensorProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.class, ProtoOnnx.TensorProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessage
                    .alwaysUseFieldBuilders) {
                    internalGetSegmentFieldBuilder();
                    internalGetExternalDataFieldBuilder();
                    internalGetMetadataPropsFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                dims_ = emptyLongList();
                dataType_ = 0;
                segment_ = null;
                if (segmentBuilder_ != null) {
                    segmentBuilder_.dispose();
                    segmentBuilder_ = null;
                }
                floatData_ = emptyFloatList();
                int32Data_ = emptyIntList();
                stringData_ = emptyList(com.google.protobuf.ByteString.class);
                int64Data_ = emptyLongList();
                name_ = "";
                docString_ = "";
                rawData_ = com.google.protobuf.ByteString.EMPTY;
                if (externalDataBuilder_ == null) {
                    externalData_ = java.util.Collections.emptyList();
                } else {
                    externalData_ = null;
                    externalDataBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000400);
                dataLocation_ = 0;
                doubleData_ = emptyDoubleList();
                uint64Data_ = emptyLongList();
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                } else {
                    metadataProps_ = null;
                    metadataPropsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00004000);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto result) {
                if (externalDataBuilder_ == null) {
                    if (((bitField0_ & 0x00000400) != 0)) {
                        externalData_ = java.util.Collections.unmodifiableList(externalData_);
                        bitField0_ = (bitField0_ & ~0x00000400);
                    }
                    result.externalData_ = externalData_;
                } else {
                    result.externalData_ = externalDataBuilder_.build();
                }
                if (metadataPropsBuilder_ == null) {
                    if (((bitField0_ & 0x00004000) != 0)) {
                        metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
                        bitField0_ = (bitField0_ & ~0x00004000);
                    }
                    result.metadataProps_ = metadataProps_;
                } else {
                    result.metadataProps_ = metadataPropsBuilder_.build();
                }
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto result) {
                int from_bitField0_ = bitField0_;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    dims_.makeImmutable();
                    result.dims_ = dims_;
                }
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.dataType_ = dataType_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    result.segment_ = segmentBuilder_ == null
                        ? segment_
                        : segmentBuilder_.build();
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000008) != 0)) {
                    floatData_.makeImmutable();
                    result.floatData_ = floatData_;
                }
                if (((from_bitField0_ & 0x00000010) != 0)) {
                    int32Data_.makeImmutable();
                    result.int32Data_ = int32Data_;
                }
                if (((from_bitField0_ & 0x00000020) != 0)) {
                    stringData_.makeImmutable();
                    result.stringData_ = stringData_;
                }
                if (((from_bitField0_ & 0x00000040) != 0)) {
                    int64Data_.makeImmutable();
                    result.int64Data_ = int64Data_;
                }
                if (((from_bitField0_ & 0x00000080) != 0)) {
                    result.name_ = name_;
                    to_bitField0_ |= 0x00000004;
                }
                if (((from_bitField0_ & 0x00000100) != 0)) {
                    result.docString_ = docString_;
                    to_bitField0_ |= 0x00000008;
                }
                if (((from_bitField0_ & 0x00000200) != 0)) {
                    result.rawData_ = rawData_;
                    to_bitField0_ |= 0x00000010;
                }
                if (((from_bitField0_ & 0x00000800) != 0)) {
                    result.dataLocation_ = dataLocation_;
                    to_bitField0_ |= 0x00000020;
                }
                if (((from_bitField0_ & 0x00001000) != 0)) {
                    doubleData_.makeImmutable();
                    result.doubleData_ = doubleData_;
                }
                if (((from_bitField0_ & 0x00002000) != 0)) {
                    uint64Data_.makeImmutable();
                    result.uint64Data_ = uint64Data_;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance()) return this;
                if (!other.dims_.isEmpty()) {
                    if (dims_.isEmpty()) {
                        dims_ = other.dims_;
                        dims_.makeImmutable();
                        bitField0_ |= 0x00000001;
                    } else {
                        ensureDimsIsMutable();
                        dims_.addAll(other.dims_);
                    }
                    onChanged();
                }
                if (other.hasDataType()) {
                    setDataType(other.getDataType());
                }
                if (other.hasSegment()) {
                    mergeSegment(other.getSegment());
                }
                if (!other.floatData_.isEmpty()) {
                    if (floatData_.isEmpty()) {
                        floatData_ = other.floatData_;
                        floatData_.makeImmutable();
                        bitField0_ |= 0x00000008;
                    } else {
                        ensureFloatDataIsMutable();
                        floatData_.addAll(other.floatData_);
                    }
                    onChanged();
                }
                if (!other.int32Data_.isEmpty()) {
                    if (int32Data_.isEmpty()) {
                        int32Data_ = other.int32Data_;
                        int32Data_.makeImmutable();
                        bitField0_ |= 0x00000010;
                    } else {
                        ensureInt32DataIsMutable();
                        int32Data_.addAll(other.int32Data_);
                    }
                    onChanged();
                }
                if (!other.stringData_.isEmpty()) {
                    if (stringData_.isEmpty()) {
                        stringData_ = other.stringData_;
                        stringData_.makeImmutable();
                        bitField0_ |= 0x00000020;
                    } else {
                        ensureStringDataIsMutable();
                        stringData_.addAll(other.stringData_);
                    }
                    onChanged();
                }
                if (!other.int64Data_.isEmpty()) {
                    if (int64Data_.isEmpty()) {
                        int64Data_ = other.int64Data_;
                        int64Data_.makeImmutable();
                        bitField0_ |= 0x00000040;
                    } else {
                        ensureInt64DataIsMutable();
                        int64Data_.addAll(other.int64Data_);
                    }
                    onChanged();
                }
                if (other.hasName()) {
                    name_ = other.name_;
                    bitField0_ |= 0x00000080;
                    onChanged();
                }
                if (other.hasDocString()) {
                    docString_ = other.docString_;
                    bitField0_ |= 0x00000100;
                    onChanged();
                }
                if (other.hasRawData()) {
                    setRawData(other.getRawData());
                }
                if (externalDataBuilder_ == null) {
                    if (!other.externalData_.isEmpty()) {
                        if (externalData_.isEmpty()) {
                            externalData_ = other.externalData_;
                            bitField0_ = (bitField0_ & ~0x00000400);
                        } else {
                            ensureExternalDataIsMutable();
                            externalData_.addAll(other.externalData_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.externalData_.isEmpty()) {
                        if (externalDataBuilder_.isEmpty()) {
                            externalDataBuilder_.dispose();
                            externalDataBuilder_ = null;
                            externalData_ = other.externalData_;
                            bitField0_ = (bitField0_ & ~0x00000400);
                            externalDataBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetExternalDataFieldBuilder() : null;
                        } else {
                            externalDataBuilder_.addAllMessages(other.externalData_);
                        }
                    }
                }
                if (other.hasDataLocation()) {
                    setDataLocation(other.getDataLocation());
                }
                if (!other.doubleData_.isEmpty()) {
                    if (doubleData_.isEmpty()) {
                        doubleData_ = other.doubleData_;
                        doubleData_.makeImmutable();
                        bitField0_ |= 0x00001000;
                    } else {
                        ensureDoubleDataIsMutable();
                        doubleData_.addAll(other.doubleData_);
                    }
                    onChanged();
                }
                if (!other.uint64Data_.isEmpty()) {
                    if (uint64Data_.isEmpty()) {
                        uint64Data_ = other.uint64Data_;
                        uint64Data_.makeImmutable();
                        bitField0_ |= 0x00002000;
                    } else {
                        ensureUint64DataIsMutable();
                        uint64Data_.addAll(other.uint64Data_);
                    }
                    onChanged();
                }
                if (metadataPropsBuilder_ == null) {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataProps_.isEmpty()) {
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00004000);
                        } else {
                            ensureMetadataPropsIsMutable();
                            metadataProps_.addAll(other.metadataProps_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataPropsBuilder_.isEmpty()) {
                            metadataPropsBuilder_.dispose();
                            metadataPropsBuilder_ = null;
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00004000);
                            metadataPropsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetMetadataPropsFieldBuilder() : null;
                        } else {
                            metadataPropsBuilder_.addAllMessages(other.metadataProps_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 8: {
                                long v = input.readInt64();
                                ensureDimsIsMutable();
                                dims_.addLong(v);
                                break;
                            } // case 8
                            case 10: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                ensureDimsIsMutable();
                                while (input.getBytesUntilLimit() > 0) {
                                    dims_.addLong(input.readInt64());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 10
                            case 16: {
                                dataType_ = input.readInt32();
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 16
                            case 26: {
                                input.readMessage(
                                    internalGetSegmentFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000004;
                                break;
                            } // case 26
                            case 37: {
                                float v = input.readFloat();
                                ensureFloatDataIsMutable();
                                floatData_.addFloat(v);
                                break;
                            } // case 37
                            case 34: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                int alloc = length > 4096 ? 4096 : length;
                                ensureFloatDataIsMutable(alloc / 4);
                                while (input.getBytesUntilLimit() > 0) {
                                    floatData_.addFloat(input.readFloat());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 34
                            case 40: {
                                int v = input.readInt32();
                                ensureInt32DataIsMutable();
                                int32Data_.addInt(v);
                                break;
                            } // case 40
                            case 42: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                ensureInt32DataIsMutable();
                                while (input.getBytesUntilLimit() > 0) {
                                    int32Data_.addInt(input.readInt32());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 42
                            case 50: {
                                com.google.protobuf.ByteString v = input.readBytes();
                                ensureStringDataIsMutable();
                                stringData_.add(v);
                                break;
                            } // case 50
                            case 56: {
                                long v = input.readInt64();
                                ensureInt64DataIsMutable();
                                int64Data_.addLong(v);
                                break;
                            } // case 56
                            case 58: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                ensureInt64DataIsMutable();
                                while (input.getBytesUntilLimit() > 0) {
                                    int64Data_.addLong(input.readInt64());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 58
                            case 66: {
                                name_ = input.readBytes();
                                bitField0_ |= 0x00000080;
                                break;
                            } // case 66
                            case 74: {
                                rawData_ = input.readBytes();
                                bitField0_ |= 0x00000200;
                                break;
                            } // case 74
                            case 81: {
                                double v = input.readDouble();
                                ensureDoubleDataIsMutable();
                                doubleData_.addDouble(v);
                                break;
                            } // case 81
                            case 82: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                int alloc = length > 4096 ? 4096 : length;
                                ensureDoubleDataIsMutable(alloc / 8);
                                while (input.getBytesUntilLimit() > 0) {
                                    doubleData_.addDouble(input.readDouble());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 82
                            case 88: {
                                long v = input.readUInt64();
                                ensureUint64DataIsMutable();
                                uint64Data_.addLong(v);
                                break;
                            } // case 88
                            case 90: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                ensureUint64DataIsMutable();
                                while (input.getBytesUntilLimit() > 0) {
                                    uint64Data_.addLong(input.readUInt64());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 90
                            case 98: {
                                docString_ = input.readBytes();
                                bitField0_ |= 0x00000100;
                                break;
                            } // case 98
                            case 106: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.parser(),
                                        extensionRegistry);
                                if (externalDataBuilder_ == null) {
                                    ensureExternalDataIsMutable();
                                    externalData_.add(m);
                                } else {
                                    externalDataBuilder_.addMessage(m);
                                }
                                break;
                            } // case 106
                            case 112: {
                                int tmpRaw = input.readEnum();
                                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation tmpValue =
                                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation.forNumber(tmpRaw);
                                if (tmpValue == null) {
                                    mergeUnknownVarintField(14, tmpRaw);
                                } else {
                                    dataLocation_ = tmpRaw;
                                    bitField0_ |= 0x00000800;
                                }
                                break;
                            } // case 112
                            case 130: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.parser(),
                                        extensionRegistry);
                                if (metadataPropsBuilder_ == null) {
                                    ensureMetadataPropsIsMutable();
                                    metadataProps_.add(m);
                                } else {
                                    metadataPropsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 130
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private com.google.protobuf.Internal.LongList dims_ = emptyLongList();
            private void ensureDimsIsMutable() {
                if (!dims_.isModifiable()) {
                    dims_ = makeMutableCopy(dims_);
                }
                bitField0_ |= 0x00000001;
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @return A list containing the dims.
             */
            public java.util.List<java.lang.Long>
            getDimsList() {
                dims_.makeImmutable();
                return dims_;
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @return The count of dims.
             */
            public int getDimsCount() {
                return dims_.size();
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @param index The index of the element to return.
             * @return The dims at the given index.
             */
            public long getDims(int index) {
                return dims_.getLong(index);
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @param index The index to set the value at.
             * @param value The dims to set.
             * @return This builder for chaining.
             */
            public Builder setDims(
                int index, long value) {
                
                ensureDimsIsMutable();
                dims_.setLong(index, value);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @param value The dims to add.
             * @return This builder for chaining.
             */
            public Builder addDims(long value) {
                
                ensureDimsIsMutable();
                dims_.addLong(value);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @param values The dims to add.
             * @return This builder for chaining.
             */
            public Builder addAllDims(
                java.lang.Iterable<? extends java.lang.Long> values) {
                ensureDimsIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, dims_);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearDims() {
                dims_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            
            private int dataType_ ;
            /**
             * <pre>
             * The data type of the tensor.
             * This field MUST have a valid TensorProto.DataType value
             * </pre>
             *
             * <code>optional int32 data_type = 2;</code>
             * @return Whether the dataType field is set.
             */
            @java.lang.Override
            public boolean hasDataType() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * The data type of the tensor.
             * This field MUST have a valid TensorProto.DataType value
             * </pre>
             *
             * <code>optional int32 data_type = 2;</code>
             * @return The dataType.
             */
            @java.lang.Override
            public int getDataType() {
                return dataType_;
            }
            /**
             * <pre>
             * The data type of the tensor.
             * This field MUST have a valid TensorProto.DataType value
             * </pre>
             *
             * <code>optional int32 data_type = 2;</code>
             * @param value The dataType to set.
             * @return This builder for chaining.
             */
            public Builder setDataType(int value) {
                
                dataType_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The data type of the tensor.
             * This field MUST have a valid TensorProto.DataType value
             * </pre>
             *
             * <code>optional int32 data_type = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearDataType() {
                bitField0_ = (bitField0_ & ~0x00000002);
                dataType_ = 0;
                onChanged();
                return this;
            }
            
            private org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment segment_;
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.SegmentOrBuilder> segmentBuilder_;
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
             * @return Whether the segment field is set.
             */
            public boolean hasSegment() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
             * @return The segment.
             */
            public ProtoOnnx.TensorProto.Segment getSegment() {
                if (segmentBuilder_ == null) {
                    return segment_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.getDefaultInstance() : segment_;
                } else {
                    return segmentBuilder_.getMessage();
                }
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
             */
            public Builder setSegment(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment value) {
                if (segmentBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    segment_ = value;
                } else {
                    segmentBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
             */
            public Builder setSegment(
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.Builder builderForValue) {
                if (segmentBuilder_ == null) {
                    segment_ = builderForValue.build();
                } else {
                    segmentBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
             */
            public Builder mergeSegment(ProtoOnnx.TensorProto.Segment value) {
                if (segmentBuilder_ == null) {
                    if (((bitField0_ & 0x00000004) != 0) &&
                        segment_ != null &&
                        segment_ != org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.getDefaultInstance()) {
                        getSegmentBuilder().mergeFrom(value);
                    } else {
                        segment_ = value;
                    }
                } else {
                    segmentBuilder_.mergeFrom(value);
                }
                if (segment_ != null) {
                    bitField0_ |= 0x00000004;
                    onChanged();
                }
                return this;
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
             */
            public Builder clearSegment() {
                bitField0_ = (bitField0_ & ~0x00000004);
                segment_ = null;
                if (segmentBuilder_ != null) {
                    segmentBuilder_.dispose();
                    segmentBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.Builder getSegmentBuilder() {
                bitField0_ |= 0x00000004;
                onChanged();
                return internalGetSegmentFieldBuilder().getBuilder();
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.SegmentOrBuilder getSegmentOrBuilder() {
                if (segmentBuilder_ != null) {
                    return segmentBuilder_.getMessageOrBuilder();
                } else {
                    return segment_ == null ?
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.getDefaultInstance() : segment_;
                }
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.Segment segment = 3;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.SegmentOrBuilder>
            internalGetSegmentFieldBuilder() {
                if (segmentBuilder_ == null) {
                    segmentBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Segment.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.SegmentOrBuilder>(
                        getSegment(),
                        getParentForChildren(),
                        isClean());
                    segment_ = null;
                }
                return segmentBuilder_;
            }
            
            private com.google.protobuf.Internal.FloatList floatData_ = emptyFloatList();
            private void ensureFloatDataIsMutable() {
                if (!floatData_.isModifiable()) {
                    floatData_ = makeMutableCopy(floatData_);
                }
                bitField0_ |= 0x00000008;
            }
            private void ensureFloatDataIsMutable(int capacity) {
                if (!floatData_.isModifiable()) {
                    floatData_ = makeMutableCopy(floatData_, capacity);
                }
                bitField0_ |= 0x00000008;
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @return A list containing the floatData.
             */
            public java.util.List<java.lang.Float>
            getFloatDataList() {
                floatData_.makeImmutable();
                return floatData_;
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @return The count of floatData.
             */
            public int getFloatDataCount() {
                return floatData_.size();
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @param index The index of the element to return.
             * @return The floatData at the given index.
             */
            public float getFloatData(int index) {
                return floatData_.getFloat(index);
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @param index The index to set the value at.
             * @param value The floatData to set.
             * @return This builder for chaining.
             */
            public Builder setFloatData(
                int index, float value) {
                
                ensureFloatDataIsMutable();
                floatData_.setFloat(index, value);
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @param value The floatData to add.
             * @return This builder for chaining.
             */
            public Builder addFloatData(float value) {
                
                ensureFloatDataIsMutable();
                floatData_.addFloat(value);
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @param values The floatData to add.
             * @return This builder for chaining.
             */
            public Builder addAllFloatData(
                java.lang.Iterable<? extends java.lang.Float> values) {
                ensureFloatDataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, floatData_);
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @return This builder for chaining.
             */
            public Builder clearFloatData() {
                floatData_ = emptyFloatList();
                bitField0_ = (bitField0_ & ~0x00000008);
                onChanged();
                return this;
            }
            
            private com.google.protobuf.Internal.IntList int32Data_ = emptyIntList();
            private void ensureInt32DataIsMutable() {
                if (!int32Data_.isModifiable()) {
                    int32Data_ = makeMutableCopy(int32Data_);
                }
                bitField0_ |= 0x00000010;
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
             * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
             * representation before being written to the buffer.
             * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
             * The first element is stored in the 4 least significant bits (LSB),
             * and the second element is stored in the 4 most significant bits (MSB).
             *
             * Consequently:
             * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
             * - For 4-bit data types, each `int32_data` stores two elements.
             *
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @return A list containing the int32Data.
             */
            public java.util.List<java.lang.Integer>
            getInt32DataList() {
                int32Data_.makeImmutable();
                return int32Data_;
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
             * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
             * representation before being written to the buffer.
             * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
             * The first element is stored in the 4 least significant bits (LSB),
             * and the second element is stored in the 4 most significant bits (MSB).
             *
             * Consequently:
             * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
             * - For 4-bit data types, each `int32_data` stores two elements.
             *
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @return The count of int32Data.
             */
            public int getInt32DataCount() {
                return int32Data_.size();
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
             * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
             * representation before being written to the buffer.
             * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
             * The first element is stored in the 4 least significant bits (LSB),
             * and the second element is stored in the 4 most significant bits (MSB).
             *
             * Consequently:
             * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
             * - For 4-bit data types, each `int32_data` stores two elements.
             *
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @param index The index of the element to return.
             * @return The int32Data at the given index.
             */
            public int getInt32Data(int index) {
                return int32Data_.getInt(index);
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
             * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
             * representation before being written to the buffer.
             * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
             * The first element is stored in the 4 least significant bits (LSB),
             * and the second element is stored in the 4 most significant bits (MSB).
             *
             * Consequently:
             * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
             * - For 4-bit data types, each `int32_data` stores two elements.
             *
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @param index The index to set the value at.
             * @param value The int32Data to set.
             * @return This builder for chaining.
             */
            public Builder setInt32Data(
                int index, int value) {
                
                ensureInt32DataIsMutable();
                int32Data_.setInt(index, value);
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
             * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
             * representation before being written to the buffer.
             * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
             * The first element is stored in the 4 least significant bits (LSB),
             * and the second element is stored in the 4 most significant bits (MSB).
             *
             * Consequently:
             * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
             * - For 4-bit data types, each `int32_data` stores two elements.
             *
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @param value The int32Data to add.
             * @return This builder for chaining.
             */
            public Builder addInt32Data(int value) {
                
                ensureInt32DataIsMutable();
                int32Data_.addInt(value);
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
             * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
             * representation before being written to the buffer.
             * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
             * The first element is stored in the 4 least significant bits (LSB),
             * and the second element is stored in the 4 most significant bits (MSB).
             *
             * Consequently:
             * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
             * - For 4-bit data types, each `int32_data` stores two elements.
             *
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @param values The int32Data to add.
             * @return This builder for chaining.
             */
            public Builder addAllInt32Data(
                java.lang.Iterable<? extends java.lang.Integer> values) {
                ensureInt32DataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, int32Data_);
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
             * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
             * representation before being written to the buffer.
             * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
             * The first element is stored in the 4 least significant bits (LSB),
             * and the second element is stored in the 4 most significant bits (MSB).
             *
             * Consequently:
             * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
             * - For 4-bit data types, each `int32_data` stores two elements.
             *
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @return This builder for chaining.
             */
            public Builder clearInt32Data() {
                int32Data_ = emptyIntList();
                bitField0_ = (bitField0_ & ~0x00000010);
                onChanged();
                return this;
            }
            
            private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> stringData_ = emptyList(com.google.protobuf.ByteString.class);
            private void ensureStringDataIsMutable() {
                if (!stringData_.isModifiable()) {
                    stringData_ = makeMutableCopy(stringData_);
                }
                bitField0_ |= 0x00000020;
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @return A list containing the stringData.
             */
            public java.util.List<com.google.protobuf.ByteString>
            getStringDataList() {
                stringData_.makeImmutable();
                return stringData_;
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @return The count of stringData.
             */
            public int getStringDataCount() {
                return stringData_.size();
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @param index The index of the element to return.
             * @return The stringData at the given index.
             */
            public com.google.protobuf.ByteString getStringData(int index) {
                return stringData_.get(index);
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @param index The index to set the value at.
             * @param value The stringData to set.
             * @return This builder for chaining.
             */
            public Builder setStringData(
                int index, com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                ensureStringDataIsMutable();
                stringData_.set(index, value);
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @param value The stringData to add.
             * @return This builder for chaining.
             */
            public Builder addStringData(com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                ensureStringDataIsMutable();
                stringData_.add(value);
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @param values The stringData to add.
             * @return This builder for chaining.
             */
            public Builder addAllStringData(
                java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
                ensureStringDataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, stringData_);
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @return This builder for chaining.
             */
            public Builder clearStringData() {
                stringData_ = emptyList(com.google.protobuf.ByteString.class);
                bitField0_ = (bitField0_ & ~0x00000020);
                onChanged();
                return this;
            }
            
            private com.google.protobuf.Internal.LongList int64Data_ = emptyLongList();
            private void ensureInt64DataIsMutable() {
                if (!int64Data_.isModifiable()) {
                    int64Data_ = makeMutableCopy(int64Data_);
                }
                bitField0_ |= 0x00000040;
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @return A list containing the int64Data.
             */
            public java.util.List<java.lang.Long>
            getInt64DataList() {
                int64Data_.makeImmutable();
                return int64Data_;
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @return The count of int64Data.
             */
            public int getInt64DataCount() {
                return int64Data_.size();
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @param index The index of the element to return.
             * @return The int64Data at the given index.
             */
            public long getInt64Data(int index) {
                return int64Data_.getLong(index);
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @param index The index to set the value at.
             * @param value The int64Data to set.
             * @return This builder for chaining.
             */
            public Builder setInt64Data(
                int index, long value) {
                
                ensureInt64DataIsMutable();
                int64Data_.setLong(index, value);
                bitField0_ |= 0x00000040;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @param value The int64Data to add.
             * @return This builder for chaining.
             */
            public Builder addInt64Data(long value) {
                
                ensureInt64DataIsMutable();
                int64Data_.addLong(value);
                bitField0_ |= 0x00000040;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @param values The int64Data to add.
             * @return This builder for chaining.
             */
            public Builder addAllInt64Data(
                java.lang.Iterable<? extends java.lang.Long> values) {
                ensureInt64DataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, int64Data_);
                bitField0_ |= 0x00000040;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @return This builder for chaining.
             */
            public Builder clearInt64Data() {
                int64Data_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000040);
                onChanged();
                return this;
            }
            
            private java.lang.Object name_ = "";
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000080) != 0);
            }
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000080;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                name_ = getDefaultInstance().getName();
                bitField0_ = (bitField0_ & ~0x00000080);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000080;
                onChanged();
                return this;
            }
            
            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000100) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000100;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                docString_ = getDefaultInstance().getDocString();
                bitField0_ = (bitField0_ & ~0x00000100);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000100;
                onChanged();
                return this;
            }
            
            private com.google.protobuf.ByteString rawData_ = com.google.protobuf.ByteString.EMPTY;
            /**
             * <pre>
             * Serializations can either use one of the fields above, or use this
             * raw bytes field. The only exception is the string case, where one is
             * required to store the content in the repeated bytes string_data field.
             *
             * When this raw_data field is used to store tensor value, elements MUST
             * be stored in as fixed-width, little-endian order.
             * Floating-point data types MUST be stored in IEEE 754 format.
             * Complex64 elements must be written as two consecutive FLOAT values, real component first.
             * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
             * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
             * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
             *
             * Note: the advantage of specific field rather than the raw_data field is
             * that in some cases (e.g. int data), protobuf does a better packing via
             * variable length storage, and may lead to smaller binary footprint.
             * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
             * </pre>
             *
             * <code>optional bytes raw_data = 9;</code>
             * @return Whether the rawData field is set.
             */
            @java.lang.Override
            public boolean hasRawData() {
                return ((bitField0_ & 0x00000200) != 0);
            }
            /**
             * <pre>
             * Serializations can either use one of the fields above, or use this
             * raw bytes field. The only exception is the string case, where one is
             * required to store the content in the repeated bytes string_data field.
             *
             * When this raw_data field is used to store tensor value, elements MUST
             * be stored in as fixed-width, little-endian order.
             * Floating-point data types MUST be stored in IEEE 754 format.
             * Complex64 elements must be written as two consecutive FLOAT values, real component first.
             * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
             * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
             * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
             *
             * Note: the advantage of specific field rather than the raw_data field is
             * that in some cases (e.g. int data), protobuf does a better packing via
             * variable length storage, and may lead to smaller binary footprint.
             * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
             * </pre>
             *
             * <code>optional bytes raw_data = 9;</code>
             * @return The rawData.
             */
            @java.lang.Override
            public com.google.protobuf.ByteString getRawData() {
                return rawData_;
            }
            /**
             * <pre>
             * Serializations can either use one of the fields above, or use this
             * raw bytes field. The only exception is the string case, where one is
             * required to store the content in the repeated bytes string_data field.
             *
             * When this raw_data field is used to store tensor value, elements MUST
             * be stored in as fixed-width, little-endian order.
             * Floating-point data types MUST be stored in IEEE 754 format.
             * Complex64 elements must be written as two consecutive FLOAT values, real component first.
             * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
             * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
             * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
             *
             * Note: the advantage of specific field rather than the raw_data field is
             * that in some cases (e.g. int data), protobuf does a better packing via
             * variable length storage, and may lead to smaller binary footprint.
             * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
             * </pre>
             *
             * <code>optional bytes raw_data = 9;</code>
             * @param value The rawData to set.
             * @return This builder for chaining.
             */
            public Builder setRawData(com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                rawData_ = value;
                bitField0_ |= 0x00000200;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Serializations can either use one of the fields above, or use this
             * raw bytes field. The only exception is the string case, where one is
             * required to store the content in the repeated bytes string_data field.
             *
             * When this raw_data field is used to store tensor value, elements MUST
             * be stored in as fixed-width, little-endian order.
             * Floating-point data types MUST be stored in IEEE 754 format.
             * Complex64 elements must be written as two consecutive FLOAT values, real component first.
             * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
             * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
             * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
             *
             * Note: the advantage of specific field rather than the raw_data field is
             * that in some cases (e.g. int data), protobuf does a better packing via
             * variable length storage, and may lead to smaller binary footprint.
             * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
             * </pre>
             *
             * <code>optional bytes raw_data = 9;</code>
             * @return This builder for chaining.
             */
            public Builder clearRawData() {
                bitField0_ = (bitField0_ & ~0x00000200);
                rawData_ = getDefaultInstance().getRawData();
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> externalData_ =
                java.util.Collections.emptyList();
            private void ensureExternalDataIsMutable() {
                if (!((bitField0_ & 0x00000400) != 0)) {
                    externalData_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>(externalData_);
                    bitField0_ |= 0x00000400;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder> externalDataBuilder_;
            
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getExternalDataList() {
                if (externalDataBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(externalData_);
                } else {
                    return externalDataBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public int getExternalDataCount() {
                if (externalDataBuilder_ == null) {
                    return externalData_.size();
                } else {
                    return externalDataBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getExternalData(int index) {
                if (externalDataBuilder_ == null) {
                    return externalData_.get(index);
                } else {
                    return externalDataBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder setExternalData(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (externalDataBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureExternalDataIsMutable();
                    externalData_.set(index, value);
                    onChanged();
                } else {
                    externalDataBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder setExternalData(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (externalDataBuilder_ == null) {
                    ensureExternalDataIsMutable();
                    externalData_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    externalDataBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder addExternalData(org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (externalDataBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureExternalDataIsMutable();
                    externalData_.add(value);
                    onChanged();
                } else {
                    externalDataBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder addExternalData(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (externalDataBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureExternalDataIsMutable();
                    externalData_.add(index, value);
                    onChanged();
                } else {
                    externalDataBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder addExternalData(
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (externalDataBuilder_ == null) {
                    ensureExternalDataIsMutable();
                    externalData_.add(builderForValue.build());
                    onChanged();
                } else {
                    externalDataBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder addExternalData(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (externalDataBuilder_ == null) {
                    ensureExternalDataIsMutable();
                    externalData_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    externalDataBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder addAllExternalData(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> values) {
                if (externalDataBuilder_ == null) {
                    ensureExternalDataIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, externalData_);
                    onChanged();
                } else {
                    externalDataBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder clearExternalData() {
                if (externalDataBuilder_ == null) {
                    externalData_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000400);
                    onChanged();
                } else {
                    externalDataBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder removeExternalData(int index) {
                if (externalDataBuilder_ == null) {
                    ensureExternalDataIsMutable();
                    externalData_.remove(index);
                    onChanged();
                } else {
                    externalDataBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public ProtoOnnx.StringStringEntryProto.Builder getExternalDataBuilder(
                int index) {
                return internalGetExternalDataFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
                int index) {
                if (externalDataBuilder_ == null) {
                    return externalData_.get(index);  } else {
                    return externalDataBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            getExternalDataOrBuilderList() {
                if (externalDataBuilder_ != null) {
                    return externalDataBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(externalData_);
                }
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addExternalDataBuilder() {
                return internalGetExternalDataFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addExternalDataBuilder(
                int index) {
                return internalGetExternalDataFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             * protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto external_data = 13;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder>
            getExternalDataBuilderList() {
                return internalGetExternalDataFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            internalGetExternalDataFieldBuilder() {
                if (externalDataBuilder_ == null) {
                    externalDataBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>(
                        externalData_,
                        ((bitField0_ & 0x00000400) != 0),
                        getParentForChildren(),
                        isClean());
                    externalData_ = null;
                }
                return externalDataBuilder_;
            }
            
            private int dataLocation_ = 0;
            /**
             * <pre>
             * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.DataLocation data_location = 14;</code>
             * @return Whether the dataLocation field is set.
             */
            @java.lang.Override public boolean hasDataLocation() {
                return ((bitField0_ & 0x00000800) != 0);
            }
            /**
             * <pre>
             * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.DataLocation data_location = 14;</code>
             * @return The dataLocation.
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation getDataLocation() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation result = org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation.forNumber(dataLocation_);
                return result == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation.DEFAULT : result;
            }
            /**
             * <pre>
             * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.DataLocation data_location = 14;</code>
             * @param value The dataLocation to set.
             * @return This builder for chaining.
             */
            public Builder setDataLocation(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.DataLocation value) {
                if (value == null) { throw new NullPointerException(); }
                bitField0_ |= 0x00000800;
                dataLocation_ = value.getNumber();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto.DataLocation data_location = 14;</code>
             * @return This builder for chaining.
             */
            public Builder clearDataLocation() {
                bitField0_ = (bitField0_ & ~0x00000800);
                dataLocation_ = 0;
                onChanged();
                return this;
            }
            
            private com.google.protobuf.Internal.DoubleList doubleData_ = emptyDoubleList();
            private void ensureDoubleDataIsMutable() {
                if (!doubleData_.isModifiable()) {
                    doubleData_ = makeMutableCopy(doubleData_);
                }
                bitField0_ |= 0x00001000;
            }
            private void ensureDoubleDataIsMutable(int capacity) {
                if (!doubleData_.isModifiable()) {
                    doubleData_ = makeMutableCopy(doubleData_, capacity);
                }
                bitField0_ |= 0x00001000;
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @return A list containing the doubleData.
             */
            public java.util.List<java.lang.Double>
            getDoubleDataList() {
                doubleData_.makeImmutable();
                return doubleData_;
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @return The count of doubleData.
             */
            public int getDoubleDataCount() {
                return doubleData_.size();
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @param index The index of the element to return.
             * @return The doubleData at the given index.
             */
            public double getDoubleData(int index) {
                return doubleData_.getDouble(index);
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @param index The index to set the value at.
             * @param value The doubleData to set.
             * @return This builder for chaining.
             */
            public Builder setDoubleData(
                int index, double value) {
                
                ensureDoubleDataIsMutable();
                doubleData_.setDouble(index, value);
                bitField0_ |= 0x00001000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @param value The doubleData to add.
             * @return This builder for chaining.
             */
            public Builder addDoubleData(double value) {
                
                ensureDoubleDataIsMutable();
                doubleData_.addDouble(value);
                bitField0_ |= 0x00001000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @param values The doubleData to add.
             * @return This builder for chaining.
             */
            public Builder addAllDoubleData(
                java.lang.Iterable<? extends java.lang.Double> values) {
                ensureDoubleDataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, doubleData_);
                bitField0_ |= 0x00001000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @return This builder for chaining.
             */
            public Builder clearDoubleData() {
                doubleData_ = emptyDoubleList();
                bitField0_ = (bitField0_ & ~0x00001000);
                onChanged();
                return this;
            }
            
            private com.google.protobuf.Internal.LongList uint64Data_ = emptyLongList();
            private void ensureUint64DataIsMutable() {
                if (!uint64Data_.isModifiable()) {
                    uint64Data_ = makeMutableCopy(uint64Data_);
                }
                bitField0_ |= 0x00002000;
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @return A list containing the uint64Data.
             */
            public java.util.List<java.lang.Long>
            getUint64DataList() {
                uint64Data_.makeImmutable();
                return uint64Data_;
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @return The count of uint64Data.
             */
            public int getUint64DataCount() {
                return uint64Data_.size();
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @param index The index of the element to return.
             * @return The uint64Data at the given index.
             */
            public long getUint64Data(int index) {
                return uint64Data_.getLong(index);
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @param index The index to set the value at.
             * @param value The uint64Data to set.
             * @return This builder for chaining.
             */
            public Builder setUint64Data(
                int index, long value) {
                
                ensureUint64DataIsMutable();
                uint64Data_.setLong(index, value);
                bitField0_ |= 0x00002000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @param value The uint64Data to add.
             * @return This builder for chaining.
             */
            public Builder addUint64Data(long value) {
                
                ensureUint64DataIsMutable();
                uint64Data_.addLong(value);
                bitField0_ |= 0x00002000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @param values The uint64Data to add.
             * @return This builder for chaining.
             */
            public Builder addAllUint64Data(
                java.lang.Iterable<? extends java.lang.Long> values) {
                ensureUint64DataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, uint64Data_);
                bitField0_ |= 0x00002000;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @return This builder for chaining.
             */
            public Builder clearUint64Data() {
                uint64Data_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00002000);
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> metadataProps_ =
                java.util.Collections.emptyList();
            private void ensureMetadataPropsIsMutable() {
                if (!((bitField0_ & 0x00004000) != 0)) {
                    metadataProps_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>(metadataProps_);
                    bitField0_ |= 0x00004000;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;
            
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
                if (metadataPropsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                } else {
                    return metadataPropsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public int getMetadataPropsCount() {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.size();
                } else {
                    return metadataPropsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);
                } else {
                    return metadataPropsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder setMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder setMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder addMetadataProps(org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder addMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder addMetadataProps(
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder addMetadataProps(
                int index, ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder addAllMetadataProps(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> values) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, metadataProps_);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder clearMetadataProps() {
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00004000);
                    onChanged();
                } else {
                    metadataPropsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public Builder removeMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.remove(index);
                    onChanged();
                } else {
                    metadataPropsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public ProtoOnnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
                int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);  } else {
                    return metadataPropsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            getMetadataPropsOrBuilderList() {
                if (metadataPropsBuilder_ != null) {
                    return metadataPropsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 16;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder>
            getMetadataPropsBuilderList() {
                return internalGetMetadataPropsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
            internalGetMetadataPropsFieldBuilder() {
                if (metadataPropsBuilder_ == null) {
                    metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, ProtoOnnx.StringStringEntryProtoOrBuilder>(
                        metadataProps_,
                        ((bitField0_ & 0x00004000) != 0),
                        getParentForChildren(),
                        isClean());
                    metadataProps_ = null;
                }
                return metadataPropsBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TensorProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TensorProto)
        private static final ProtoOnnx.TensorProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ProtoOnnx.TensorProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<TensorProto>
            PARSER = new com.google.protobuf.AbstractParser<TensorProto>() {
            @java.lang.Override
            public TensorProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<TensorProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<TensorProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface SparseTensorProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.SparseTensorProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
         * @return Whether the values field is set.
         */
        boolean hasValues();
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
         * @return The values.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getValues();
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder getValuesOrBuilder();
        
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
         * @return Whether the indices field is set.
         */
        boolean hasIndices();
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
         * @return The indices.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getIndices();
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder getIndicesOrBuilder();
        
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @return A list containing the dims.
         */
        java.util.List<java.lang.Long> getDimsList();
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @return The count of dims.
         */
        int getDimsCount();
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @param index The index of the element to return.
         * @return The dims at the given index.
         */
        long getDims(int index);
    }
    /**
     * <pre>
     * A serialized sparse-tensor value
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.SparseTensorProto}
     */
    public static final class SparseTensorProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.SparseTensorProto)
        SparseTensorProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                SparseTensorProto.class.getName());
        }
        // Use SparseTensorProto.newBuilder() to construct.
        private SparseTensorProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private SparseTensorProto() {
            dims_ = emptyLongList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_SparseTensorProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_SparseTensorProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int VALUES_FIELD_NUMBER = 1;
        private org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto values_;
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
         * @return Whether the values field is set.
         */
        @java.lang.Override
        public boolean hasValues() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
         * @return The values.
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getValues() {
            return values_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance() : values_;
        }
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder getValuesOrBuilder() {
            return values_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance() : values_;
        }
        
        public static final int INDICES_FIELD_NUMBER = 2;
        private org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto indices_;
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
         * @return Whether the indices field is set.
         */
        @java.lang.Override
        public boolean hasIndices() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
         * @return The indices.
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getIndices() {
            return indices_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance() : indices_;
        }
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder getIndicesOrBuilder() {
            return indices_ == null ? ProtoOnnx.TensorProto.getDefaultInstance() : indices_;
        }
        
        public static final int DIMS_FIELD_NUMBER = 3;
        @SuppressWarnings("serial")
        private com.google.protobuf.Internal.LongList dims_ =
            emptyLongList();
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @return A list containing the dims.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getDimsList() {
            return dims_;
        }
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @return The count of dims.
         */
        public int getDimsCount() {
            return dims_.size();
        }
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @param index The index of the element to return.
         * @return The dims at the given index.
         */
        public long getDims(int index) {
            return dims_.getLong(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeMessage(1, getValues());
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeMessage(2, getIndices());
            }
            for (int i = 0; i < dims_.size(); i++) {
                output.writeInt64(3, dims_.getLong(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(1, getValues());
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(2, getIndices());
            }
            {
                int dataSize = 0;
                for (int i = 0; i < dims_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                        .computeInt64SizeNoTag(dims_.getLong(i));
                }
                size += dataSize;
                size += 1 * getDimsList().size();
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto) obj;
            
            if (hasValues() != other.hasValues()) return false;
            if (hasValues()) {
                if (!getValues()
                    .equals(other.getValues())) return false;
            }
            if (hasIndices() != other.hasIndices()) return false;
            if (hasIndices()) {
                if (!getIndices()
                    .equals(other.getIndices())) return false;
            }
            if (!getDimsList()
                .equals(other.getDimsList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasValues()) {
                hash = (37 * hash) + VALUES_FIELD_NUMBER;
                hash = (53 * hash) + getValues().hashCode();
            }
            if (hasIndices()) {
                hash = (37 * hash) + INDICES_FIELD_NUMBER;
                hash = (53 * hash) + getIndices().hashCode();
            }
            if (getDimsCount() > 0) {
                hash = (37 * hash) + DIMS_FIELD_NUMBER;
                hash = (53 * hash) + getDimsList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static ProtoOnnx.SparseTensorProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * A serialized sparse-tensor value
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.SparseTensorProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.SparseTensorProto)
            ProtoOnnx.SparseTensorProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_SparseTensorProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_SparseTensorProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessage
                    .alwaysUseFieldBuilders) {
                    internalGetValuesFieldBuilder();
                    internalGetIndicesFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                values_ = null;
                if (valuesBuilder_ != null) {
                    valuesBuilder_.dispose();
                    valuesBuilder_ = null;
                }
                indices_ = null;
                if (indicesBuilder_ != null) {
                    indicesBuilder_.dispose();
                    indicesBuilder_ = null;
                }
                dims_ = emptyLongList();
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_SparseTensorProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto result = new ProtoOnnx.SparseTensorProto(this);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.values_ = valuesBuilder_ == null
                        ? values_
                        : valuesBuilder_.build();
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.indices_ = indicesBuilder_ == null
                        ? indices_
                        : indicesBuilder_.build();
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    dims_.makeImmutable();
                    result.dims_ = dims_;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto other) {
                if (other == ProtoOnnx.SparseTensorProto.getDefaultInstance()) return this;
                if (other.hasValues()) {
                    mergeValues(other.getValues());
                }
                if (other.hasIndices()) {
                    mergeIndices(other.getIndices());
                }
                if (!other.dims_.isEmpty()) {
                    if (dims_.isEmpty()) {
                        dims_ = other.dims_;
                        dims_.makeImmutable();
                        bitField0_ |= 0x00000004;
                    } else {
                        ensureDimsIsMutable();
                        dims_.addAll(other.dims_);
                    }
                    onChanged();
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                input.readMessage(
                                    internalGetValuesFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 18: {
                                input.readMessage(
                                    internalGetIndicesFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 18
                            case 24: {
                                long v = input.readInt64();
                                ensureDimsIsMutable();
                                dims_.addLong(v);
                                break;
                            } // case 24
                            case 26: {
                                int length = input.readRawVarint32();
                                int limit = input.pushLimit(length);
                                ensureDimsIsMutable();
                                while (input.getBytesUntilLimit() > 0) {
                                    dims_.addLong(input.readInt64());
                                }
                                input.popLimit(limit);
                                break;
                            } // case 26
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto values_;
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder> valuesBuilder_;
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
             * @return Whether the values field is set.
             */
            public boolean hasValues() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
             * @return The values.
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getValues() {
                if (valuesBuilder_ == null) {
                    return values_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance() : values_;
                } else {
                    return valuesBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
             */
            public Builder setValues(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto value) {
                if (valuesBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    values_ = value;
                } else {
                    valuesBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
             */
            public Builder setValues(
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder builderForValue) {
                if (valuesBuilder_ == null) {
                    values_ = builderForValue.build();
                } else {
                    valuesBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
             */
            public Builder mergeValues(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto value) {
                if (valuesBuilder_ == null) {
                    if (((bitField0_ & 0x00000001) != 0) &&
                        values_ != null &&
                        values_ != org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance()) {
                        getValuesBuilder().mergeFrom(value);
                    } else {
                        values_ = value;
                    }
                } else {
                    valuesBuilder_.mergeFrom(value);
                }
                if (values_ != null) {
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                return this;
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
             */
            public Builder clearValues() {
                bitField0_ = (bitField0_ & ~0x00000001);
                values_ = null;
                if (valuesBuilder_ != null) {
                    valuesBuilder_.dispose();
                    valuesBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder getValuesBuilder() {
                bitField0_ |= 0x00000001;
                onChanged();
                return internalGetValuesFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder getValuesOrBuilder() {
                if (valuesBuilder_ != null) {
                    return valuesBuilder_.getMessageOrBuilder();
                } else {
                    return values_ == null ?
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance() : values_;
                }
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto values = 1;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder>
            internalGetValuesFieldBuilder() {
                if (valuesBuilder_ == null) {
                    valuesBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder>(
                        getValues(),
                        getParentForChildren(),
                        isClean());
                    values_ = null;
                }
                return valuesBuilder_;
            }
            
            private org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto indices_;
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder, ProtoOnnx.TensorProtoOrBuilder> indicesBuilder_;
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
             * @return Whether the indices field is set.
             */
            public boolean hasIndices() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
             * @return The indices.
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto getIndices() {
                if (indicesBuilder_ == null) {
                    return indices_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance() : indices_;
                } else {
                    return indicesBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
             */
            public Builder setIndices(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto value) {
                if (indicesBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    indices_ = value;
                } else {
                    indicesBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
             */
            public Builder setIndices(
                ProtoOnnx.TensorProto.Builder builderForValue) {
                if (indicesBuilder_ == null) {
                    indices_ = builderForValue.build();
                } else {
                    indicesBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
             */
            public Builder mergeIndices(org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto value) {
                if (indicesBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0) &&
                        indices_ != null &&
                        indices_ != org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.getDefaultInstance()) {
                        getIndicesBuilder().mergeFrom(value);
                    } else {
                        indices_ = value;
                    }
                } else {
                    indicesBuilder_.mergeFrom(value);
                }
                if (indices_ != null) {
                    bitField0_ |= 0x00000002;
                    onChanged();
                }
                return this;
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
             */
            public Builder clearIndices() {
                bitField0_ = (bitField0_ & ~0x00000002);
                indices_ = null;
                if (indicesBuilder_ != null) {
                    indicesBuilder_.dispose();
                    indicesBuilder_ = null;
                }
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
             */
            public ProtoOnnx.TensorProto.Builder getIndicesBuilder() {
                bitField0_ |= 0x00000002;
                onChanged();
                return internalGetIndicesFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder getIndicesOrBuilder() {
                if (indicesBuilder_ != null) {
                    return indicesBuilder_.getMessageOrBuilder();
                } else {
                    return indices_ == null ?
                        ProtoOnnx.TensorProto.getDefaultInstance() : indices_;
                }
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TensorProto indices = 2;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder>
            internalGetIndicesFieldBuilder() {
                if (indicesBuilder_ == null) {
                    indicesBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorProto, ProtoOnnx.TensorProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorProtoOrBuilder>(
                        getIndices(),
                        getParentForChildren(),
                        isClean());
                    indices_ = null;
                }
                return indicesBuilder_;
            }
            
            private com.google.protobuf.Internal.LongList dims_ = emptyLongList();
            private void ensureDimsIsMutable() {
                if (!dims_.isModifiable()) {
                    dims_ = makeMutableCopy(dims_);
                }
                bitField0_ |= 0x00000004;
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @return A list containing the dims.
             */
            public java.util.List<java.lang.Long>
            getDimsList() {
                dims_.makeImmutable();
                return dims_;
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @return The count of dims.
             */
            public int getDimsCount() {
                return dims_.size();
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @param index The index of the element to return.
             * @return The dims at the given index.
             */
            public long getDims(int index) {
                return dims_.getLong(index);
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @param index The index to set the value at.
             * @param value The dims to set.
             * @return This builder for chaining.
             */
            public Builder setDims(
                int index, long value) {
                
                ensureDimsIsMutable();
                dims_.setLong(index, value);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @param value The dims to add.
             * @return This builder for chaining.
             */
            public Builder addDims(long value) {
                
                ensureDimsIsMutable();
                dims_.addLong(value);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @param values The dims to add.
             * @return This builder for chaining.
             */
            public Builder addAllDims(
                java.lang.Iterable<? extends java.lang.Long> values) {
                ensureDimsIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, dims_);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearDims() {
                dims_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000004);
                onChanged();
                return this;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.SparseTensorProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.SparseTensorProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<SparseTensorProto>
            PARSER = new com.google.protobuf.AbstractParser<SparseTensorProto>() {
            @java.lang.Override
            public SparseTensorProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<SparseTensorProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<SparseTensorProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.SparseTensorProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface TensorShapeProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TensorShapeProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension>
        getDimList();
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension getDim(int index);
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        int getDimCount();
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.DimensionOrBuilder>
        getDimOrBuilderList();
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        ProtoOnnx.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
            int index);
    }
    /**
     * <pre>
     * Defines a tensor shape. A dimension can be either an integer value
     * or a symbolic variable. A symbolic variable represents an unknown
     * dimension.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.TensorShapeProto}
     */
    public static final class TensorShapeProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TensorShapeProto)
        TensorShapeProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                TensorShapeProto.class.getName());
        }
        // Use TensorShapeProto.newBuilder() to construct.
        private TensorShapeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private TensorShapeProto() {
            dim_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorShapeProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ProtoOnnx.internal_static_onnx_TensorShapeProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Builder.class);
        }
        
        public interface DimensionOrBuilder extends
            // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TensorShapeProto.Dimension)
            com.google.protobuf.MessageOrBuilder {
            
            /**
             * <code>int64 dim_value = 1;</code>
             * @return Whether the dimValue field is set.
             */
            boolean hasDimValue();
            /**
             * <code>int64 dim_value = 1;</code>
             * @return The dimValue.
             */
            long getDimValue();
            
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return Whether the dimParam field is set.
             */
            boolean hasDimParam();
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return The dimParam.
             */
            java.lang.String getDimParam();
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return The bytes for dimParam.
             */
            com.google.protobuf.ByteString
            getDimParamBytes();
            
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return Whether the denotation field is set.
             */
            boolean hasDenotation();
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return The denotation.
             */
            java.lang.String getDenotation();
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return The bytes for denotation.
             */
            com.google.protobuf.ByteString
            getDenotationBytes();
            
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.ValueCase getValueCase();
        }
        /**
         * Protobuf type {@code org.brain4j.core.importing.onnx.TensorShapeProto.Dimension}
         */
        public static final class Dimension extends
            com.google.protobuf.GeneratedMessage implements
            // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TensorShapeProto.Dimension)
            DimensionOrBuilder {
            private static final long serialVersionUID = 0L;
            static {
                com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                    com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 31,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    Dimension.class.getName());
            }
            // Use Dimension.newBuilder() to construct.
            private Dimension(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
                super(builder);
            }
            private Dimension() {
                denotation_ = "";
            }
            
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorShapeProto_Dimension_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        ProtoOnnx.TensorShapeProto.Dimension.class, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder.class);
            }
            
            private int bitField0_;
            private int valueCase_ = 0;
            @SuppressWarnings("serial")
            private java.lang.Object value_;
            public enum ValueCase
                implements com.google.protobuf.Internal.EnumLite,
                com.google.protobuf.AbstractMessage.InternalOneOfEnum {
                DIM_VALUE(1),
                DIM_PARAM(2),
                VALUE_NOT_SET(0);
                private final int value;
                private ValueCase(int value) {
                    this.value = value;
                }
                /**
                 * @param value The number of the enum to look for.
                 * @return The enum associated with the given number.
                 * @deprecated Use {@link #forNumber(int)} instead.
                 */
                @java.lang.Deprecated
                public static ValueCase valueOf(int value) {
                    return forNumber(value);
                }
                
                public static ValueCase forNumber(int value) {
                    switch (value) {
                        case 1: return DIM_VALUE;
                        case 2: return DIM_PARAM;
                        case 0: return VALUE_NOT_SET;
                        default: return null;
                    }
                }
                public int getNumber() {
                    return this.value;
                }
            };
            
            public ValueCase
            getValueCase() {
                return ValueCase.forNumber(
                    valueCase_);
            }
            
            public static final int DIM_VALUE_FIELD_NUMBER = 1;
            /**
             * <code>int64 dim_value = 1;</code>
             * @return Whether the dimValue field is set.
             */
            @java.lang.Override
            public boolean hasDimValue() {
                return valueCase_ == 1;
            }
            /**
             * <code>int64 dim_value = 1;</code>
             * @return The dimValue.
             */
            @java.lang.Override
            public long getDimValue() {
                if (valueCase_ == 1) {
                    return (java.lang.Long) value_;
                }
                return 0L;
            }
            
            public static final int DIM_PARAM_FIELD_NUMBER = 2;
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return Whether the dimParam field is set.
             */
            public boolean hasDimParam() {
                return valueCase_ == 2;
            }
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return The dimParam.
             */
            public java.lang.String getDimParam() {
                java.lang.Object ref = "";
                if (valueCase_ == 2) {
                    ref = value_;
                }
                if (ref instanceof java.lang.String) {
                    return (java.lang.String) ref;
                } else {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8() && (valueCase_ == 2)) {
                        value_ = s;
                    }
                    return s;
                }
            }
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return The bytes for dimParam.
             */
            public com.google.protobuf.ByteString
            getDimParamBytes() {
                java.lang.Object ref = "";
                if (valueCase_ == 2) {
                    ref = value_;
                }
                if (ref instanceof java.lang.String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    if (valueCase_ == 2) {
                        value_ = b;
                    }
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            
            public static final int DENOTATION_FIELD_NUMBER = 3;
            @SuppressWarnings("serial")
            private volatile java.lang.Object denotation_ = "";
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return Whether the denotation field is set.
             */
            @java.lang.Override
            public boolean hasDenotation() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return The denotation.
             */
            @java.lang.Override
            public java.lang.String getDenotation() {
                java.lang.Object ref = denotation_;
                if (ref instanceof java.lang.String) {
                    return (java.lang.String) ref;
                } else {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        denotation_ = s;
                    }
                    return s;
                }
            }
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return The bytes for denotation.
             */
            @java.lang.Override
            public com.google.protobuf.ByteString
            getDenotationBytes() {
                java.lang.Object ref = denotation_;
                if (ref instanceof java.lang.String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    denotation_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            
            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;
                
                memoizedIsInitialized = 1;
                return true;
            }
            
            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
                if (valueCase_ == 1) {
                    output.writeInt64(
                        1, (long)((java.lang.Long) value_));
                }
                if (valueCase_ == 2) {
                    com.google.protobuf.GeneratedMessage.writeString(output, 2, value_);
                }
                if (((bitField0_ & 0x00000001) != 0)) {
                    com.google.protobuf.GeneratedMessage.writeString(output, 3, denotation_);
                }
                getUnknownFields().writeTo(output);
            }
            
            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;
                
                size = 0;
                if (valueCase_ == 1) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt64Size(
                            1, (long)((java.lang.Long) value_));
                }
                if (valueCase_ == 2) {
                    size += com.google.protobuf.GeneratedMessage.computeStringSize(2, value_);
                }
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.GeneratedMessage.computeStringSize(3, denotation_);
                }
                size += getUnknownFields().getSerializedSize();
                memoizedSize = size;
                return size;
            }
            
            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof Dimension other)) {
                    return super.equals(obj);
                }
                
                if (hasDenotation() != other.hasDenotation()) return false;
                if (hasDenotation()) {
                    if (!getDenotation()
                        .equals(other.getDenotation())) return false;
                }
                if (!getValueCase().equals(other.getValueCase())) return false;
                switch (valueCase_) {
                    case 1:
                        if (getDimValue()
                            != other.getDimValue()) return false;
                        break;
                    case 2:
                        if (!getDimParam()
                            .equals(other.getDimParam())) return false;
                        break;
                    case 0:
                    default:
                }
                if (!getUnknownFields().equals(other.getUnknownFields())) return false;
                return true;
            }
            
            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasDenotation()) {
                    hash = (37 * hash) + DENOTATION_FIELD_NUMBER;
                    hash = (53 * hash) + getDenotation().hashCode();
                }
                switch (valueCase_) {
                    case 1:
                        hash = (37 * hash) + DIM_VALUE_FIELD_NUMBER;
                        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                            getDimValue());
                        break;
                    case 2:
                        hash = (37 * hash) + DIM_PARAM_FIELD_NUMBER;
                        hash = (53 * hash) + getDimParam().hashCode();
                        break;
                    case 0:
                    default:
                }
                hash = (29 * hash) + getUnknownFields().hashCode();
                memoizedHashCode = hash;
                return hash;
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ProtoOnnx.TensorShapeProto.Dimension parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ProtoOnnx.TensorShapeProto.Dimension parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension parseFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            public static ProtoOnnx.TensorShapeProto.Dimension parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static ProtoOnnx.TensorShapeProto.Dimension parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static ProtoOnnx.TensorShapeProto.Dimension parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
            }
            
            @java.lang.Override
            protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * Protobuf type {@code org.brain4j.core.importing.onnx.TensorShapeProto.Dimension}
             */
            public static final class Builder extends
                com.google.protobuf.GeneratedMessage.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TensorShapeProto.Dimension)
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.DimensionOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorShapeProto_Dimension_descriptor;
                }
                
                @java.lang.Override
                protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                            org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.class, ProtoOnnx.TensorShapeProto.Dimension.Builder.class);
                }
                
                // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.newBuilder()
                private Builder() {
                
                }
                
                private Builder(
                    com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                    super(parent);
                    
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    bitField0_ = 0;
                    denotation_ = "";
                    valueCase_ = 0;
                    value_ = null;
                    return this;
                }
                
                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorShapeProto_Dimension_descriptor;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension getDefaultInstanceForType() {
                    return ProtoOnnx.TensorShapeProto.Dimension.getDefaultInstance();
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension build() {
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension buildPartial() {
                    ProtoOnnx.TensorShapeProto.Dimension result = new org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension(this);
                    if (bitField0_ != 0) { buildPartial0(result); }
                    buildPartialOneofs(result);
                    onBuilt();
                    return result;
                }
                
                private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension result) {
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000004) != 0)) {
                        result.denotation_ = denotation_;
                        to_bitField0_ |= 0x00000001;
                    }
                    result.bitField0_ |= to_bitField0_;
                }
                
                private void buildPartialOneofs(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension result) {
                    result.valueCase_ = valueCase_;
                    result.value_ = this.value_;
                }
                
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof ProtoOnnx.TensorShapeProto.Dimension) {
                        return mergeFrom((ProtoOnnx.TensorShapeProto.Dimension)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }
                
                public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension other) {
                    if (other == ProtoOnnx.TensorShapeProto.Dimension.getDefaultInstance()) return this;
                    if (other.hasDenotation()) {
                        denotation_ = other.denotation_;
                        bitField0_ |= 0x00000004;
                        onChanged();
                    }
                    switch (other.getValueCase()) {
                        case DIM_VALUE: {
                            setDimValue(other.getDimValue());
                            break;
                        }
                        case DIM_PARAM: {
                            valueCase_ = 2;
                            value_ = other.value_;
                            onChanged();
                            break;
                        }
                        case VALUE_NOT_SET: {
                            break;
                        }
                    }
                    this.mergeUnknownFields(other.getUnknownFields());
                    onChanged();
                    return this;
                }
                
                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }
                
                @java.lang.Override
                public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                    if (extensionRegistry == null) {
                        throw new java.lang.NullPointerException();
                    }
                    try {
                        boolean done = false;
                        while (!done) {
                            int tag = input.readTag();
                            switch (tag) {
                                case 0:
                                    done = true;
                                    break;
                                case 8: {
                                    value_ = input.readInt64();
                                    valueCase_ = 1;
                                    break;
                                } // case 8
                                case 18: {
                                    com.google.protobuf.ByteString bs = input.readBytes();
                                    valueCase_ = 2;
                                    value_ = bs;
                                    break;
                                } // case 18
                                case 26: {
                                    denotation_ = input.readBytes();
                                    bitField0_ |= 0x00000004;
                                    break;
                                } // case 26
                                default: {
                                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                        done = true; // was an endgroup tag
                                    }
                                    break;
                                } // default:
                            } // switch (tag)
                        } // while (!done)
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.unwrapIOException();
                    } finally {
                        onChanged();
                    } // finally
                    return this;
                }
                private int valueCase_ = 0;
                private java.lang.Object value_;
                public ValueCase
                getValueCase() {
                    return ValueCase.forNumber(
                        valueCase_);
                }
                
                public Builder clearValue() {
                    valueCase_ = 0;
                    value_ = null;
                    onChanged();
                    return this;
                }
                
                private int bitField0_;
                
                /**
                 * <code>int64 dim_value = 1;</code>
                 * @return Whether the dimValue field is set.
                 */
                public boolean hasDimValue() {
                    return valueCase_ == 1;
                }
                /**
                 * <code>int64 dim_value = 1;</code>
                 * @return The dimValue.
                 */
                public long getDimValue() {
                    if (valueCase_ == 1) {
                        return (java.lang.Long) value_;
                    }
                    return 0L;
                }
                /**
                 * <code>int64 dim_value = 1;</code>
                 * @param value The dimValue to set.
                 * @return This builder for chaining.
                 */
                public Builder setDimValue(long value) {
                    
                    valueCase_ = 1;
                    value_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <code>int64 dim_value = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearDimValue() {
                    if (valueCase_ == 1) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                    return this;
                }
                
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @return Whether the dimParam field is set.
                 */
                @java.lang.Override
                public boolean hasDimParam() {
                    return valueCase_ == 2;
                }
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @return The dimParam.
                 */
                @java.lang.Override
                public java.lang.String getDimParam() {
                    java.lang.Object ref = "";
                    if (valueCase_ == 2) {
                        ref = value_;
                    }
                    if (!(ref instanceof java.lang.String)) {
                        com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                        java.lang.String s = bs.toStringUtf8();
                        if (valueCase_ == 2) {
                            if (bs.isValidUtf8()) {
                                value_ = s;
                            }
                        }
                        return s;
                    } else {
                        return (java.lang.String) ref;
                    }
                }
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @return The bytes for dimParam.
                 */
                @java.lang.Override
                public com.google.protobuf.ByteString
                getDimParamBytes() {
                    java.lang.Object ref = "";
                    if (valueCase_ == 2) {
                        ref = value_;
                    }
                    if (ref instanceof String) {
                        com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                        if (valueCase_ == 2) {
                            value_ = b;
                        }
                        return b;
                    } else {
                        return (com.google.protobuf.ByteString) ref;
                    }
                }
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @param value The dimParam to set.
                 * @return This builder for chaining.
                 */
                public Builder setDimParam(
                    java.lang.String value) {
                    if (value == null) { throw new NullPointerException(); }
                    valueCase_ = 2;
                    value_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearDimParam() {
                    if (valueCase_ == 2) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                    return this;
                }
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @param value The bytes for dimParam to set.
                 * @return This builder for chaining.
                 */
                public Builder setDimParamBytes(
                    com.google.protobuf.ByteString value) {
                    if (value == null) { throw new NullPointerException(); }
                    valueCase_ = 2;
                    value_ = value;
                    onChanged();
                    return this;
                }
                
                private java.lang.Object denotation_ = "";
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @return Whether the denotation field is set.
                 */
                public boolean hasDenotation() {
                    return ((bitField0_ & 0x00000004) != 0);
                }
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @return The denotation.
                 */
                public java.lang.String getDenotation() {
                    java.lang.Object ref = denotation_;
                    if (!(ref instanceof java.lang.String)) {
                        com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                        java.lang.String s = bs.toStringUtf8();
                        if (bs.isValidUtf8()) {
                            denotation_ = s;
                        }
                        return s;
                    } else {
                        return (java.lang.String) ref;
                    }
                }
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @return The bytes for denotation.
                 */
                public com.google.protobuf.ByteString
                getDenotationBytes() {
                    java.lang.Object ref = denotation_;
                    if (ref instanceof String) {
                        com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                        denotation_ = b;
                        return b;
                    } else {
                        return (com.google.protobuf.ByteString) ref;
                    }
                }
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @param value The denotation to set.
                 * @return This builder for chaining.
                 */
                public Builder setDenotation(
                    java.lang.String value) {
                    if (value == null) { throw new NullPointerException(); }
                    denotation_ = value;
                    bitField0_ |= 0x00000004;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearDenotation() {
                    denotation_ = getDefaultInstance().getDenotation();
                    bitField0_ = (bitField0_ & ~0x00000004);
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @param value The bytes for denotation to set.
                 * @return This builder for chaining.
                 */
                public Builder setDenotationBytes(
                    com.google.protobuf.ByteString value) {
                    if (value == null) { throw new NullPointerException(); }
                    denotation_ = value;
                    bitField0_ |= 0x00000004;
                    onChanged();
                    return this;
                }
                
                // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TensorShapeProto.Dimension)
            }
            
            // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TensorShapeProto.Dimension)
            private static final org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension();
            }
            
            public static ProtoOnnx.TensorShapeProto.Dimension getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }
            
            private static final com.google.protobuf.Parser<Dimension>
                PARSER = new com.google.protobuf.AbstractParser<Dimension>() {
                @java.lang.Override
                public Dimension parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                    Builder builder = newBuilder();
                    try {
                        builder.mergeFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.setUnfinishedMessage(builder.buildPartial());
                    } catch (com.google.protobuf.UninitializedMessageException e) {
                        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                    } catch (java.io.IOException e) {
                        throw new com.google.protobuf.InvalidProtocolBufferException(e)
                            .setUnfinishedMessage(builder.buildPartial());
                    }
                    return builder.buildPartial();
                }
            };
            
            public static com.google.protobuf.Parser<Dimension> parser() {
                return PARSER;
            }
            
            @java.lang.Override
            public com.google.protobuf.Parser<Dimension> getParserForType() {
                return PARSER;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }
            
        }
        
        public static final int DIM_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension> dim_;
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension> getDimList() {
            return dim_;
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.DimensionOrBuilder>
        getDimOrBuilderList() {
            return dim_;
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        @java.lang.Override
        public int getDimCount() {
            return dim_.size();
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension getDim(int index) {
            return dim_.get(index);
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
            int index) {
            return dim_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            for (int i = 0; i < dim_.size(); i++) {
                output.writeMessage(1, dim_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            for (int i = 0; i < dim_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(1, dim_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto) obj;
            
            if (!getDimList()
                .equals(other.getDimList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getDimCount() > 0) {
                hash = (37 * hash) + DIM_FIELD_NUMBER;
                hash = (53 * hash) + getDimList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static ProtoOnnx.TensorShapeProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ProtoOnnx.TensorShapeProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ProtoOnnx.TensorShapeProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Defines a tensor shape. A dimension can be either an integer value
         * or a symbolic variable. A symbolic variable represents an unknown
         * dimension.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.TensorShapeProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TensorShapeProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorShapeProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorShapeProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                if (dimBuilder_ == null) {
                    dim_ = java.util.Collections.emptyList();
                } else {
                    dim_ = null;
                    dimBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000001);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TensorShapeProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto getDefaultInstanceForType() {
                return ProtoOnnx.TensorShapeProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto result) {
                if (dimBuilder_ == null) {
                    if (((bitField0_ & 0x00000001) != 0)) {
                        dim_ = java.util.Collections.unmodifiableList(dim_);
                        bitField0_ = (bitField0_ & ~0x00000001);
                    }
                    result.dim_ = dim_;
                } else {
                    result.dim_ = dimBuilder_.build();
                }
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto result) {
                int from_bitField0_ = bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto) {
                    return mergeFrom((ProtoOnnx.TensorShapeProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(ProtoOnnx.TensorShapeProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.getDefaultInstance()) return this;
                if (dimBuilder_ == null) {
                    if (!other.dim_.isEmpty()) {
                        if (dim_.isEmpty()) {
                            dim_ = other.dim_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                        } else {
                            ensureDimIsMutable();
                            dim_.addAll(other.dim_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.dim_.isEmpty()) {
                        if (dimBuilder_.isEmpty()) {
                            dimBuilder_.dispose();
                            dimBuilder_ = null;
                            dim_ = other.dim_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                            dimBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetDimFieldBuilder() : null;
                        } else {
                            dimBuilder_.addAllMessages(other.dim_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.parser(),
                                        extensionRegistry);
                                if (dimBuilder_ == null) {
                                    ensureDimIsMutable();
                                    dim_.add(m);
                                } else {
                                    dimBuilder_.addMessage(m);
                                }
                                break;
                            } // case 10
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension> dim_ =
                java.util.Collections.emptyList();
            private void ensureDimIsMutable() {
                if (!((bitField0_ & 0x00000001) != 0)) {
                    dim_ = new java.util.ArrayList<ProtoOnnx.TensorShapeProto.Dimension>(dim_);
                    bitField0_ |= 0x00000001;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.DimensionOrBuilder> dimBuilder_;
            
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension> getDimList() {
                if (dimBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(dim_);
                } else {
                    return dimBuilder_.getMessageList();
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public int getDimCount() {
                if (dimBuilder_ == null) {
                    return dim_.size();
                } else {
                    return dimBuilder_.getCount();
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension getDim(int index) {
                if (dimBuilder_ == null) {
                    return dim_.get(index);
                } else {
                    return dimBuilder_.getMessage(index);
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder setDim(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension value) {
                if (dimBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureDimIsMutable();
                    dim_.set(index, value);
                    onChanged();
                } else {
                    dimBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder setDim(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder builderForValue) {
                if (dimBuilder_ == null) {
                    ensureDimIsMutable();
                    dim_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    dimBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder addDim(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension value) {
                if (dimBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureDimIsMutable();
                    dim_.add(value);
                    onChanged();
                } else {
                    dimBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder addDim(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension value) {
                if (dimBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureDimIsMutable();
                    dim_.add(index, value);
                    onChanged();
                } else {
                    dimBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder addDim(
                org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder builderForValue) {
                if (dimBuilder_ == null) {
                    ensureDimIsMutable();
                    dim_.add(builderForValue.build());
                    onChanged();
                } else {
                    dimBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder addDim(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder builderForValue) {
                if (dimBuilder_ == null) {
                    ensureDimIsMutable();
                    dim_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    dimBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder addAllDim(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension> values) {
                if (dimBuilder_ == null) {
                    ensureDimIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, dim_);
                    onChanged();
                } else {
                    dimBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder clearDim() {
                if (dimBuilder_ == null) {
                    dim_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000001);
                    onChanged();
                } else {
                    dimBuilder_.clear();
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder removeDim(int index) {
                if (dimBuilder_ == null) {
                    ensureDimIsMutable();
                    dim_.remove(index);
                    onChanged();
                } else {
                    dimBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder getDimBuilder(
                int index) {
                return internalGetDimFieldBuilder().getBuilder(index);
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
                int index) {
                if (dimBuilder_ == null) {
                    return dim_.get(index);  } else {
                    return dimBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.DimensionOrBuilder>
            getDimOrBuilderList() {
                if (dimBuilder_ != null) {
                    return dimBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(dim_);
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder addDimBuilder() {
                return internalGetDimFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.getDefaultInstance());
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder addDimBuilder(
                int index) {
                return internalGetDimFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.getDefaultInstance());
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder>
            getDimBuilderList() {
                return internalGetDimFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.TensorShapeProto.Dimension, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.DimensionOrBuilder>
            internalGetDimFieldBuilder() {
                if (dimBuilder_ == null) {
                    dimBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Dimension.Builder, ProtoOnnx.TensorShapeProto.DimensionOrBuilder>(
                        dim_,
                        ((bitField0_ & 0x00000001) != 0),
                        getParentForChildren(),
                        isClean());
                    dim_ = null;
                }
                return dimBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TensorShapeProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TensorShapeProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<TensorShapeProto>
            PARSER = new com.google.protobuf.AbstractParser<TensorShapeProto>() {
            @java.lang.Override
            public TensorShapeProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<TensorShapeProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<TensorShapeProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface TypeProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TypeProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
         * @return Whether the tensorType field is set.
         */
        boolean hasTensorType();
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
         * @return The tensorType.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor getTensorType();
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
         */
        ProtoOnnx.TypeProto.TensorOrBuilder getTensorTypeOrBuilder();
        
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
         * @return Whether the sequenceType field is set.
         */
        boolean hasSequenceType();
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
         * @return The sequenceType.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence getSequenceType();
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder();
        
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
         * @return Whether the mapType field is set.
         */
        boolean hasMapType();
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
         * @return The mapType.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map getMapType();
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.MapOrBuilder getMapTypeOrBuilder();
        
        /**
         * <pre>
         * The type of an optional.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
         * @return Whether the optionalType field is set.
         */
        boolean hasOptionalType();
        /**
         * <pre>
         * The type of an optional.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
         * @return The optionalType.
         */
        ProtoOnnx.TypeProto.Optional getOptionalType();
        /**
         * <pre>
         * The type of an optional.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.OptionalOrBuilder getOptionalTypeOrBuilder();
        
        /**
         * <pre>
         * Type of the sparse tensor
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         * @return Whether the sparseTensorType field is set.
         */
        boolean hasSparseTensorType();
        /**
         * <pre>
         * Type of the sparse tensor
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         * @return The sparseTensorType.
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor getSparseTensorType();
        /**
         * <pre>
         * Type of the sparse tensor
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder();
        
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return Whether the denotation field is set.
         */
        boolean hasDenotation();
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return The denotation.
         */
        java.lang.String getDenotation();
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return The bytes for denotation.
         */
        com.google.protobuf.ByteString
        getDenotationBytes();
        
        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.ValueCase getValueCase();
    }
    /**
     * <pre>
     * Types
     *
     * The standard ONNX data types.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto}
     */
    public static final class TypeProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TypeProto)
        TypeProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                TypeProto.class.getName());
        }
        // Use TypeProto.newBuilder() to construct.
        private TypeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private TypeProto() {
            denotation_ = "";
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ProtoOnnx.internal_static_onnx_TypeProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder.class);
        }
        
        public interface TensorOrBuilder extends
            // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TypeProto.Tensor)
            com.google.protobuf.MessageOrBuilder {
            
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            boolean hasElemType();
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return The elemType.
             */
            int getElemType();
            
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             * @return Whether the shape field is set.
             */
            boolean hasShape();
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             * @return The shape.
             */
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto getShape();
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             */
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder getShapeOrBuilder();
        }
        /**
         * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto.Tensor}
         */
        public static final class Tensor extends
            com.google.protobuf.GeneratedMessage implements
            // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TypeProto.Tensor)
            TensorOrBuilder {
            private static final long serialVersionUID = 0L;
            static {
                com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                    com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 31,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    Tensor.class.getName());
            }
            // Use Tensor.newBuilder() to construct.
            private Tensor(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
                super(builder);
            }
            private Tensor() {
            }
            
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Tensor_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Tensor_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.class, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.Builder.class);
            }
            
            private int bitField0_;
            public static final int ELEM_TYPE_FIELD_NUMBER = 1;
            private int elemType_ = 0;
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            @java.lang.Override
            public boolean hasElemType() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return The elemType.
             */
            @java.lang.Override
            public int getElemType() {
                return elemType_;
            }
            
            public static final int SHAPE_FIELD_NUMBER = 2;
            private org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto shape_;
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             * @return Whether the shape field is set.
             */
            @java.lang.Override
            public boolean hasShape() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             * @return The shape.
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto getShape() {
                return shape_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.getDefaultInstance() : shape_;
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder getShapeOrBuilder() {
                return shape_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.getDefaultInstance() : shape_;
            }
            
            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;
                
                memoizedIsInitialized = 1;
                return true;
            }
            
            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeInt32(1, elemType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    output.writeMessage(2, getShape());
                }
                getUnknownFields().writeTo(output);
            }
            
            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;
                
                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt32Size(1, elemType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(2, getShape());
                }
                size += getUnknownFields().getSerializedSize();
                memoizedSize = size;
                return size;
            }
            
            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor)) {
                    return super.equals(obj);
                }
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor other = (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor) obj;
                
                if (hasElemType() != other.hasElemType()) return false;
                if (hasElemType()) {
                    if (getElemType()
                        != other.getElemType()) return false;
                }
                if (hasShape() != other.hasShape()) return false;
                if (hasShape()) {
                    if (!getShape()
                        .equals(other.getShape())) return false;
                }
                if (!getUnknownFields().equals(other.getUnknownFields())) return false;
                return true;
            }
            
            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasElemType()) {
                    hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getElemType();
                }
                if (hasShape()) {
                    hash = (37 * hash) + SHAPE_FIELD_NUMBER;
                    hash = (53 * hash) + getShape().hashCode();
                }
                hash = (29 * hash) + getUnknownFields().hashCode();
                memoizedHashCode = hash;
                return hash;
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
            }
            
            @java.lang.Override
            protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto.Tensor}
             */
            public static final class Builder extends
                com.google.protobuf.GeneratedMessage.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TypeProto.Tensor)
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.TensorOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Tensor_descriptor;
                }
                
                @java.lang.Override
                protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Tensor_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.class, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.Builder.class);
                }
                
                // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }
                
                private Builder(
                    com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessage
                        .alwaysUseFieldBuilders) {
                        internalGetShapeFieldBuilder();
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    bitField0_ = 0;
                    elemType_ = 0;
                    shape_ = null;
                    if (shapeBuilder_ != null) {
                        shapeBuilder_.dispose();
                        shapeBuilder_ = null;
                    }
                    return this;
                }
                
                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return ProtoOnnx.internal_static_onnx_TypeProto_Tensor_descriptor;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor getDefaultInstanceForType() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.getDefaultInstance();
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor build() {
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor buildPartial() {
                    ProtoOnnx.TypeProto.Tensor result = new ProtoOnnx.TypeProto.Tensor(this);
                    if (bitField0_ != 0) { buildPartial0(result); }
                    onBuilt();
                    return result;
                }
                
                private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor result) {
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        result.elemType_ = elemType_;
                        to_bitField0_ |= 0x00000001;
                    }
                    if (((from_bitField0_ & 0x00000002) != 0)) {
                        result.shape_ = shapeBuilder_ == null
                            ? shape_
                            : shapeBuilder_.build();
                        to_bitField0_ |= 0x00000002;
                    }
                    result.bitField0_ |= to_bitField0_;
                }
                
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor) {
                        return mergeFrom((ProtoOnnx.TypeProto.Tensor)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }
                
                public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor other) {
                    if (other == org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.getDefaultInstance()) return this;
                    if (other.hasElemType()) {
                        setElemType(other.getElemType());
                    }
                    if (other.hasShape()) {
                        mergeShape(other.getShape());
                    }
                    this.mergeUnknownFields(other.getUnknownFields());
                    onChanged();
                    return this;
                }
                
                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }
                
                @java.lang.Override
                public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                    if (extensionRegistry == null) {
                        throw new java.lang.NullPointerException();
                    }
                    try {
                        boolean done = false;
                        while (!done) {
                            int tag = input.readTag();
                            switch (tag) {
                                case 0:
                                    done = true;
                                    break;
                                case 8: {
                                    elemType_ = input.readInt32();
                                    bitField0_ |= 0x00000001;
                                    break;
                                } // case 8
                                case 18: {
                                    input.readMessage(
                                        internalGetShapeFieldBuilder().getBuilder(),
                                        extensionRegistry);
                                    bitField0_ |= 0x00000002;
                                    break;
                                } // case 18
                                default: {
                                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                        done = true; // was an endgroup tag
                                    }
                                    break;
                                } // default:
                            } // switch (tag)
                        } // while (!done)
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.unwrapIOException();
                    } finally {
                        onChanged();
                    } // finally
                    return this;
                }
                private int bitField0_;
                
                private int elemType_ ;
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return Whether the elemType field is set.
                 */
                @java.lang.Override
                public boolean hasElemType() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return The elemType.
                 */
                @java.lang.Override
                public int getElemType() {
                    return elemType_;
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @param value The elemType to set.
                 * @return This builder for chaining.
                 */
                public Builder setElemType(int value) {
                    
                    elemType_ = value;
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearElemType() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    elemType_ = 0;
                    onChanged();
                    return this;
                }
                
                private org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto shape_;
                private com.google.protobuf.SingleFieldBuilder<
                    ProtoOnnx.TensorShapeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder> shapeBuilder_;
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 * @return Whether the shape field is set.
                 */
                public boolean hasShape() {
                    return ((bitField0_ & 0x00000002) != 0);
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 * @return The shape.
                 */
                public ProtoOnnx.TensorShapeProto getShape() {
                    if (shapeBuilder_ == null) {
                        return shape_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.getDefaultInstance() : shape_;
                    } else {
                        return shapeBuilder_.getMessage();
                    }
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder setShape(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto value) {
                    if (shapeBuilder_ == null) {
                        if (value == null) {
                            throw new NullPointerException();
                        }
                        shape_ = value;
                    } else {
                        shapeBuilder_.setMessage(value);
                    }
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return this;
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder setShape(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Builder builderForValue) {
                    if (shapeBuilder_ == null) {
                        shape_ = builderForValue.build();
                    } else {
                        shapeBuilder_.setMessage(builderForValue.build());
                    }
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return this;
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder mergeShape(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto value) {
                    if (shapeBuilder_ == null) {
                        if (((bitField0_ & 0x00000002) != 0) &&
                            shape_ != null &&
                            shape_ != org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.getDefaultInstance()) {
                            getShapeBuilder().mergeFrom(value);
                        } else {
                            shape_ = value;
                        }
                    } else {
                        shapeBuilder_.mergeFrom(value);
                    }
                    if (shape_ != null) {
                        bitField0_ |= 0x00000002;
                        onChanged();
                    }
                    return this;
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder clearShape() {
                    bitField0_ = (bitField0_ & ~0x00000002);
                    shape_ = null;
                    if (shapeBuilder_ != null) {
                        shapeBuilder_.dispose();
                        shapeBuilder_ = null;
                    }
                    onChanged();
                    return this;
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Builder getShapeBuilder() {
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return internalGetShapeFieldBuilder().getBuilder();
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder getShapeOrBuilder() {
                    if (shapeBuilder_ != null) {
                        return shapeBuilder_.getMessageOrBuilder();
                    } else {
                        return shape_ == null ?
                            ProtoOnnx.TensorShapeProto.getDefaultInstance() : shape_;
                    }
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                private com.google.protobuf.SingleFieldBuilder<
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder>
                internalGetShapeFieldBuilder() {
                    if (shapeBuilder_ == null) {
                        shapeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                            org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto, ProtoOnnx.TensorShapeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder>(
                            getShape(),
                            getParentForChildren(),
                            isClean());
                        shape_ = null;
                    }
                    return shapeBuilder_;
                }
                
                // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TypeProto.Tensor)
            }
            
            // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TypeProto.Tensor)
            private static final org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor();
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }
            
            private static final com.google.protobuf.Parser<Tensor>
                PARSER = new com.google.protobuf.AbstractParser<Tensor>() {
                @java.lang.Override
                public Tensor parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                    Builder builder = newBuilder();
                    try {
                        builder.mergeFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.setUnfinishedMessage(builder.buildPartial());
                    } catch (com.google.protobuf.UninitializedMessageException e) {
                        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                    } catch (java.io.IOException e) {
                        throw new com.google.protobuf.InvalidProtocolBufferException(e)
                            .setUnfinishedMessage(builder.buildPartial());
                    }
                    return builder.buildPartial();
                }
            };
            
            public static com.google.protobuf.Parser<Tensor> parser() {
                return PARSER;
            }
            
            @java.lang.Override
            public com.google.protobuf.Parser<Tensor> getParserForType() {
                return PARSER;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }
            
        }
        
        public interface SequenceOrBuilder extends
            // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TypeProto.Sequence)
            com.google.protobuf.MessageOrBuilder {
            
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            boolean hasElemType();
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             * @return The elemType.
             */
            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getElemType();
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             */
            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder getElemTypeOrBuilder();
        }
        /**
         * <pre>
         * repeated T
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto.Sequence}
         */
        public static final class Sequence extends
            com.google.protobuf.GeneratedMessage implements
            // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TypeProto.Sequence)
            SequenceOrBuilder {
            private static final long serialVersionUID = 0L;
            static {
                com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                    com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 31,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    Sequence.class.getName());
            }
            // Use Sequence.newBuilder() to construct.
            private Sequence(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
                super(builder);
            }
            private Sequence() {
            }
            
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Sequence_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Sequence_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.class, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.Builder.class);
            }
            
            private int bitField0_;
            public static final int ELEM_TYPE_FIELD_NUMBER = 1;
            private org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto elemType_;
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            @java.lang.Override
            public boolean hasElemType() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             * @return The elemType.
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getElemType() {
                return elemType_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : elemType_;
            }
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder getElemTypeOrBuilder() {
                return elemType_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : elemType_;
            }
            
            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;
                
                memoizedIsInitialized = 1;
                return true;
            }
            
            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeMessage(1, getElemType());
                }
                getUnknownFields().writeTo(output);
            }
            
            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;
                
                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(1, getElemType());
                }
                size += getUnknownFields().getSerializedSize();
                memoizedSize = size;
                return size;
            }
            
            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence)) {
                    return super.equals(obj);
                }
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence other = (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence) obj;
                
                if (hasElemType() != other.hasElemType()) return false;
                if (hasElemType()) {
                    if (!getElemType()
                        .equals(other.getElemType())) return false;
                }
                if (!getUnknownFields().equals(other.getUnknownFields())) return false;
                return true;
            }
            
            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasElemType()) {
                    hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getElemType().hashCode();
                }
                hash = (29 * hash) + getUnknownFields().hashCode();
                memoizedHashCode = hash;
                return hash;
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ProtoOnnx.TypeProto.Sequence parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ProtoOnnx.TypeProto.Sequence parseFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
            }
            
            @java.lang.Override
            protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * <pre>
             * repeated T
             * </pre>
             *
             * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto.Sequence}
             */
            public static final class Builder extends
                com.google.protobuf.GeneratedMessage.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TypeProto.Sequence)
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SequenceOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Sequence_descriptor;
                }
                
                @java.lang.Override
                protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Sequence_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                            ProtoOnnx.TypeProto.Sequence.class, ProtoOnnx.TypeProto.Sequence.Builder.class);
                }
                
                // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }
                
                private Builder(
                    com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessage
                        .alwaysUseFieldBuilders) {
                        internalGetElemTypeFieldBuilder();
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    bitField0_ = 0;
                    elemType_ = null;
                    if (elemTypeBuilder_ != null) {
                        elemTypeBuilder_.dispose();
                        elemTypeBuilder_ = null;
                    }
                    return this;
                }
                
                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Sequence_descriptor;
                }
                
                @java.lang.Override
                public ProtoOnnx.TypeProto.Sequence getDefaultInstanceForType() {
                    return ProtoOnnx.TypeProto.Sequence.getDefaultInstance();
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence build() {
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence buildPartial() {
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence result = new org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence(this);
                    if (bitField0_ != 0) { buildPartial0(result); }
                    onBuilt();
                    return result;
                }
                
                private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence result) {
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        result.elemType_ = elemTypeBuilder_ == null
                            ? elemType_
                            : elemTypeBuilder_.build();
                        to_bitField0_ |= 0x00000001;
                    }
                    result.bitField0_ |= to_bitField0_;
                }
                
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof ProtoOnnx.TypeProto.Sequence) {
                        return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }
                
                public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence other) {
                    if (other == org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.getDefaultInstance()) return this;
                    if (other.hasElemType()) {
                        mergeElemType(other.getElemType());
                    }
                    this.mergeUnknownFields(other.getUnknownFields());
                    onChanged();
                    return this;
                }
                
                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }
                
                @java.lang.Override
                public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                    if (extensionRegistry == null) {
                        throw new java.lang.NullPointerException();
                    }
                    try {
                        boolean done = false;
                        while (!done) {
                            int tag = input.readTag();
                            switch (tag) {
                                case 0:
                                    done = true;
                                    break;
                                case 10: {
                                    input.readMessage(
                                        internalGetElemTypeFieldBuilder().getBuilder(),
                                        extensionRegistry);
                                    bitField0_ |= 0x00000001;
                                    break;
                                } // case 10
                                default: {
                                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                        done = true; // was an endgroup tag
                                    }
                                    break;
                                } // default:
                            } // switch (tag)
                        } // while (!done)
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.unwrapIOException();
                    } finally {
                        onChanged();
                    } // finally
                    return this;
                }
                private int bitField0_;
                
                private ProtoOnnx.TypeProto elemType_;
                private com.google.protobuf.SingleFieldBuilder<
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, ProtoOnnx.TypeProtoOrBuilder> elemTypeBuilder_;
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 * @return Whether the elemType field is set.
                 */
                public boolean hasElemType() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 * @return The elemType.
                 */
                public ProtoOnnx.TypeProto getElemType() {
                    if (elemTypeBuilder_ == null) {
                        return elemType_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : elemType_;
                    } else {
                        return elemTypeBuilder_.getMessage();
                    }
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder setElemType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto value) {
                    if (elemTypeBuilder_ == null) {
                        if (value == null) {
                            throw new NullPointerException();
                        }
                        elemType_ = value;
                    } else {
                        elemTypeBuilder_.setMessage(value);
                    }
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder setElemType(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder builderForValue) {
                    if (elemTypeBuilder_ == null) {
                        elemType_ = builderForValue.build();
                    } else {
                        elemTypeBuilder_.setMessage(builderForValue.build());
                    }
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder mergeElemType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto value) {
                    if (elemTypeBuilder_ == null) {
                        if (((bitField0_ & 0x00000001) != 0) &&
                            elemType_ != null &&
                            elemType_ != org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance()) {
                            getElemTypeBuilder().mergeFrom(value);
                        } else {
                            elemType_ = value;
                        }
                    } else {
                        elemTypeBuilder_.mergeFrom(value);
                    }
                    if (elemType_ != null) {
                        bitField0_ |= 0x00000001;
                        onChanged();
                    }
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder clearElemType() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    elemType_ = null;
                    if (elemTypeBuilder_ != null) {
                        elemTypeBuilder_.dispose();
                        elemTypeBuilder_ = null;
                    }
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder getElemTypeBuilder() {
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return internalGetElemTypeFieldBuilder().getBuilder();
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public ProtoOnnx.TypeProtoOrBuilder getElemTypeOrBuilder() {
                    if (elemTypeBuilder_ != null) {
                        return elemTypeBuilder_.getMessageOrBuilder();
                    } else {
                        return elemType_ == null ?
                            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : elemType_;
                    }
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                private com.google.protobuf.SingleFieldBuilder<
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder>
                internalGetElemTypeFieldBuilder() {
                    if (elemTypeBuilder_ == null) {
                        elemTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder>(
                            getElemType(),
                            getParentForChildren(),
                            isClean());
                        elemType_ = null;
                    }
                    return elemTypeBuilder_;
                }
                
                // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TypeProto.Sequence)
            }
            
            // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TypeProto.Sequence)
            private static final org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence();
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }
            
            private static final com.google.protobuf.Parser<Sequence>
                PARSER = new com.google.protobuf.AbstractParser<Sequence>() {
                @java.lang.Override
                public Sequence parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                    Builder builder = newBuilder();
                    try {
                        builder.mergeFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.setUnfinishedMessage(builder.buildPartial());
                    } catch (com.google.protobuf.UninitializedMessageException e) {
                        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                    } catch (java.io.IOException e) {
                        throw new com.google.protobuf.InvalidProtocolBufferException(e)
                            .setUnfinishedMessage(builder.buildPartial());
                    }
                    return builder.buildPartial();
                }
            };
            
            public static com.google.protobuf.Parser<Sequence> parser() {
                return PARSER;
            }
            
            @java.lang.Override
            public com.google.protobuf.Parser<Sequence> getParserForType() {
                return PARSER;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }
            
        }
        
        public interface MapOrBuilder extends
            // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TypeProto.Map)
            com.google.protobuf.MessageOrBuilder {
            
            /**
             * <pre>
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
             * </pre>
             *
             * <code>optional int32 key_type = 1;</code>
             * @return Whether the keyType field is set.
             */
            boolean hasKeyType();
            /**
             * <pre>
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
             * </pre>
             *
             * <code>optional int32 key_type = 1;</code>
             * @return The keyType.
             */
            int getKeyType();
            
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
             * @return Whether the valueType field is set.
             */
            boolean hasValueType();
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
             * @return The valueType.
             */
            ProtoOnnx.TypeProto getValueType();
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
             */
            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder getValueTypeOrBuilder();
        }
        /**
         * <pre>
         * map&lt;K,V&gt;
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto.Map}
         */
        public static final class Map extends
            com.google.protobuf.GeneratedMessage implements
            // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TypeProto.Map)
            MapOrBuilder {
            private static final long serialVersionUID = 0L;
            static {
                com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                    com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 31,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    Map.class.getName());
            }
            // Use Map.newBuilder() to construct.
            private Map(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
                super(builder);
            }
            private Map() {
            }
            
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Map_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Map_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.class, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.Builder.class);
            }
            
            private int bitField0_;
            public static final int KEY_TYPE_FIELD_NUMBER = 1;
            private int keyType_ = 0;
            /**
             * <pre>
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
             * </pre>
             *
             * <code>optional int32 key_type = 1;</code>
             * @return Whether the keyType field is set.
             */
            @java.lang.Override
            public boolean hasKeyType() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
             * </pre>
             *
             * <code>optional int32 key_type = 1;</code>
             * @return The keyType.
             */
            @java.lang.Override
            public int getKeyType() {
                return keyType_;
            }
            
            public static final int VALUE_TYPE_FIELD_NUMBER = 2;
            private org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto valueType_;
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
             * @return Whether the valueType field is set.
             */
            @java.lang.Override
            public boolean hasValueType() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
             * @return The valueType.
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getValueType() {
                return valueType_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : valueType_;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder getValueTypeOrBuilder() {
                return valueType_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : valueType_;
            }
            
            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;
                
                memoizedIsInitialized = 1;
                return true;
            }
            
            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeInt32(1, keyType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    output.writeMessage(2, getValueType());
                }
                getUnknownFields().writeTo(output);
            }
            
            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;
                
                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt32Size(1, keyType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(2, getValueType());
                }
                size += getUnknownFields().getSerializedSize();
                memoizedSize = size;
                return size;
            }
            
            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map)) {
                    return super.equals(obj);
                }
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map other = (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map) obj;
                
                if (hasKeyType() != other.hasKeyType()) return false;
                if (hasKeyType()) {
                    if (getKeyType()
                        != other.getKeyType()) return false;
                }
                if (hasValueType() != other.hasValueType()) return false;
                if (hasValueType()) {
                    if (!getValueType()
                        .equals(other.getValueType())) return false;
                }
                if (!getUnknownFields().equals(other.getUnknownFields())) return false;
                return true;
            }
            
            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasKeyType()) {
                    hash = (37 * hash) + KEY_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getKeyType();
                }
                if (hasValueType()) {
                    hash = (37 * hash) + VALUE_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getValueType().hashCode();
                }
                hash = (29 * hash) + getUnknownFields().hashCode();
                memoizedHashCode = hash;
                return hash;
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            public static ProtoOnnx.TypeProto.Map parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
            }
            
            @java.lang.Override
            protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * <pre>
             * map&lt;K,V&gt;
             * </pre>
             *
             * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto.Map}
             */
            public static final class Builder extends
                com.google.protobuf.GeneratedMessage.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TypeProto.Map)
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.MapOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Map_descriptor;
                }
                
                @java.lang.Override
                protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Map_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.class, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.Builder.class);
                }
                
                // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }
                
                private Builder(
                    com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessage
                        .alwaysUseFieldBuilders) {
                        internalGetValueTypeFieldBuilder();
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    bitField0_ = 0;
                    keyType_ = 0;
                    valueType_ = null;
                    if (valueTypeBuilder_ != null) {
                        valueTypeBuilder_.dispose();
                        valueTypeBuilder_ = null;
                    }
                    return this;
                }
                
                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return ProtoOnnx.internal_static_onnx_TypeProto_Map_descriptor;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map getDefaultInstanceForType() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.getDefaultInstance();
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map build() {
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }
                
                @java.lang.Override
                public ProtoOnnx.TypeProto.Map buildPartial() {
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map result = new org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map(this);
                    if (bitField0_ != 0) { buildPartial0(result); }
                    onBuilt();
                    return result;
                }
                
                private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map result) {
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        result.keyType_ = keyType_;
                        to_bitField0_ |= 0x00000001;
                    }
                    if (((from_bitField0_ & 0x00000002) != 0)) {
                        result.valueType_ = valueTypeBuilder_ == null
                            ? valueType_
                            : valueTypeBuilder_.build();
                        to_bitField0_ |= 0x00000002;
                    }
                    result.bitField0_ |= to_bitField0_;
                }
                
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map) {
                        return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }
                
                public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map other) {
                    if (other == org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.getDefaultInstance()) return this;
                    if (other.hasKeyType()) {
                        setKeyType(other.getKeyType());
                    }
                    if (other.hasValueType()) {
                        mergeValueType(other.getValueType());
                    }
                    this.mergeUnknownFields(other.getUnknownFields());
                    onChanged();
                    return this;
                }
                
                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }
                
                @java.lang.Override
                public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                    if (extensionRegistry == null) {
                        throw new java.lang.NullPointerException();
                    }
                    try {
                        boolean done = false;
                        while (!done) {
                            int tag = input.readTag();
                            switch (tag) {
                                case 0:
                                    done = true;
                                    break;
                                case 8: {
                                    keyType_ = input.readInt32();
                                    bitField0_ |= 0x00000001;
                                    break;
                                } // case 8
                                case 18: {
                                    input.readMessage(
                                        internalGetValueTypeFieldBuilder().getBuilder(),
                                        extensionRegistry);
                                    bitField0_ |= 0x00000002;
                                    break;
                                } // case 18
                                default: {
                                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                        done = true; // was an endgroup tag
                                    }
                                    break;
                                } // default:
                            } // switch (tag)
                        } // while (!done)
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.unwrapIOException();
                    } finally {
                        onChanged();
                    } // finally
                    return this;
                }
                private int bitField0_;
                
                private int keyType_ ;
                /**
                 * <pre>
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
                 * </pre>
                 *
                 * <code>optional int32 key_type = 1;</code>
                 * @return Whether the keyType field is set.
                 */
                @java.lang.Override
                public boolean hasKeyType() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <pre>
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
                 * </pre>
                 *
                 * <code>optional int32 key_type = 1;</code>
                 * @return The keyType.
                 */
                @java.lang.Override
                public int getKeyType() {
                    return keyType_;
                }
                /**
                 * <pre>
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
                 * </pre>
                 *
                 * <code>optional int32 key_type = 1;</code>
                 * @param value The keyType to set.
                 * @return This builder for chaining.
                 */
                public Builder setKeyType(int value) {
                    
                    keyType_ = value;
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
                 * </pre>
                 *
                 * <code>optional int32 key_type = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearKeyType() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    keyType_ = 0;
                    onChanged();
                    return this;
                }
                
                private org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto valueType_;
                private com.google.protobuf.SingleFieldBuilder<
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder> valueTypeBuilder_;
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
                 * @return Whether the valueType field is set.
                 */
                public boolean hasValueType() {
                    return ((bitField0_ & 0x00000002) != 0);
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
                 * @return The valueType.
                 */
                public ProtoOnnx.TypeProto getValueType() {
                    if (valueTypeBuilder_ == null) {
                        return valueType_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : valueType_;
                    } else {
                        return valueTypeBuilder_.getMessage();
                    }
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
                 */
                public Builder setValueType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto value) {
                    if (valueTypeBuilder_ == null) {
                        if (value == null) {
                            throw new NullPointerException();
                        }
                        valueType_ = value;
                    } else {
                        valueTypeBuilder_.setMessage(value);
                    }
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
                 */
                public Builder setValueType(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder builderForValue) {
                    if (valueTypeBuilder_ == null) {
                        valueType_ = builderForValue.build();
                    } else {
                        valueTypeBuilder_.setMessage(builderForValue.build());
                    }
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
                 */
                public Builder mergeValueType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto value) {
                    if (valueTypeBuilder_ == null) {
                        if (((bitField0_ & 0x00000002) != 0) &&
                            valueType_ != null &&
                            valueType_ != ProtoOnnx.TypeProto.getDefaultInstance()) {
                            getValueTypeBuilder().mergeFrom(value);
                        } else {
                            valueType_ = value;
                        }
                    } else {
                        valueTypeBuilder_.mergeFrom(value);
                    }
                    if (valueType_ != null) {
                        bitField0_ |= 0x00000002;
                        onChanged();
                    }
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
                 */
                public Builder clearValueType() {
                    bitField0_ = (bitField0_ & ~0x00000002);
                    valueType_ = null;
                    if (valueTypeBuilder_ != null) {
                        valueTypeBuilder_.dispose();
                        valueTypeBuilder_ = null;
                    }
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
                 */
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder getValueTypeBuilder() {
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return internalGetValueTypeFieldBuilder().getBuilder();
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
                 */
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder getValueTypeOrBuilder() {
                    if (valueTypeBuilder_ != null) {
                        return valueTypeBuilder_.getMessageOrBuilder();
                    } else {
                        return valueType_ == null ?
                            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : valueType_;
                    }
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto value_type = 2;</code>
                 */
                private com.google.protobuf.SingleFieldBuilder<
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder>
                internalGetValueTypeFieldBuilder() {
                    if (valueTypeBuilder_ == null) {
                        valueTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, ProtoOnnx.TypeProtoOrBuilder>(
                            getValueType(),
                            getParentForChildren(),
                            isClean());
                        valueType_ = null;
                    }
                    return valueTypeBuilder_;
                }
                
                // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TypeProto.Map)
            }
            
            // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TypeProto.Map)
            private static final org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new ProtoOnnx.TypeProto.Map();
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }
            
            private static final com.google.protobuf.Parser<Map>
                PARSER = new com.google.protobuf.AbstractParser<Map>() {
                @java.lang.Override
                public Map parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                    Builder builder = newBuilder();
                    try {
                        builder.mergeFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.setUnfinishedMessage(builder.buildPartial());
                    } catch (com.google.protobuf.UninitializedMessageException e) {
                        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                    } catch (java.io.IOException e) {
                        throw new com.google.protobuf.InvalidProtocolBufferException(e)
                            .setUnfinishedMessage(builder.buildPartial());
                    }
                    return builder.buildPartial();
                }
            };
            
            public static com.google.protobuf.Parser<Map> parser() {
                return PARSER;
            }
            
            @java.lang.Override
            public com.google.protobuf.Parser<Map> getParserForType() {
                return PARSER;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }
            
        }
        
        public interface OptionalOrBuilder extends
            // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TypeProto.Optional)
            com.google.protobuf.MessageOrBuilder {
            
            /**
             * <pre>
             * The type and optional shape of the element wrapped.
             * This field MUST be present for this version of the IR.
             * Possible values correspond to OptionalProto.DataType enum
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            boolean hasElemType();
            /**
             * <pre>
             * The type and optional shape of the element wrapped.
             * This field MUST be present for this version of the IR.
             * Possible values correspond to OptionalProto.DataType enum
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             * @return The elemType.
             */
            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getElemType();
            /**
             * <pre>
             * The type and optional shape of the element wrapped.
             * This field MUST be present for this version of the IR.
             * Possible values correspond to OptionalProto.DataType enum
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             */
            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder getElemTypeOrBuilder();
        }
        /**
         * <pre>
         * wrapper for Tensor, Sequence, or Map
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto.Optional}
         */
        public static final class Optional extends
            com.google.protobuf.GeneratedMessage implements
            // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TypeProto.Optional)
            OptionalOrBuilder {
            private static final long serialVersionUID = 0L;
            static {
                com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                    com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 31,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    Optional.class.getName());
            }
            // Use Optional.newBuilder() to construct.
            private Optional(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
                super(builder);
            }
            private Optional() {
            }
            
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Optional_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Optional_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        ProtoOnnx.TypeProto.Optional.class, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.Builder.class);
            }
            
            private int bitField0_;
            public static final int ELEM_TYPE_FIELD_NUMBER = 1;
            private org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto elemType_;
            /**
             * <pre>
             * The type and optional shape of the element wrapped.
             * This field MUST be present for this version of the IR.
             * Possible values correspond to OptionalProto.DataType enum
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            @java.lang.Override
            public boolean hasElemType() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The type and optional shape of the element wrapped.
             * This field MUST be present for this version of the IR.
             * Possible values correspond to OptionalProto.DataType enum
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             * @return The elemType.
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getElemType() {
                return elemType_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : elemType_;
            }
            /**
             * <pre>
             * The type and optional shape of the element wrapped.
             * This field MUST be present for this version of the IR.
             * Possible values correspond to OptionalProto.DataType enum
             * </pre>
             *
             * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder getElemTypeOrBuilder() {
                return elemType_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : elemType_;
            }
            
            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;
                
                memoizedIsInitialized = 1;
                return true;
            }
            
            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeMessage(1, getElemType());
                }
                getUnknownFields().writeTo(output);
            }
            
            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;
                
                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(1, getElemType());
                }
                size += getUnknownFields().getSerializedSize();
                memoizedSize = size;
                return size;
            }
            
            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof ProtoOnnx.TypeProto.Optional)) {
                    return super.equals(obj);
                }
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional other = (ProtoOnnx.TypeProto.Optional) obj;
                
                if (hasElemType() != other.hasElemType()) return false;
                if (hasElemType()) {
                    if (!getElemType()
                        .equals(other.getElemType())) return false;
                }
                if (!getUnknownFields().equals(other.getUnknownFields())) return false;
                return true;
            }
            
            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasElemType()) {
                    hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getElemType().hashCode();
                }
                hash = (29 * hash) + getUnknownFields().hashCode();
                memoizedHashCode = hash;
                return hash;
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ProtoOnnx.TypeProto.Optional parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ProtoOnnx.TypeProto.Optional parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional parseFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static ProtoOnnx.TypeProto.Optional parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
            }
            
            @java.lang.Override
            protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * <pre>
             * wrapper for Tensor, Sequence, or Map
             * </pre>
             *
             * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto.Optional}
             */
            public static final class Builder extends
                com.google.protobuf.GeneratedMessage.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TypeProto.Optional)
                ProtoOnnx.TypeProto.OptionalOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Optional_descriptor;
                }
                
                @java.lang.Override
                protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Optional_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                            ProtoOnnx.TypeProto.Optional.class, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.Builder.class);
                }
                
                // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }
                
                private Builder(
                    com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessage
                        .alwaysUseFieldBuilders) {
                        internalGetElemTypeFieldBuilder();
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    bitField0_ = 0;
                    elemType_ = null;
                    if (elemTypeBuilder_ != null) {
                        elemTypeBuilder_.dispose();
                        elemTypeBuilder_ = null;
                    }
                    return this;
                }
                
                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_Optional_descriptor;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional getDefaultInstanceForType() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.getDefaultInstance();
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional build() {
                    ProtoOnnx.TypeProto.Optional result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional buildPartial() {
                    ProtoOnnx.TypeProto.Optional result = new org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional(this);
                    if (bitField0_ != 0) { buildPartial0(result); }
                    onBuilt();
                    return result;
                }
                
                private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional result) {
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        result.elemType_ = elemTypeBuilder_ == null
                            ? elemType_
                            : elemTypeBuilder_.build();
                        to_bitField0_ |= 0x00000001;
                    }
                    result.bitField0_ |= to_bitField0_;
                }
                
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional) {
                        return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }
                
                public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional other) {
                    if (other == org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.getDefaultInstance()) return this;
                    if (other.hasElemType()) {
                        mergeElemType(other.getElemType());
                    }
                    this.mergeUnknownFields(other.getUnknownFields());
                    onChanged();
                    return this;
                }
                
                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }
                
                @java.lang.Override
                public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                    if (extensionRegistry == null) {
                        throw new java.lang.NullPointerException();
                    }
                    try {
                        boolean done = false;
                        while (!done) {
                            int tag = input.readTag();
                            switch (tag) {
                                case 0:
                                    done = true;
                                    break;
                                case 10: {
                                    input.readMessage(
                                        internalGetElemTypeFieldBuilder().getBuilder(),
                                        extensionRegistry);
                                    bitField0_ |= 0x00000001;
                                    break;
                                } // case 10
                                default: {
                                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                        done = true; // was an endgroup tag
                                    }
                                    break;
                                } // default:
                            } // switch (tag)
                        } // while (!done)
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.unwrapIOException();
                    } finally {
                        onChanged();
                    } // finally
                    return this;
                }
                private int bitField0_;
                
                private org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto elemType_;
                private com.google.protobuf.SingleFieldBuilder<
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder> elemTypeBuilder_;
                /**
                 * <pre>
                 * The type and optional shape of the element wrapped.
                 * This field MUST be present for this version of the IR.
                 * Possible values correspond to OptionalProto.DataType enum
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 * @return Whether the elemType field is set.
                 */
                public boolean hasElemType() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <pre>
                 * The type and optional shape of the element wrapped.
                 * This field MUST be present for this version of the IR.
                 * Possible values correspond to OptionalProto.DataType enum
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 * @return The elemType.
                 */
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getElemType() {
                    if (elemTypeBuilder_ == null) {
                        return elemType_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance() : elemType_;
                    } else {
                        return elemTypeBuilder_.getMessage();
                    }
                }
                /**
                 * <pre>
                 * The type and optional shape of the element wrapped.
                 * This field MUST be present for this version of the IR.
                 * Possible values correspond to OptionalProto.DataType enum
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder setElemType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto value) {
                    if (elemTypeBuilder_ == null) {
                        if (value == null) {
                            throw new NullPointerException();
                        }
                        elemType_ = value;
                    } else {
                        elemTypeBuilder_.setMessage(value);
                    }
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of the element wrapped.
                 * This field MUST be present for this version of the IR.
                 * Possible values correspond to OptionalProto.DataType enum
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder setElemType(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder builderForValue) {
                    if (elemTypeBuilder_ == null) {
                        elemType_ = builderForValue.build();
                    } else {
                        elemTypeBuilder_.setMessage(builderForValue.build());
                    }
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of the element wrapped.
                 * This field MUST be present for this version of the IR.
                 * Possible values correspond to OptionalProto.DataType enum
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder mergeElemType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto value) {
                    if (elemTypeBuilder_ == null) {
                        if (((bitField0_ & 0x00000001) != 0) &&
                            elemType_ != null &&
                            elemType_ != org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance()) {
                            getElemTypeBuilder().mergeFrom(value);
                        } else {
                            elemType_ = value;
                        }
                    } else {
                        elemTypeBuilder_.mergeFrom(value);
                    }
                    if (elemType_ != null) {
                        bitField0_ |= 0x00000001;
                        onChanged();
                    }
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of the element wrapped.
                 * This field MUST be present for this version of the IR.
                 * Possible values correspond to OptionalProto.DataType enum
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder clearElemType() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    elemType_ = null;
                    if (elemTypeBuilder_ != null) {
                        elemTypeBuilder_.dispose();
                        elemTypeBuilder_ = null;
                    }
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of the element wrapped.
                 * This field MUST be present for this version of the IR.
                 * Possible values correspond to OptionalProto.DataType enum
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public ProtoOnnx.TypeProto.Builder getElemTypeBuilder() {
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return internalGetElemTypeFieldBuilder().getBuilder();
                }
                /**
                 * <pre>
                 * The type and optional shape of the element wrapped.
                 * This field MUST be present for this version of the IR.
                 * Possible values correspond to OptionalProto.DataType enum
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder getElemTypeOrBuilder() {
                    if (elemTypeBuilder_ != null) {
                        return elemTypeBuilder_.getMessageOrBuilder();
                    } else {
                        return elemType_ == null ?
                            ProtoOnnx.TypeProto.getDefaultInstance() : elemType_;
                    }
                }
                /**
                 * <pre>
                 * The type and optional shape of the element wrapped.
                 * This field MUST be present for this version of the IR.
                 * Possible values correspond to OptionalProto.DataType enum
                 * </pre>
                 *
                 * <code>optional .org.brain4j.core.importing.onnx.TypeProto elem_type = 1;</code>
                 */
                private com.google.protobuf.SingleFieldBuilder<
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder>
                internalGetElemTypeFieldBuilder() {
                    if (elemTypeBuilder_ == null) {
                        elemTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder>(
                            getElemType(),
                            getParentForChildren(),
                            isClean());
                        elemType_ = null;
                    }
                    return elemTypeBuilder_;
                }
                
                // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TypeProto.Optional)
            }
            
            // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TypeProto.Optional)
            private static final org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new ProtoOnnx.TypeProto.Optional();
            }
            
            public static ProtoOnnx.TypeProto.Optional getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }
            
            private static final com.google.protobuf.Parser<Optional>
                PARSER = new com.google.protobuf.AbstractParser<Optional>() {
                @java.lang.Override
                public Optional parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                    Builder builder = newBuilder();
                    try {
                        builder.mergeFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.setUnfinishedMessage(builder.buildPartial());
                    } catch (com.google.protobuf.UninitializedMessageException e) {
                        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                    } catch (java.io.IOException e) {
                        throw new com.google.protobuf.InvalidProtocolBufferException(e)
                            .setUnfinishedMessage(builder.buildPartial());
                    }
                    return builder.buildPartial();
                }
            };
            
            public static com.google.protobuf.Parser<Optional> parser() {
                return PARSER;
            }
            
            @java.lang.Override
            public com.google.protobuf.Parser<Optional> getParserForType() {
                return PARSER;
            }
            
            @java.lang.Override
            public ProtoOnnx.TypeProto.Optional getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }
            
        }
        
        public interface SparseTensorOrBuilder extends
            // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.TypeProto.SparseTensor)
            com.google.protobuf.MessageOrBuilder {
            
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            boolean hasElemType();
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return The elemType.
             */
            int getElemType();
            
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             * @return Whether the shape field is set.
             */
            boolean hasShape();
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             * @return The shape.
             */
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto getShape();
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             */
            org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder getShapeOrBuilder();
        }
        /**
         * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto.SparseTensor}
         */
        public static final class SparseTensor extends
            com.google.protobuf.GeneratedMessage implements
            // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.TypeProto.SparseTensor)
            SparseTensorOrBuilder {
            private static final long serialVersionUID = 0L;
            static {
                com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                    com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 31,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    SparseTensor.class.getName());
            }
            // Use SparseTensor.newBuilder() to construct.
            private SparseTensor(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
                super(builder);
            }
            private SparseTensor() {
            }
            
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_SparseTensor_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.class, ProtoOnnx.TypeProto.SparseTensor.Builder.class);
            }
            
            private int bitField0_;
            public static final int ELEM_TYPE_FIELD_NUMBER = 1;
            private int elemType_ = 0;
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            @java.lang.Override
            public boolean hasElemType() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return The elemType.
             */
            @java.lang.Override
            public int getElemType() {
                return elemType_;
            }
            
            public static final int SHAPE_FIELD_NUMBER = 2;
            private org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto shape_;
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             * @return Whether the shape field is set.
             */
            @java.lang.Override
            public boolean hasShape() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             * @return The shape.
             */
            @java.lang.Override
            public ProtoOnnx.TensorShapeProto getShape() {
                return shape_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.getDefaultInstance() : shape_;
            }
            /**
             * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder getShapeOrBuilder() {
                return shape_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.getDefaultInstance() : shape_;
            }
            
            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;
                
                memoizedIsInitialized = 1;
                return true;
            }
            
            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeInt32(1, elemType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    output.writeMessage(2, getShape());
                }
                getUnknownFields().writeTo(output);
            }
            
            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;
                
                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeInt32Size(1, elemType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(2, getShape());
                }
                size += getUnknownFields().getSerializedSize();
                memoizedSize = size;
                return size;
            }
            
            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor)) {
                    return super.equals(obj);
                }
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor other = (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor) obj;
                
                if (hasElemType() != other.hasElemType()) return false;
                if (hasElemType()) {
                    if (getElemType()
                        != other.getElemType()) return false;
                }
                if (hasShape() != other.hasShape()) return false;
                if (hasShape()) {
                    if (!getShape()
                        .equals(other.getShape())) return false;
                }
                if (!getUnknownFields().equals(other.getUnknownFields())) return false;
                return true;
            }
            
            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasElemType()) {
                    hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getElemType();
                }
                if (hasShape()) {
                    hash = (37 * hash) + SHAPE_FIELD_NUMBER;
                    hash = (53 * hash) + getShape().hashCode();
                }
                hash = (29 * hash) + getUnknownFields().hashCode();
                memoizedHashCode = hash;
                return hash;
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ProtoOnnx.TypeProto.SparseTensor parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input);
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input);
            }
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                return com.google.protobuf.GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
            }
            
            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
            }
            
            @java.lang.Override
            protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto.SparseTensor}
             */
            public static final class Builder extends
                com.google.protobuf.GeneratedMessage.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TypeProto.SparseTensor)
                ProtoOnnx.TypeProto.SparseTensorOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_SparseTensor_descriptor;
                }
                
                @java.lang.Override
                protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.class, ProtoOnnx.TypeProto.SparseTensor.Builder.class);
                }
                
                // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }
                
                private Builder(
                    com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessage
                        .alwaysUseFieldBuilders) {
                        internalGetShapeFieldBuilder();
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    bitField0_ = 0;
                    elemType_ = 0;
                    shape_ = null;
                    if (shapeBuilder_ != null) {
                        shapeBuilder_.dispose();
                        shapeBuilder_ = null;
                    }
                    return this;
                }
                
                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_SparseTensor_descriptor;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor getDefaultInstanceForType() {
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.getDefaultInstance();
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor build() {
                    ProtoOnnx.TypeProto.SparseTensor result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }
                
                @java.lang.Override
                public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor buildPartial() {
                    org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor result = new ProtoOnnx.TypeProto.SparseTensor(this);
                    if (bitField0_ != 0) { buildPartial0(result); }
                    onBuilt();
                    return result;
                }
                
                private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor result) {
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        result.elemType_ = elemType_;
                        to_bitField0_ |= 0x00000001;
                    }
                    if (((from_bitField0_ & 0x00000002) != 0)) {
                        result.shape_ = shapeBuilder_ == null
                            ? shape_
                            : shapeBuilder_.build();
                        to_bitField0_ |= 0x00000002;
                    }
                    result.bitField0_ |= to_bitField0_;
                }
                
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor) {
                        return mergeFrom((ProtoOnnx.TypeProto.SparseTensor)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }
                
                public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor other) {
                    if (other == ProtoOnnx.TypeProto.SparseTensor.getDefaultInstance()) return this;
                    if (other.hasElemType()) {
                        setElemType(other.getElemType());
                    }
                    if (other.hasShape()) {
                        mergeShape(other.getShape());
                    }
                    this.mergeUnknownFields(other.getUnknownFields());
                    onChanged();
                    return this;
                }
                
                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }
                
                @java.lang.Override
                public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                    if (extensionRegistry == null) {
                        throw new java.lang.NullPointerException();
                    }
                    try {
                        boolean done = false;
                        while (!done) {
                            int tag = input.readTag();
                            switch (tag) {
                                case 0:
                                    done = true;
                                    break;
                                case 8: {
                                    elemType_ = input.readInt32();
                                    bitField0_ |= 0x00000001;
                                    break;
                                } // case 8
                                case 18: {
                                    input.readMessage(
                                        internalGetShapeFieldBuilder().getBuilder(),
                                        extensionRegistry);
                                    bitField0_ |= 0x00000002;
                                    break;
                                } // case 18
                                default: {
                                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                        done = true; // was an endgroup tag
                                    }
                                    break;
                                } // default:
                            } // switch (tag)
                        } // while (!done)
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.unwrapIOException();
                    } finally {
                        onChanged();
                    } // finally
                    return this;
                }
                private int bitField0_;
                
                private int elemType_ ;
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return Whether the elemType field is set.
                 */
                @java.lang.Override
                public boolean hasElemType() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return The elemType.
                 */
                @java.lang.Override
                public int getElemType() {
                    return elemType_;
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @param value The elemType to set.
                 * @return This builder for chaining.
                 */
                public Builder setElemType(int value) {
                    
                    elemType_ = value;
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearElemType() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    elemType_ = 0;
                    onChanged();
                    return this;
                }
                
                private org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto shape_;
                private com.google.protobuf.SingleFieldBuilder<
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder> shapeBuilder_;
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 * @return Whether the shape field is set.
                 */
                public boolean hasShape() {
                    return ((bitField0_ & 0x00000002) != 0);
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 * @return The shape.
                 */
                public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto getShape() {
                    if (shapeBuilder_ == null) {
                        return shape_ == null ? org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.getDefaultInstance() : shape_;
                    } else {
                        return shapeBuilder_.getMessage();
                    }
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder setShape(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto value) {
                    if (shapeBuilder_ == null) {
                        if (value == null) {
                            throw new NullPointerException();
                        }
                        shape_ = value;
                    } else {
                        shapeBuilder_.setMessage(value);
                    }
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return this;
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder setShape(
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Builder builderForValue) {
                    if (shapeBuilder_ == null) {
                        shape_ = builderForValue.build();
                    } else {
                        shapeBuilder_.setMessage(builderForValue.build());
                    }
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return this;
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder mergeShape(org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto value) {
                    if (shapeBuilder_ == null) {
                        if (((bitField0_ & 0x00000002) != 0) &&
                            shape_ != null &&
                            shape_ != org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.getDefaultInstance()) {
                            getShapeBuilder().mergeFrom(value);
                        } else {
                            shape_ = value;
                        }
                    } else {
                        shapeBuilder_.mergeFrom(value);
                    }
                    if (shape_ != null) {
                        bitField0_ |= 0x00000002;
                        onChanged();
                    }
                    return this;
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder clearShape() {
                    bitField0_ = (bitField0_ & ~0x00000002);
                    shape_ = null;
                    if (shapeBuilder_ != null) {
                        shapeBuilder_.dispose();
                        shapeBuilder_ = null;
                    }
                    onChanged();
                    return this;
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Builder getShapeBuilder() {
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return internalGetShapeFieldBuilder().getBuilder();
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                public org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder getShapeOrBuilder() {
                    if (shapeBuilder_ != null) {
                        return shapeBuilder_.getMessageOrBuilder();
                    } else {
                        return shape_ == null ?
                            org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.getDefaultInstance() : shape_;
                    }
                }
                /**
                 * <code>optional .org.brain4j.core.importing.onnx.TensorShapeProto shape = 2;</code>
                 */
                private com.google.protobuf.SingleFieldBuilder<
                    org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto, ProtoOnnx.TensorShapeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProtoOrBuilder>
                internalGetShapeFieldBuilder() {
                    if (shapeBuilder_ == null) {
                        shapeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                            ProtoOnnx.TensorShapeProto, org.brain4j.core.importing.onnx.ProtoOnnx.TensorShapeProto.Builder, ProtoOnnx.TensorShapeProtoOrBuilder>(
                            getShape(),
                            getParentForChildren(),
                            isClean());
                        shape_ = null;
                    }
                    return shapeBuilder_;
                }
                
                // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TypeProto.SparseTensor)
            }
            
            // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TypeProto.SparseTensor)
            private static final org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor();
            }
            
            public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }
            
            private static final com.google.protobuf.Parser<SparseTensor>
                PARSER = new com.google.protobuf.AbstractParser<SparseTensor>() {
                @java.lang.Override
                public SparseTensor parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                    Builder builder = newBuilder();
                    try {
                        builder.mergeFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        throw e.setUnfinishedMessage(builder.buildPartial());
                    } catch (com.google.protobuf.UninitializedMessageException e) {
                        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                    } catch (java.io.IOException e) {
                        throw new com.google.protobuf.InvalidProtocolBufferException(e)
                            .setUnfinishedMessage(builder.buildPartial());
                    }
                    return builder.buildPartial();
                }
            };
            
            public static com.google.protobuf.Parser<SparseTensor> parser() {
                return PARSER;
            }
            
            @java.lang.Override
            public com.google.protobuf.Parser<SparseTensor> getParserForType() {
                return PARSER;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }
            
        }
        
        private int bitField0_;
        private int valueCase_ = 0;
        @SuppressWarnings("serial")
        private java.lang.Object value_;
        public enum ValueCase
            implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
            TENSOR_TYPE(1),
            SEQUENCE_TYPE(4),
            MAP_TYPE(5),
            OPTIONAL_TYPE(9),
            SPARSE_TENSOR_TYPE(8),
            VALUE_NOT_SET(0);
            private final int value;
            private ValueCase(int value) {
                this.value = value;
            }
            /**
             * @param value The number of the enum to look for.
             * @return The enum associated with the given number.
             * @deprecated Use {@link #forNumber(int)} instead.
             */
            @java.lang.Deprecated
            public static ValueCase valueOf(int value) {
                return forNumber(value);
            }
            
            public static ValueCase forNumber(int value) {
                switch (value) {
                    case 1: return TENSOR_TYPE;
                    case 4: return SEQUENCE_TYPE;
                    case 5: return MAP_TYPE;
                    case 9: return OPTIONAL_TYPE;
                    case 8: return SPARSE_TENSOR_TYPE;
                    case 0: return VALUE_NOT_SET;
                    default: return null;
                }
            }
            public int getNumber() {
                return this.value;
            }
        };
        
        public ValueCase
        getValueCase() {
            return ValueCase.forNumber(
                valueCase_);
        }
        
        public static final int TENSOR_TYPE_FIELD_NUMBER = 1;
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
         * @return Whether the tensorType field is set.
         */
        @java.lang.Override
        public boolean hasTensorType() {
            return valueCase_ == 1;
        }
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
         * @return The tensorType.
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor getTensorType() {
            if (valueCase_ == 1) {
                return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor) value_;
            }
            return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.getDefaultInstance();
        }
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.TensorOrBuilder getTensorTypeOrBuilder() {
            if (valueCase_ == 1) {
                return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor) value_;
            }
            return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.getDefaultInstance();
        }
        
        public static final int SEQUENCE_TYPE_FIELD_NUMBER = 4;
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
         * @return Whether the sequenceType field is set.
         */
        @java.lang.Override
        public boolean hasSequenceType() {
            return valueCase_ == 4;
        }
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
         * @return The sequenceType.
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence getSequenceType() {
            if (valueCase_ == 4) {
                return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence) value_;
            }
            return ProtoOnnx.TypeProto.Sequence.getDefaultInstance();
        }
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
         */
        @java.lang.Override
        public ProtoOnnx.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder() {
            if (valueCase_ == 4) {
                return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence) value_;
            }
            return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.getDefaultInstance();
        }
        
        public static final int MAP_TYPE_FIELD_NUMBER = 5;
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
         * @return Whether the mapType field is set.
         */
        @java.lang.Override
        public boolean hasMapType() {
            return valueCase_ == 5;
        }
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
         * @return The mapType.
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map getMapType() {
            if (valueCase_ == 5) {
                return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map) value_;
            }
            return ProtoOnnx.TypeProto.Map.getDefaultInstance();
        }
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.MapOrBuilder getMapTypeOrBuilder() {
            if (valueCase_ == 5) {
                return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map) value_;
            }
            return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.getDefaultInstance();
        }
        
        public static final int OPTIONAL_TYPE_FIELD_NUMBER = 9;
        /**
         * <pre>
         * The type of an optional.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
         * @return Whether the optionalType field is set.
         */
        @java.lang.Override
        public boolean hasOptionalType() {
            return valueCase_ == 9;
        }
        /**
         * <pre>
         * The type of an optional.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
         * @return The optionalType.
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional getOptionalType() {
            if (valueCase_ == 9) {
                return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional) value_;
            }
            return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.getDefaultInstance();
        }
        /**
         * <pre>
         * The type of an optional.
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.OptionalOrBuilder getOptionalTypeOrBuilder() {
            if (valueCase_ == 9) {
                return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional) value_;
            }
            return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.getDefaultInstance();
        }
        
        public static final int SPARSE_TENSOR_TYPE_FIELD_NUMBER = 8;
        /**
         * <pre>
         * Type of the sparse tensor
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         * @return Whether the sparseTensorType field is set.
         */
        @java.lang.Override
        public boolean hasSparseTensorType() {
            return valueCase_ == 8;
        }
        /**
         * <pre>
         * Type of the sparse tensor
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         * @return The sparseTensorType.
         */
        @java.lang.Override
        public ProtoOnnx.TypeProto.SparseTensor getSparseTensorType() {
            if (valueCase_ == 8) {
                return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor) value_;
            }
            return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.getDefaultInstance();
        }
        /**
         * <pre>
         * Type of the sparse tensor
         * </pre>
         *
         * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         */
        @java.lang.Override
        public ProtoOnnx.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder() {
            if (valueCase_ == 8) {
                return (ProtoOnnx.TypeProto.SparseTensor) value_;
            }
            return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.getDefaultInstance();
        }
        
        public static final int DENOTATION_FIELD_NUMBER = 6;
        @SuppressWarnings("serial")
        private volatile java.lang.Object denotation_ = "";
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return Whether the denotation field is set.
         */
        @java.lang.Override
        public boolean hasDenotation() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return The denotation.
         */
        @java.lang.Override
        public java.lang.String getDenotation() {
            java.lang.Object ref = denotation_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    denotation_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return The bytes for denotation.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDenotationBytes() {
            java.lang.Object ref = denotation_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                denotation_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (valueCase_ == 1) {
                output.writeMessage(1, (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor) value_);
            }
            if (valueCase_ == 4) {
                output.writeMessage(4, (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence) value_);
            }
            if (valueCase_ == 5) {
                output.writeMessage(5, (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map) value_);
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 6, denotation_);
            }
            if (valueCase_ == 8) {
                output.writeMessage(8, (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor) value_);
            }
            if (valueCase_ == 9) {
                output.writeMessage(9, (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional) value_);
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (valueCase_ == 1) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(1, (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor) value_);
            }
            if (valueCase_ == 4) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(4, (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence) value_);
            }
            if (valueCase_ == 5) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(5, (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map) value_);
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(6, denotation_);
            }
            if (valueCase_ == 8) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(8, (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor) value_);
            }
            if (valueCase_ == 9) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(9, (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional) value_);
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto other = (ProtoOnnx.TypeProto) obj;
            
            if (hasDenotation() != other.hasDenotation()) return false;
            if (hasDenotation()) {
                if (!getDenotation()
                    .equals(other.getDenotation())) return false;
            }
            if (!getValueCase().equals(other.getValueCase())) return false;
            switch (valueCase_) {
                case 1:
                    if (!getTensorType()
                        .equals(other.getTensorType())) return false;
                    break;
                case 4:
                    if (!getSequenceType()
                        .equals(other.getSequenceType())) return false;
                    break;
                case 5:
                    if (!getMapType()
                        .equals(other.getMapType())) return false;
                    break;
                case 9:
                    if (!getOptionalType()
                        .equals(other.getOptionalType())) return false;
                    break;
                case 8:
                    if (!getSparseTensorType()
                        .equals(other.getSparseTensorType())) return false;
                    break;
                case 0:
                default:
            }
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasDenotation()) {
                hash = (37 * hash) + DENOTATION_FIELD_NUMBER;
                hash = (53 * hash) + getDenotation().hashCode();
            }
            switch (valueCase_) {
                case 1:
                    hash = (37 * hash) + TENSOR_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getTensorType().hashCode();
                    break;
                case 4:
                    hash = (37 * hash) + SEQUENCE_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getSequenceType().hashCode();
                    break;
                case 5:
                    hash = (37 * hash) + MAP_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getMapType().hashCode();
                    break;
                case 9:
                    hash = (37 * hash) + OPTIONAL_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getOptionalType().hashCode();
                    break;
                case 8:
                    hash = (37 * hash) + SPARSE_TENSOR_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getSparseTensorType().hashCode();
                    break;
                case 0:
                default:
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ProtoOnnx.TypeProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static ProtoOnnx.TypeProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static ProtoOnnx.TypeProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Types
         *
         * The standard ONNX data types.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.TypeProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.TypeProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.TypeProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                if (tensorTypeBuilder_ != null) {
                    tensorTypeBuilder_.clear();
                }
                if (sequenceTypeBuilder_ != null) {
                    sequenceTypeBuilder_.clear();
                }
                if (mapTypeBuilder_ != null) {
                    mapTypeBuilder_.clear();
                }
                if (optionalTypeBuilder_ != null) {
                    optionalTypeBuilder_.clear();
                }
                if (sparseTensorTypeBuilder_ != null) {
                    sparseTensorTypeBuilder_.clear();
                }
                denotation_ = "";
                valueCase_ = 0;
                value_ = null;
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_TypeProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto result = new org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto(this);
                if (bitField0_ != 0) { buildPartial0(result); }
                buildPartialOneofs(result);
                onBuilt();
                return result;
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000020) != 0)) {
                    result.denotation_ = denotation_;
                    to_bitField0_ |= 0x00000001;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            private void buildPartialOneofs(ProtoOnnx.TypeProto result) {
                result.valueCase_ = valueCase_;
                result.value_ = this.value_;
                if (valueCase_ == 1 &&
                    tensorTypeBuilder_ != null) {
                    result.value_ = tensorTypeBuilder_.build();
                }
                if (valueCase_ == 4 &&
                    sequenceTypeBuilder_ != null) {
                    result.value_ = sequenceTypeBuilder_.build();
                }
                if (valueCase_ == 5 &&
                    mapTypeBuilder_ != null) {
                    result.value_ = mapTypeBuilder_.build();
                }
                if (valueCase_ == 9 &&
                    optionalTypeBuilder_ != null) {
                    result.value_ = optionalTypeBuilder_.build();
                }
                if (valueCase_ == 8 &&
                    sparseTensorTypeBuilder_ != null) {
                    result.value_ = sparseTensorTypeBuilder_.build();
                }
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto) {
                    return mergeFrom((ProtoOnnx.TypeProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(ProtoOnnx.TypeProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.getDefaultInstance()) return this;
                if (other.hasDenotation()) {
                    denotation_ = other.denotation_;
                    bitField0_ |= 0x00000020;
                    onChanged();
                }
                switch (other.getValueCase()) {
                    case TENSOR_TYPE: {
                        mergeTensorType(other.getTensorType());
                        break;
                    }
                    case SEQUENCE_TYPE: {
                        mergeSequenceType(other.getSequenceType());
                        break;
                    }
                    case MAP_TYPE: {
                        mergeMapType(other.getMapType());
                        break;
                    }
                    case OPTIONAL_TYPE: {
                        mergeOptionalType(other.getOptionalType());
                        break;
                    }
                    case SPARSE_TENSOR_TYPE: {
                        mergeSparseTensorType(other.getSparseTensorType());
                        break;
                    }
                    case VALUE_NOT_SET: {
                        break;
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                input.readMessage(
                                    internalGetTensorTypeFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                valueCase_ = 1;
                                break;
                            } // case 10
                            case 34: {
                                input.readMessage(
                                    internalGetSequenceTypeFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                valueCase_ = 4;
                                break;
                            } // case 34
                            case 42: {
                                input.readMessage(
                                    internalGetMapTypeFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                valueCase_ = 5;
                                break;
                            } // case 42
                            case 50: {
                                denotation_ = input.readBytes();
                                bitField0_ |= 0x00000020;
                                break;
                            } // case 50
                            case 66: {
                                input.readMessage(
                                    internalGetSparseTensorTypeFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                valueCase_ = 8;
                                break;
                            } // case 66
                            case 74: {
                                input.readMessage(
                                    internalGetOptionalTypeFieldBuilder().getBuilder(),
                                    extensionRegistry);
                                valueCase_ = 9;
                                break;
                            } // case 74
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int valueCase_ = 0;
            private java.lang.Object value_;
            public ValueCase
            getValueCase() {
                return ValueCase.forNumber(
                    valueCase_);
            }
            
            public Builder clearValue() {
                valueCase_ = 0;
                value_ = null;
                onChanged();
                return this;
            }
            
            private int bitField0_;
            
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.TensorOrBuilder> tensorTypeBuilder_;
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
             * @return Whether the tensorType field is set.
             */
            @java.lang.Override
            public boolean hasTensorType() {
                return valueCase_ == 1;
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
             * @return The tensorType.
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor getTensorType() {
                if (tensorTypeBuilder_ == null) {
                    if (valueCase_ == 1) {
                        return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor) value_;
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.getDefaultInstance();
                } else {
                    if (valueCase_ == 1) {
                        return tensorTypeBuilder_.getMessage();
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            public Builder setTensorType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor value) {
                if (tensorTypeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    value_ = value;
                    onChanged();
                } else {
                    tensorTypeBuilder_.setMessage(value);
                }
                valueCase_ = 1;
                return this;
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            public Builder setTensorType(
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.Builder builderForValue) {
                if (tensorTypeBuilder_ == null) {
                    value_ = builderForValue.build();
                    onChanged();
                } else {
                    tensorTypeBuilder_.setMessage(builderForValue.build());
                }
                valueCase_ = 1;
                return this;
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            public Builder mergeTensorType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor value) {
                if (tensorTypeBuilder_ == null) {
                    if (valueCase_ == 1 &&
                        value_ != org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.getDefaultInstance()) {
                        value_ = org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.newBuilder((org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor) value_)
                            .mergeFrom(value).buildPartial();
                    } else {
                        value_ = value;
                    }
                    onChanged();
                } else {
                    if (valueCase_ == 1) {
                        tensorTypeBuilder_.mergeFrom(value);
                    } else {
                        tensorTypeBuilder_.setMessage(value);
                    }
                }
                valueCase_ = 1;
                return this;
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            public Builder clearTensorType() {
                if (tensorTypeBuilder_ == null) {
                    if (valueCase_ == 1) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                } else {
                    if (valueCase_ == 1) {
                        valueCase_ = 0;
                        value_ = null;
                    }
                    tensorTypeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            public ProtoOnnx.TypeProto.Tensor.Builder getTensorTypeBuilder() {
                return internalGetTensorTypeFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.TensorOrBuilder getTensorTypeOrBuilder() {
                if ((valueCase_ == 1) && (tensorTypeBuilder_ != null)) {
                    return tensorTypeBuilder_.getMessageOrBuilder();
                } else {
                    if (valueCase_ == 1) {
                        return (ProtoOnnx.TypeProto.Tensor) value_;
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.Builder, ProtoOnnx.TypeProto.TensorOrBuilder>
            internalGetTensorTypeFieldBuilder() {
                if (tensorTypeBuilder_ == null) {
                    if (!(valueCase_ == 1)) {
                        value_ = org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.getDefaultInstance();
                    }
                    tensorTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        ProtoOnnx.TypeProto.Tensor, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.TensorOrBuilder>(
                        (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Tensor) value_,
                        getParentForChildren(),
                        isClean());
                    value_ = null;
                }
                valueCase_ = 1;
                onChanged();
                return tensorTypeBuilder_;
            }
            
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SequenceOrBuilder> sequenceTypeBuilder_;
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
             * @return Whether the sequenceType field is set.
             */
            @java.lang.Override
            public boolean hasSequenceType() {
                return valueCase_ == 4;
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
             * @return The sequenceType.
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence getSequenceType() {
                if (sequenceTypeBuilder_ == null) {
                    if (valueCase_ == 4) {
                        return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence) value_;
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.getDefaultInstance();
                } else {
                    if (valueCase_ == 4) {
                        return sequenceTypeBuilder_.getMessage();
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            public Builder setSequenceType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence value) {
                if (sequenceTypeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    value_ = value;
                    onChanged();
                } else {
                    sequenceTypeBuilder_.setMessage(value);
                }
                valueCase_ = 4;
                return this;
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            public Builder setSequenceType(
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.Builder builderForValue) {
                if (sequenceTypeBuilder_ == null) {
                    value_ = builderForValue.build();
                    onChanged();
                } else {
                    sequenceTypeBuilder_.setMessage(builderForValue.build());
                }
                valueCase_ = 4;
                return this;
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            public Builder mergeSequenceType(ProtoOnnx.TypeProto.Sequence value) {
                if (sequenceTypeBuilder_ == null) {
                    if (valueCase_ == 4 &&
                        value_ != org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.getDefaultInstance()) {
                        value_ = org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.newBuilder((org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence) value_)
                            .mergeFrom(value).buildPartial();
                    } else {
                        value_ = value;
                    }
                    onChanged();
                } else {
                    if (valueCase_ == 4) {
                        sequenceTypeBuilder_.mergeFrom(value);
                    } else {
                        sequenceTypeBuilder_.setMessage(value);
                    }
                }
                valueCase_ = 4;
                return this;
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            public Builder clearSequenceType() {
                if (sequenceTypeBuilder_ == null) {
                    if (valueCase_ == 4) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                } else {
                    if (valueCase_ == 4) {
                        valueCase_ = 0;
                        value_ = null;
                    }
                    sequenceTypeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.Builder getSequenceTypeBuilder() {
                return internalGetSequenceTypeFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder() {
                if ((valueCase_ == 4) && (sequenceTypeBuilder_ != null)) {
                    return sequenceTypeBuilder_.getMessageOrBuilder();
                } else {
                    if (valueCase_ == 4) {
                        return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence) value_;
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.Builder, ProtoOnnx.TypeProto.SequenceOrBuilder>
            internalGetSequenceTypeFieldBuilder() {
                if (sequenceTypeBuilder_ == null) {
                    if (!(valueCase_ == 4)) {
                        value_ = org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.getDefaultInstance();
                    }
                    sequenceTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Sequence.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SequenceOrBuilder>(
                        (ProtoOnnx.TypeProto.Sequence) value_,
                        getParentForChildren(),
                        isClean());
                    value_ = null;
                }
                valueCase_ = 4;
                onChanged();
                return sequenceTypeBuilder_;
            }
            
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.MapOrBuilder> mapTypeBuilder_;
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
             * @return Whether the mapType field is set.
             */
            @java.lang.Override
            public boolean hasMapType() {
                return valueCase_ == 5;
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
             * @return The mapType.
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map getMapType() {
                if (mapTypeBuilder_ == null) {
                    if (valueCase_ == 5) {
                        return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map) value_;
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.getDefaultInstance();
                } else {
                    if (valueCase_ == 5) {
                        return mapTypeBuilder_.getMessage();
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
             */
            public Builder setMapType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map value) {
                if (mapTypeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    value_ = value;
                    onChanged();
                } else {
                    mapTypeBuilder_.setMessage(value);
                }
                valueCase_ = 5;
                return this;
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
             */
            public Builder setMapType(
                ProtoOnnx.TypeProto.Map.Builder builderForValue) {
                if (mapTypeBuilder_ == null) {
                    value_ = builderForValue.build();
                    onChanged();
                } else {
                    mapTypeBuilder_.setMessage(builderForValue.build());
                }
                valueCase_ = 5;
                return this;
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
             */
            public Builder mergeMapType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map value) {
                if (mapTypeBuilder_ == null) {
                    if (valueCase_ == 5 &&
                        value_ != org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.getDefaultInstance()) {
                        value_ = org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.newBuilder((org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map) value_)
                            .mergeFrom(value).buildPartial();
                    } else {
                        value_ = value;
                    }
                    onChanged();
                } else {
                    if (valueCase_ == 5) {
                        mapTypeBuilder_.mergeFrom(value);
                    } else {
                        mapTypeBuilder_.setMessage(value);
                    }
                }
                valueCase_ = 5;
                return this;
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
             */
            public Builder clearMapType() {
                if (mapTypeBuilder_ == null) {
                    if (valueCase_ == 5) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                } else {
                    if (valueCase_ == 5) {
                        valueCase_ = 0;
                        value_ = null;
                    }
                    mapTypeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.Builder getMapTypeBuilder() {
                return internalGetMapTypeFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.MapOrBuilder getMapTypeOrBuilder() {
                if ((valueCase_ == 5) && (mapTypeBuilder_ != null)) {
                    return mapTypeBuilder_.getMessageOrBuilder();
                } else {
                    if (valueCase_ == 5) {
                        return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map) value_;
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Map map_type = 5;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.Builder, ProtoOnnx.TypeProto.MapOrBuilder>
            internalGetMapTypeFieldBuilder() {
                if (mapTypeBuilder_ == null) {
                    if (!(valueCase_ == 5)) {
                        value_ = org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map.getDefaultInstance();
                    }
                    mapTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map, ProtoOnnx.TypeProto.Map.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.MapOrBuilder>(
                        (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Map) value_,
                        getParentForChildren(),
                        isClean());
                    value_ = null;
                }
                valueCase_ = 5;
                onChanged();
                return mapTypeBuilder_;
            }
            
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional, ProtoOnnx.TypeProto.Optional.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.OptionalOrBuilder> optionalTypeBuilder_;
            /**
             * <pre>
             * The type of an optional.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
             * @return Whether the optionalType field is set.
             */
            @java.lang.Override
            public boolean hasOptionalType() {
                return valueCase_ == 9;
            }
            /**
             * <pre>
             * The type of an optional.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
             * @return The optionalType.
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional getOptionalType() {
                if (optionalTypeBuilder_ == null) {
                    if (valueCase_ == 9) {
                        return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional) value_;
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.getDefaultInstance();
                } else {
                    if (valueCase_ == 9) {
                        return optionalTypeBuilder_.getMessage();
                    }
                    return ProtoOnnx.TypeProto.Optional.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of an optional.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
             */
            public Builder setOptionalType(ProtoOnnx.TypeProto.Optional value) {
                if (optionalTypeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    value_ = value;
                    onChanged();
                } else {
                    optionalTypeBuilder_.setMessage(value);
                }
                valueCase_ = 9;
                return this;
            }
            /**
             * <pre>
             * The type of an optional.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
             */
            public Builder setOptionalType(
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.Builder builderForValue) {
                if (optionalTypeBuilder_ == null) {
                    value_ = builderForValue.build();
                    onChanged();
                } else {
                    optionalTypeBuilder_.setMessage(builderForValue.build());
                }
                valueCase_ = 9;
                return this;
            }
            /**
             * <pre>
             * The type of an optional.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
             */
            public Builder mergeOptionalType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional value) {
                if (optionalTypeBuilder_ == null) {
                    if (valueCase_ == 9 &&
                        value_ != org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.getDefaultInstance()) {
                        value_ = org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.newBuilder((org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional) value_)
                            .mergeFrom(value).buildPartial();
                    } else {
                        value_ = value;
                    }
                    onChanged();
                } else {
                    if (valueCase_ == 9) {
                        optionalTypeBuilder_.mergeFrom(value);
                    } else {
                        optionalTypeBuilder_.setMessage(value);
                    }
                }
                valueCase_ = 9;
                return this;
            }
            /**
             * <pre>
             * The type of an optional.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
             */
            public Builder clearOptionalType() {
                if (optionalTypeBuilder_ == null) {
                    if (valueCase_ == 9) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                } else {
                    if (valueCase_ == 9) {
                        valueCase_ = 0;
                        value_ = null;
                    }
                    optionalTypeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The type of an optional.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.Builder getOptionalTypeBuilder() {
                return internalGetOptionalTypeFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The type of an optional.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.OptionalOrBuilder getOptionalTypeOrBuilder() {
                if ((valueCase_ == 9) && (optionalTypeBuilder_ != null)) {
                    return optionalTypeBuilder_.getMessageOrBuilder();
                } else {
                    if (valueCase_ == 9) {
                        return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional) value_;
                    }
                    return ProtoOnnx.TypeProto.Optional.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of an optional.
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.Optional optional_type = 9;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.OptionalOrBuilder>
            internalGetOptionalTypeFieldBuilder() {
                if (optionalTypeBuilder_ == null) {
                    if (!(valueCase_ == 9)) {
                        value_ = ProtoOnnx.TypeProto.Optional.getDefaultInstance();
                    }
                    optionalTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.OptionalOrBuilder>(
                        (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.Optional) value_,
                        getParentForChildren(),
                        isClean());
                    value_ = null;
                }
                valueCase_ = 9;
                onChanged();
                return optionalTypeBuilder_;
            }
            
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensorOrBuilder> sparseTensorTypeBuilder_;
            /**
             * <pre>
             * Type of the sparse tensor
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             * @return Whether the sparseTensorType field is set.
             */
            @java.lang.Override
            public boolean hasSparseTensorType() {
                return valueCase_ == 8;
            }
            /**
             * <pre>
             * Type of the sparse tensor
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             * @return The sparseTensorType.
             */
            @java.lang.Override
            public ProtoOnnx.TypeProto.SparseTensor getSparseTensorType() {
                if (sparseTensorTypeBuilder_ == null) {
                    if (valueCase_ == 8) {
                        return (ProtoOnnx.TypeProto.SparseTensor) value_;
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.getDefaultInstance();
                } else {
                    if (valueCase_ == 8) {
                        return sparseTensorTypeBuilder_.getMessage();
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * Type of the sparse tensor
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            public Builder setSparseTensorType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor value) {
                if (sparseTensorTypeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    value_ = value;
                    onChanged();
                } else {
                    sparseTensorTypeBuilder_.setMessage(value);
                }
                valueCase_ = 8;
                return this;
            }
            /**
             * <pre>
             * Type of the sparse tensor
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            public Builder setSparseTensorType(
                ProtoOnnx.TypeProto.SparseTensor.Builder builderForValue) {
                if (sparseTensorTypeBuilder_ == null) {
                    value_ = builderForValue.build();
                    onChanged();
                } else {
                    sparseTensorTypeBuilder_.setMessage(builderForValue.build());
                }
                valueCase_ = 8;
                return this;
            }
            /**
             * <pre>
             * Type of the sparse tensor
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            public Builder mergeSparseTensorType(org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor value) {
                if (sparseTensorTypeBuilder_ == null) {
                    if (valueCase_ == 8 &&
                        value_ != org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.getDefaultInstance()) {
                        value_ = org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.newBuilder((org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor) value_)
                            .mergeFrom(value).buildPartial();
                    } else {
                        value_ = value;
                    }
                    onChanged();
                } else {
                    if (valueCase_ == 8) {
                        sparseTensorTypeBuilder_.mergeFrom(value);
                    } else {
                        sparseTensorTypeBuilder_.setMessage(value);
                    }
                }
                valueCase_ = 8;
                return this;
            }
            /**
             * <pre>
             * Type of the sparse tensor
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            public Builder clearSparseTensorType() {
                if (sparseTensorTypeBuilder_ == null) {
                    if (valueCase_ == 8) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                } else {
                    if (valueCase_ == 8) {
                        valueCase_ = 0;
                        value_ = null;
                    }
                    sparseTensorTypeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Type of the sparse tensor
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.Builder getSparseTensorTypeBuilder() {
                return internalGetSparseTensorTypeFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * Type of the sparse tensor
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder() {
                if ((valueCase_ == 8) && (sparseTensorTypeBuilder_ != null)) {
                    return sparseTensorTypeBuilder_.getMessageOrBuilder();
                } else {
                    if (valueCase_ == 8) {
                        return (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor) value_;
                    }
                    return org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * Type of the sparse tensor
             * </pre>
             *
             * <code>.org.brain4j.core.importing.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            private com.google.protobuf.SingleFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensorOrBuilder>
            internalGetSparseTensorTypeFieldBuilder() {
                if (sparseTensorTypeBuilder_ == null) {
                    if (!(valueCase_ == 8)) {
                        value_ = org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.getDefaultInstance();
                    }
                    sparseTensorTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensorOrBuilder>(
                        (org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto.SparseTensor) value_,
                        getParentForChildren(),
                        isClean());
                    value_ = null;
                }
                valueCase_ = 8;
                onChanged();
                return sparseTensorTypeBuilder_;
            }
            
            private java.lang.Object denotation_ = "";
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @return Whether the denotation field is set.
             */
            public boolean hasDenotation() {
                return ((bitField0_ & 0x00000020) != 0);
            }
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @return The denotation.
             */
            public java.lang.String getDenotation() {
                java.lang.Object ref = denotation_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        denotation_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @return The bytes for denotation.
             */
            public com.google.protobuf.ByteString
            getDenotationBytes() {
                java.lang.Object ref = denotation_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    denotation_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @param value The denotation to set.
             * @return This builder for chaining.
             */
            public Builder setDenotation(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                denotation_ = value;
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @return This builder for chaining.
             */
            public Builder clearDenotation() {
                denotation_ = getDefaultInstance().getDenotation();
                bitField0_ = (bitField0_ & ~0x00000020);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @param value The bytes for denotation to set.
             * @return This builder for chaining.
             */
            public Builder setDenotationBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                denotation_ = value;
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.TypeProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.TypeProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<TypeProto>
            PARSER = new com.google.protobuf.AbstractParser<TypeProto>() {
            @java.lang.Override
            public TypeProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<TypeProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<TypeProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.TypeProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface OperatorSetIdProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.OperatorSetIdProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return Whether the domain field is set.
         */
        boolean hasDomain();
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return The domain.
         */
        java.lang.String getDomain();
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return The bytes for domain.
         */
        com.google.protobuf.ByteString
        getDomainBytes();
        
        /**
         * <pre>
         * The version of the operator set being identified.
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional int64 version = 2;</code>
         * @return Whether the version field is set.
         */
        boolean hasVersion();
        /**
         * <pre>
         * The version of the operator set being identified.
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional int64 version = 2;</code>
         * @return The version.
         */
        long getVersion();
    }
    /**
     * <pre>
     * Operator Sets
     *
     * OperatorSets are uniquely identified by a (domain, opset_version) pair.
     * </pre>
     *
     * Protobuf type {@code org.brain4j.core.importing.onnx.OperatorSetIdProto}
     */
    public static final class OperatorSetIdProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.OperatorSetIdProto)
        OperatorSetIdProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                OperatorSetIdProto.class.getName());
        }
        // Use OperatorSetIdProto.newBuilder() to construct.
        private OperatorSetIdProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private OperatorSetIdProto() {
            domain_ = "";
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_OperatorSetIdProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_OperatorSetIdProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int DOMAIN_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private volatile java.lang.Object domain_ = "";
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return Whether the domain field is set.
         */
        @java.lang.Override
        public boolean hasDomain() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return The domain.
         */
        @java.lang.Override
        public java.lang.String getDomain() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    domain_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return The bytes for domain.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDomainBytes() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                domain_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int VERSION_FIELD_NUMBER = 2;
        private long version_ = 0L;
        /**
         * <pre>
         * The version of the operator set being identified.
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional int64 version = 2;</code>
         * @return Whether the version field is set.
         */
        @java.lang.Override
        public boolean hasVersion() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The version of the operator set being identified.
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional int64 version = 2;</code>
         * @return The version.
         */
        @java.lang.Override
        public long getVersion() {
            return version_;
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 1, domain_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeInt64(2, version_);
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(1, domain_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                    .computeInt64Size(2, version_);
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto)) {
                return super.equals(obj);
            }
            org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto) obj;
            
            if (hasDomain() != other.hasDomain()) return false;
            if (hasDomain()) {
                if (!getDomain()
                    .equals(other.getDomain())) return false;
            }
            if (hasVersion() != other.hasVersion()) return false;
            if (hasVersion()) {
                if (getVersion()
                    != other.getVersion()) return false;
            }
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasDomain()) {
                hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
                hash = (53 * hash) + getDomain().hashCode();
            }
            if (hasVersion()) {
                hash = (37 * hash) + VERSION_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                    getVersion());
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ProtoOnnx.OperatorSetIdProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ProtoOnnx.OperatorSetIdProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Operator Sets
         *
         * OperatorSets are uniquely identified by a (domain, opset_version) pair.
         * </pre>
         *
         * Protobuf type {@code org.brain4j.core.importing.onnx.OperatorSetIdProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.OperatorSetIdProto)
            ProtoOnnx.OperatorSetIdProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_OperatorSetIdProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_OperatorSetIdProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                domain_ = "";
                version_ = 0L;
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ProtoOnnx.internal_static_onnx_OperatorSetIdProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto result = new ProtoOnnx.OperatorSetIdProto(this);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartial0(ProtoOnnx.OperatorSetIdProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.domain_ = domain_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.version_ = version_;
                    to_bitField0_ |= 0x00000002;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ProtoOnnx.OperatorSetIdProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto other) {
                if (other == ProtoOnnx.OperatorSetIdProto.getDefaultInstance()) return this;
                if (other.hasDomain()) {
                    domain_ = other.domain_;
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                if (other.hasVersion()) {
                    setVersion(other.getVersion());
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                domain_ = input.readBytes();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 16: {
                                version_ = input.readInt64();
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 16
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.lang.Object domain_ = "";
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return Whether the domain field is set.
             */
            public boolean hasDomain() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return The domain.
             */
            public java.lang.String getDomain() {
                java.lang.Object ref = domain_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        domain_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return The bytes for domain.
             */
            public com.google.protobuf.ByteString
            getDomainBytes() {
                java.lang.Object ref = domain_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    domain_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @param value The domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomain(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                domain_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearDomain() {
                domain_ = getDefaultInstance().getDomain();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @param value The bytes for domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomainBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                domain_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            
            private long version_ ;
            /**
             * <pre>
             * The version of the operator set being identified.
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional int64 version = 2;</code>
             * @return Whether the version field is set.
             */
            @java.lang.Override
            public boolean hasVersion() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * The version of the operator set being identified.
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional int64 version = 2;</code>
             * @return The version.
             */
            @java.lang.Override
            public long getVersion() {
                return version_;
            }
            /**
             * <pre>
             * The version of the operator set being identified.
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional int64 version = 2;</code>
             * @param value The version to set.
             * @return This builder for chaining.
             */
            public Builder setVersion(long value) {
                
                version_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The version of the operator set being identified.
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional int64 version = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearVersion() {
                bitField0_ = (bitField0_ & ~0x00000002);
                version_ = 0L;
                onChanged();
                return this;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.OperatorSetIdProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.OperatorSetIdProto)
        private static final ProtoOnnx.OperatorSetIdProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ProtoOnnx.OperatorSetIdProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<OperatorSetIdProto>
            PARSER = new com.google.protobuf.AbstractParser<OperatorSetIdProto>() {
            @java.lang.Override
            public OperatorSetIdProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<OperatorSetIdProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<OperatorSetIdProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    public interface FunctionProtoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.brain4j.core.importing.onnx.FunctionProto)
        com.google.protobuf.MessageOrBuilder {
        
        /**
         * <pre>
         * The name of the function, similar to op_type in NodeProto.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * The name of the function, similar to op_type in NodeProto.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * The name of the function, similar to op_type in NodeProto.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();
        
        /**
         * <pre>
         * The inputs and outputs of the function.
         * </pre>
         *
         * <code>repeated string input = 4;</code>
         * @return A list containing the input.
         */
        java.util.List<java.lang.String>
        getInputList();
        /**
         * <pre>
         * The inputs and outputs of the function.
         * </pre>
         *
         * <code>repeated string input = 4;</code>
         * @return The count of input.
         */
        int getInputCount();
        /**
         * <pre>
         * The inputs and outputs of the function.
         * </pre>
         *
         * <code>repeated string input = 4;</code>
         * @param index The index of the element to return.
         * @return The input at the given index.
         */
        java.lang.String getInput(int index);
        /**
         * <pre>
         * The inputs and outputs of the function.
         * </pre>
         *
         * <code>repeated string input = 4;</code>
         * @param index The index of the value to return.
         * @return The bytes of the input at the given index.
         */
        com.google.protobuf.ByteString
        getInputBytes(int index);
        
        /**
         * <code>repeated string output = 5;</code>
         * @return A list containing the output.
         */
        java.util.List<java.lang.String>
        getOutputList();
        /**
         * <code>repeated string output = 5;</code>
         * @return The count of output.
         */
        int getOutputCount();
        /**
         * <code>repeated string output = 5;</code>
         * @param index The index of the element to return.
         * @return The output at the given index.
         */
        java.lang.String getOutput(int index);
        /**
         * <code>repeated string output = 5;</code>
         * @param index The index of the value to return.
         * @return The bytes of the output at the given index.
         */
        com.google.protobuf.ByteString
        getOutputBytes(int index);
        
        /**
         * <pre>
         * The attribute parameters of the function.
         * It is for function parameters without default values.
         * </pre>
         *
         * <code>repeated string attribute = 6;</code>
         * @return A list containing the attribute.
         */
        java.util.List<java.lang.String>
        getAttributeList();
        /**
         * <pre>
         * The attribute parameters of the function.
         * It is for function parameters without default values.
         * </pre>
         *
         * <code>repeated string attribute = 6;</code>
         * @return The count of attribute.
         */
        int getAttributeCount();
        /**
         * <pre>
         * The attribute parameters of the function.
         * It is for function parameters without default values.
         * </pre>
         *
         * <code>repeated string attribute = 6;</code>
         * @param index The index of the element to return.
         * @return The attribute at the given index.
         */
        java.lang.String getAttribute(int index);
        /**
         * <pre>
         * The attribute parameters of the function.
         * It is for function parameters without default values.
         * </pre>
         *
         * <code>repeated string attribute = 6;</code>
         * @param index The index of the value to return.
         * @return The bytes of the attribute at the given index.
         */
        com.google.protobuf.ByteString
        getAttributeBytes(int index);
        
        /**
         * <pre>
         * The attribute protos of the function.
         * It is for function attributes with default values.
         * A function attribute shall be represented either as
         * a string attribute or an AttributeProto, not both.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto>
        getAttributeProtoList();
        /**
         * <pre>
         * The attribute protos of the function.
         * It is for function attributes with default values.
         * A function attribute shall be represented either as
         * a string attribute or an AttributeProto, not both.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto getAttributeProto(int index);
        /**
         * <pre>
         * The attribute protos of the function.
         * It is for function attributes with default values.
         * A function attribute shall be represented either as
         * a string attribute or an AttributeProto, not both.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
         */
        int getAttributeProtoCount();
        /**
         * <pre>
         * The attribute protos of the function.
         * It is for function attributes with default values.
         * A function attribute shall be represented either as
         * a string attribute or an AttributeProto, not both.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder>
        getAttributeProtoOrBuilderList();
        /**
         * <pre>
         * The attribute protos of the function.
         * It is for function attributes with default values.
         * A function attribute shall be represented either as
         * a string attribute or an AttributeProto, not both.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder getAttributeProtoOrBuilder(
            int index);
        
        /**
         * <pre>
         * The nodes in the function.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto>
        getNodeList();
        /**
         * <pre>
         * The nodes in the function.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto getNode(int index);
        /**
         * <pre>
         * The nodes in the function.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
         */
        int getNodeCount();
        /**
         * <pre>
         * The nodes in the function.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder>
        getNodeOrBuilderList();
        /**
         * <pre>
         * The nodes in the function.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder getNodeOrBuilder(
            int index);
        
        /**
         * <pre>
         * A human-readable documentation for this function. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 8;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this function. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 8;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this function. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 8;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();
        
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto>
        getOpsetImportList();
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
         */
        ProtoOnnx.OperatorSetIdProto getOpsetImport(int index);
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
         */
        int getOpsetImportCount();
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder>
        getOpsetImportOrBuilderList();
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
            int index);
        
        /**
         * <pre>
         * The domain which this function belongs to.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string domain = 10;</code>
         * @return Whether the domain field is set.
         */
        boolean hasDomain();
        /**
         * <pre>
         * The domain which this function belongs to.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string domain = 10;</code>
         * @return The domain.
         */
        java.lang.String getDomain();
        /**
         * <pre>
         * The domain which this function belongs to.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string domain = 10;</code>
         * @return The bytes for domain.
         */
        com.google.protobuf.ByteString
        getDomainBytes();
        
        /**
         * <pre>
         * The overload identifier of the function.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string overload = 13;</code>
         * @return Whether the overload field is set.
         */
        boolean hasOverload();
        /**
         * <pre>
         * The overload identifier of the function.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string overload = 13;</code>
         * @return The overload.
         */
        java.lang.String getOverload();
        /**
         * <pre>
         * The overload identifier of the function.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string overload = 13;</code>
         * @return The bytes for overload.
         */
        com.google.protobuf.ByteString
        getOverloadBytes();
        
        /**
         * <pre>
         * Information for the values in the function. The ValueInfoProto.name's
         * must be distinct and refer to names in the function (including inputs,
         * outputs, and intermediate values). It is optional for a value to appear
         * in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
         */
        java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto>
        getValueInfoList();
        /**
         * <pre>
         * Information for the values in the function. The ValueInfoProto.name's
         * must be distinct and refer to names in the function (including inputs,
         * outputs, and intermediate values). It is optional for a value to appear
         * in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
         */
        ProtoOnnx.ValueInfoProto getValueInfo(int index);
        /**
         * <pre>
         * Information for the values in the function. The ValueInfoProto.name's
         * must be distinct and refer to names in the function (including inputs,
         * outputs, and intermediate values). It is optional for a value to appear
         * in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
         */
        int getValueInfoCount();
        /**
         * <pre>
         * Information for the values in the function. The ValueInfoProto.name's
         * must be distinct and refer to names in the function (including inputs,
         * outputs, and intermediate values). It is optional for a value to appear
         * in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
        getValueInfoOrBuilderList();
        /**
         * <pre>
         * Information for the values in the function. The ValueInfoProto.name's
         * must be distinct and refer to names in the function (including inputs,
         * outputs, and intermediate values). It is optional for a value to appear
         * in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
            int index);
        
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        java.util.List<ProtoOnnx.StringStringEntryProto>
        getMetadataPropsList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index);
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        int getMetadataPropsCount();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index);
    }
    /**
     * Protobuf type {@code org.brain4j.core.importing.onnx.FunctionProto}
     */
    public static final class FunctionProto extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:org.brain4j.core.importing.onnx.FunctionProto)
        FunctionProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
                com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 31,
                /* patch= */ 1,
                /* suffix= */ "",
                FunctionProto.class.getName());
        }
        // Use FunctionProto.newBuilder() to construct.
        private FunctionProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
        }
        private FunctionProto() {
            name_ = "";
            input_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            output_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            attribute_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            attributeProto_ = java.util.Collections.emptyList();
            node_ = java.util.Collections.emptyList();
            docString_ = "";
            opsetImport_ = java.util.Collections.emptyList();
            domain_ = "";
            overload_ = "";
            valueInfo_ = java.util.Collections.emptyList();
            metadataProps_ = java.util.Collections.emptyList();
        }
        
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ProtoOnnx.internal_static_onnx_FunctionProto_descriptor;
        }
        
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_FunctionProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.Builder.class);
        }
        
        private int bitField0_;
        public static final int NAME_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private volatile java.lang.Object name_ = "";
        /**
         * <pre>
         * The name of the function, similar to op_type in NodeProto.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The name of the function, similar to op_type in NodeProto.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The name of the function, similar to op_type in NodeProto.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int INPUT_FIELD_NUMBER = 4;
        @SuppressWarnings("serial")
        private com.google.protobuf.LazyStringArrayList input_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        /**
         * <pre>
         * The inputs and outputs of the function.
         * </pre>
         *
         * <code>repeated string input = 4;</code>
         * @return A list containing the input.
         */
        public com.google.protobuf.ProtocolStringList
        getInputList() {
            return input_;
        }
        /**
         * <pre>
         * The inputs and outputs of the function.
         * </pre>
         *
         * <code>repeated string input = 4;</code>
         * @return The count of input.
         */
        public int getInputCount() {
            return input_.size();
        }
        /**
         * <pre>
         * The inputs and outputs of the function.
         * </pre>
         *
         * <code>repeated string input = 4;</code>
         * @param index The index of the element to return.
         * @return The input at the given index.
         */
        public java.lang.String getInput(int index) {
            return input_.get(index);
        }
        /**
         * <pre>
         * The inputs and outputs of the function.
         * </pre>
         *
         * <code>repeated string input = 4;</code>
         * @param index The index of the value to return.
         * @return The bytes of the input at the given index.
         */
        public com.google.protobuf.ByteString
        getInputBytes(int index) {
            return input_.getByteString(index);
        }
        
        public static final int OUTPUT_FIELD_NUMBER = 5;
        @SuppressWarnings("serial")
        private com.google.protobuf.LazyStringArrayList output_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        /**
         * <code>repeated string output = 5;</code>
         * @return A list containing the output.
         */
        public com.google.protobuf.ProtocolStringList
        getOutputList() {
            return output_;
        }
        /**
         * <code>repeated string output = 5;</code>
         * @return The count of output.
         */
        public int getOutputCount() {
            return output_.size();
        }
        /**
         * <code>repeated string output = 5;</code>
         * @param index The index of the element to return.
         * @return The output at the given index.
         */
        public java.lang.String getOutput(int index) {
            return output_.get(index);
        }
        /**
         * <code>repeated string output = 5;</code>
         * @param index The index of the value to return.
         * @return The bytes of the output at the given index.
         */
        public com.google.protobuf.ByteString
        getOutputBytes(int index) {
            return output_.getByteString(index);
        }
        
        public static final int ATTRIBUTE_FIELD_NUMBER = 6;
        @SuppressWarnings("serial")
        private com.google.protobuf.LazyStringArrayList attribute_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        /**
         * <pre>
         * The attribute parameters of the function.
         * It is for function parameters without default values.
         * </pre>
         *
         * <code>repeated string attribute = 6;</code>
         * @return A list containing the attribute.
         */
        public com.google.protobuf.ProtocolStringList
        getAttributeList() {
            return attribute_;
        }
        /**
         * <pre>
         * The attribute parameters of the function.
         * It is for function parameters without default values.
         * </pre>
         *
         * <code>repeated string attribute = 6;</code>
         * @return The count of attribute.
         */
        public int getAttributeCount() {
            return attribute_.size();
        }
        /**
         * <pre>
         * The attribute parameters of the function.
         * It is for function parameters without default values.
         * </pre>
         *
         * <code>repeated string attribute = 6;</code>
         * @param index The index of the element to return.
         * @return The attribute at the given index.
         */
        public java.lang.String getAttribute(int index) {
            return attribute_.get(index);
        }
        /**
         * <pre>
         * The attribute parameters of the function.
         * It is for function parameters without default values.
         * </pre>
         *
         * <code>repeated string attribute = 6;</code>
         * @param index The index of the value to return.
         * @return The bytes of the attribute at the given index.
         */
        public com.google.protobuf.ByteString
        getAttributeBytes(int index) {
            return attribute_.getByteString(index);
        }
        
        public static final int ATTRIBUTE_PROTO_FIELD_NUMBER = 11;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto> attributeProto_;
        /**
         * <pre>
         * The attribute protos of the function.
         * It is for function attributes with default values.
         * A function attribute shall be represented either as
         * a string attribute or an AttributeProto, not both.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto> getAttributeProtoList() {
            return attributeProto_;
        }
        /**
         * <pre>
         * The attribute protos of the function.
         * It is for function attributes with default values.
         * A function attribute shall be represented either as
         * a string attribute or an AttributeProto, not both.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder>
        getAttributeProtoOrBuilderList() {
            return attributeProto_;
        }
        /**
         * <pre>
         * The attribute protos of the function.
         * It is for function attributes with default values.
         * A function attribute shall be represented either as
         * a string attribute or an AttributeProto, not both.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
         */
        @java.lang.Override
        public int getAttributeProtoCount() {
            return attributeProto_.size();
        }
        /**
         * <pre>
         * The attribute protos of the function.
         * It is for function attributes with default values.
         * A function attribute shall be represented either as
         * a string attribute or an AttributeProto, not both.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto getAttributeProto(int index) {
            return attributeProto_.get(index);
        }
        /**
         * <pre>
         * The attribute protos of the function.
         * It is for function attributes with default values.
         * A function attribute shall be represented either as
         * a string attribute or an AttributeProto, not both.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder getAttributeProtoOrBuilder(
            int index) {
            return attributeProto_.get(index);
        }
        
        public static final int NODE_FIELD_NUMBER = 7;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto> node_;
        /**
         * <pre>
         * The nodes in the function.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto> getNodeList() {
            return node_;
        }
        /**
         * <pre>
         * The nodes in the function.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder>
        getNodeOrBuilderList() {
            return node_;
        }
        /**
         * <pre>
         * The nodes in the function.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
         */
        @java.lang.Override
        public int getNodeCount() {
            return node_.size();
        }
        /**
         * <pre>
         * The nodes in the function.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto getNode(int index) {
            return node_.get(index);
        }
        /**
         * <pre>
         * The nodes in the function.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
         */
        @java.lang.Override
        public ProtoOnnx.NodeProtoOrBuilder getNodeOrBuilder(
            int index) {
            return node_.get(index);
        }
        
        public static final int DOC_STRING_FIELD_NUMBER = 8;
        @SuppressWarnings("serial")
        private volatile java.lang.Object docString_ = "";
        /**
         * <pre>
         * A human-readable documentation for this function. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 8;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this function. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 8;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this function. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 8;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int OPSET_IMPORT_FIELD_NUMBER = 9;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto> opsetImport_;
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.OperatorSetIdProto> getOpsetImportList() {
            return opsetImport_;
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder>
        getOpsetImportOrBuilderList() {
            return opsetImport_;
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
         */
        @java.lang.Override
        public int getOpsetImportCount() {
            return opsetImport_.size();
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto getOpsetImport(int index) {
            return opsetImport_.get(index);
        }
        /**
         * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
            int index) {
            return opsetImport_.get(index);
        }
        
        public static final int DOMAIN_FIELD_NUMBER = 10;
        @SuppressWarnings("serial")
        private volatile java.lang.Object domain_ = "";
        /**
         * <pre>
         * The domain which this function belongs to.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string domain = 10;</code>
         * @return Whether the domain field is set.
         */
        @java.lang.Override
        public boolean hasDomain() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The domain which this function belongs to.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string domain = 10;</code>
         * @return The domain.
         */
        @java.lang.Override
        public java.lang.String getDomain() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    domain_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The domain which this function belongs to.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string domain = 10;</code>
         * @return The bytes for domain.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDomainBytes() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                domain_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int OVERLOAD_FIELD_NUMBER = 13;
        @SuppressWarnings("serial")
        private volatile java.lang.Object overload_ = "";
        /**
         * <pre>
         * The overload identifier of the function.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string overload = 13;</code>
         * @return Whether the overload field is set.
         */
        @java.lang.Override
        public boolean hasOverload() {
            return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * The overload identifier of the function.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string overload = 13;</code>
         * @return The overload.
         */
        @java.lang.Override
        public java.lang.String getOverload() {
            java.lang.Object ref = overload_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    overload_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The overload identifier of the function.
         * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
         * </pre>
         *
         * <code>optional string overload = 13;</code>
         * @return The bytes for overload.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getOverloadBytes() {
            java.lang.Object ref = overload_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                overload_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }
        
        public static final int VALUE_INFO_FIELD_NUMBER = 12;
        @SuppressWarnings("serial")
        private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> valueInfo_;
        /**
         * <pre>
         * Information for the values in the function. The ValueInfoProto.name's
         * must be distinct and refer to names in the function (including inputs,
         * outputs, and intermediate values). It is optional for a value to appear
         * in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
         */
        @java.lang.Override
        public java.util.List<ProtoOnnx.ValueInfoProto> getValueInfoList() {
            return valueInfo_;
        }
        /**
         * <pre>
         * Information for the values in the function. The ValueInfoProto.name's
         * must be distinct and refer to names in the function (including inputs,
         * outputs, and intermediate values). It is optional for a value to appear
         * in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
        getValueInfoOrBuilderList() {
            return valueInfo_;
        }
        /**
         * <pre>
         * Information for the values in the function. The ValueInfoProto.name's
         * must be distinct and refer to names in the function (including inputs,
         * outputs, and intermediate values). It is optional for a value to appear
         * in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
         */
        @java.lang.Override
        public int getValueInfoCount() {
            return valueInfo_.size();
        }
        /**
         * <pre>
         * Information for the values in the function. The ValueInfoProto.name's
         * must be distinct and refer to names in the function (including inputs,
         * outputs, and intermediate values). It is optional for a value to appear
         * in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto getValueInfo(int index) {
            return valueInfo_.get(index);
        }
        /**
         * <pre>
         * Information for the values in the function. The ValueInfoProto.name's
         * must be distinct and refer to names in the function (including inputs,
         * outputs, and intermediate values). It is optional for a value to appear
         * in value_info list.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
         */
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
            int index) {
            return valueInfo_.get(index);
        }
        
        public static final int METADATA_PROPS_FIELD_NUMBER = 14;
        @SuppressWarnings("serial")
        private java.util.List<ProtoOnnx.StringStringEntryProto> metadataProps_;
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public int getMetadataPropsCount() {
            return metadataProps_.size();
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
            return metadataProps_.get(index);
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
            int index) {
            return metadataProps_.get(index);
        }
        
        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;
            
            memoizedIsInitialized = 1;
            return true;
        }
        
        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
            }
            for (int i = 0; i < input_.size(); i++) {
                com.google.protobuf.GeneratedMessage.writeString(output, 4, input_.getRaw(i));
            }
            for (int i = 0; i < output_.size(); i++) {
                com.google.protobuf.GeneratedMessage.writeString(output, 5, output_.getRaw(i));
            }
            for (int i = 0; i < attribute_.size(); i++) {
                com.google.protobuf.GeneratedMessage.writeString(output, 6, attribute_.getRaw(i));
            }
            for (int i = 0; i < node_.size(); i++) {
                output.writeMessage(7, node_.get(i));
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 8, docString_);
            }
            for (int i = 0; i < opsetImport_.size(); i++) {
                output.writeMessage(9, opsetImport_.get(i));
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 10, domain_);
            }
            for (int i = 0; i < attributeProto_.size(); i++) {
                output.writeMessage(11, attributeProto_.get(i));
            }
            for (int i = 0; i < valueInfo_.size(); i++) {
                output.writeMessage(12, valueInfo_.get(i));
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                com.google.protobuf.GeneratedMessage.writeString(output, 13, overload_);
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                output.writeMessage(14, metadataProps_.get(i));
            }
            getUnknownFields().writeTo(output);
        }
        
        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;
            
            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
            }
            {
                int dataSize = 0;
                for (int i = 0; i < input_.size(); i++) {
                    dataSize += computeStringSizeNoTag(input_.getRaw(i));
                }
                size += dataSize;
                size += 1 * getInputList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < output_.size(); i++) {
                    dataSize += computeStringSizeNoTag(output_.getRaw(i));
                }
                size += dataSize;
                size += 1 * getOutputList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < attribute_.size(); i++) {
                    dataSize += computeStringSizeNoTag(attribute_.getRaw(i));
                }
                size += dataSize;
                size += 1 * getAttributeList().size();
            }
            for (int i = 0; i < node_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(7, node_.get(i));
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(8, docString_);
            }
            for (int i = 0; i < opsetImport_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(9, opsetImport_.get(i));
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(10, domain_);
            }
            for (int i = 0; i < attributeProto_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(11, attributeProto_.get(i));
            }
            for (int i = 0; i < valueInfo_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(12, valueInfo_.get(i));
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                size += com.google.protobuf.GeneratedMessage.computeStringSize(13, overload_);
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(14, metadataProps_.get(i));
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }
        
        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ProtoOnnx.FunctionProto)) {
                return super.equals(obj);
            }
            ProtoOnnx.FunctionProto other = (org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto) obj;
            
            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                    .equals(other.getName())) return false;
            }
            if (!getInputList()
                .equals(other.getInputList())) return false;
            if (!getOutputList()
                .equals(other.getOutputList())) return false;
            if (!getAttributeList()
                .equals(other.getAttributeList())) return false;
            if (!getAttributeProtoList()
                .equals(other.getAttributeProtoList())) return false;
            if (!getNodeList()
                .equals(other.getNodeList())) return false;
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                    .equals(other.getDocString())) return false;
            }
            if (!getOpsetImportList()
                .equals(other.getOpsetImportList())) return false;
            if (hasDomain() != other.hasDomain()) return false;
            if (hasDomain()) {
                if (!getDomain()
                    .equals(other.getDomain())) return false;
            }
            if (hasOverload() != other.hasOverload()) return false;
            if (hasOverload()) {
                if (!getOverload()
                    .equals(other.getOverload())) return false;
            }
            if (!getValueInfoList()
                .equals(other.getValueInfoList())) return false;
            if (!getMetadataPropsList()
                .equals(other.getMetadataPropsList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
        }
        
        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (getInputCount() > 0) {
                hash = (37 * hash) + INPUT_FIELD_NUMBER;
                hash = (53 * hash) + getInputList().hashCode();
            }
            if (getOutputCount() > 0) {
                hash = (37 * hash) + OUTPUT_FIELD_NUMBER;
                hash = (53 * hash) + getOutputList().hashCode();
            }
            if (getAttributeCount() > 0) {
                hash = (37 * hash) + ATTRIBUTE_FIELD_NUMBER;
                hash = (53 * hash) + getAttributeList().hashCode();
            }
            if (getAttributeProtoCount() > 0) {
                hash = (37 * hash) + ATTRIBUTE_PROTO_FIELD_NUMBER;
                hash = (53 * hash) + getAttributeProtoList().hashCode();
            }
            if (getNodeCount() > 0) {
                hash = (37 * hash) + NODE_FIELD_NUMBER;
                hash = (53 * hash) + getNodeList().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (getOpsetImportCount() > 0) {
                hash = (37 * hash) + OPSET_IMPORT_FIELD_NUMBER;
                hash = (53 * hash) + getOpsetImportList().hashCode();
            }
            if (hasDomain()) {
                hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
                hash = (53 * hash) + getDomain().hashCode();
            }
            if (hasOverload()) {
                hash = (37 * hash) + OVERLOAD_FIELD_NUMBER;
                hash = (53 * hash) + getOverload().hashCode();
            }
            if (getValueInfoCount() > 0) {
                hash = (37 * hash) + VALUE_INFO_FIELD_NUMBER;
                hash = (53 * hash) + getValueInfoList().hashCode();
            }
            if (getMetadataPropsCount() > 0) {
                hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
                hash = (53 * hash) + getMetadataPropsList().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
        }
        public static ProtoOnnx.FunctionProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
        }
        
        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ProtoOnnx.FunctionProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
        }
        
        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * Protobuf type {@code org.brain4j.core.importing.onnx.FunctionProto}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:org.brain4j.core.importing.onnx.FunctionProto)
            org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ProtoOnnx.internal_static_onnx_FunctionProto_descriptor;
            }
            
            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_FunctionProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                        org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.class, org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.Builder.class);
            }
            
            // Construct using org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.newBuilder()
            private Builder() {
            
            }
            
            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
                super(parent);
                
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                bitField0_ = 0;
                name_ = "";
                input_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                output_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                attribute_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                if (attributeProtoBuilder_ == null) {
                    attributeProto_ = java.util.Collections.emptyList();
                } else {
                    attributeProto_ = null;
                    attributeProtoBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000010);
                if (nodeBuilder_ == null) {
                    node_ = java.util.Collections.emptyList();
                } else {
                    node_ = null;
                    nodeBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000020);
                docString_ = "";
                if (opsetImportBuilder_ == null) {
                    opsetImport_ = java.util.Collections.emptyList();
                } else {
                    opsetImport_ = null;
                    opsetImportBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000080);
                domain_ = "";
                overload_ = "";
                if (valueInfoBuilder_ == null) {
                    valueInfo_ = java.util.Collections.emptyList();
                } else {
                    valueInfo_ = null;
                    valueInfoBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000400);
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                } else {
                    metadataProps_ = null;
                    metadataPropsBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000800);
                return this;
            }
            
            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.internal_static_onnx_FunctionProto_descriptor;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto getDefaultInstanceForType() {
                return org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.getDefaultInstance();
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto build() {
                org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }
            
            @java.lang.Override
            public org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto buildPartial() {
                org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto result = new ProtoOnnx.FunctionProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0) { buildPartial0(result); }
                onBuilt();
                return result;
            }
            
            private void buildPartialRepeatedFields(org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto result) {
                if (attributeProtoBuilder_ == null) {
                    if (((bitField0_ & 0x00000010) != 0)) {
                        attributeProto_ = java.util.Collections.unmodifiableList(attributeProto_);
                        bitField0_ = (bitField0_ & ~0x00000010);
                    }
                    result.attributeProto_ = attributeProto_;
                } else {
                    result.attributeProto_ = attributeProtoBuilder_.build();
                }
                if (nodeBuilder_ == null) {
                    if (((bitField0_ & 0x00000020) != 0)) {
                        node_ = java.util.Collections.unmodifiableList(node_);
                        bitField0_ = (bitField0_ & ~0x00000020);
                    }
                    result.node_ = node_;
                } else {
                    result.node_ = nodeBuilder_.build();
                }
                if (opsetImportBuilder_ == null) {
                    if (((bitField0_ & 0x00000080) != 0)) {
                        opsetImport_ = java.util.Collections.unmodifiableList(opsetImport_);
                        bitField0_ = (bitField0_ & ~0x00000080);
                    }
                    result.opsetImport_ = opsetImport_;
                } else {
                    result.opsetImport_ = opsetImportBuilder_.build();
                }
                if (valueInfoBuilder_ == null) {
                    if (((bitField0_ & 0x00000400) != 0)) {
                        valueInfo_ = java.util.Collections.unmodifiableList(valueInfo_);
                        bitField0_ = (bitField0_ & ~0x00000400);
                    }
                    result.valueInfo_ = valueInfo_;
                } else {
                    result.valueInfo_ = valueInfoBuilder_.build();
                }
                if (metadataPropsBuilder_ == null) {
                    if (((bitField0_ & 0x00000800) != 0)) {
                        metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
                        bitField0_ = (bitField0_ & ~0x00000800);
                    }
                    result.metadataProps_ = metadataProps_;
                } else {
                    result.metadataProps_ = metadataPropsBuilder_.build();
                }
            }
            
            private void buildPartial0(org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto result) {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.name_ = name_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    input_.makeImmutable();
                    result.input_ = input_;
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    output_.makeImmutable();
                    result.output_ = output_;
                }
                if (((from_bitField0_ & 0x00000008) != 0)) {
                    attribute_.makeImmutable();
                    result.attribute_ = attribute_;
                }
                if (((from_bitField0_ & 0x00000040) != 0)) {
                    result.docString_ = docString_;
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000100) != 0)) {
                    result.domain_ = domain_;
                    to_bitField0_ |= 0x00000004;
                }
                if (((from_bitField0_ & 0x00000200) != 0)) {
                    result.overload_ = overload_;
                    to_bitField0_ |= 0x00000008;
                }
                result.bitField0_ |= to_bitField0_;
            }
            
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto) {
                    return mergeFrom((org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }
            
            public Builder mergeFrom(org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto other) {
                if (other == org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto.getDefaultInstance()) return this;
                if (other.hasName()) {
                    name_ = other.name_;
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                if (!other.input_.isEmpty()) {
                    if (input_.isEmpty()) {
                        input_ = other.input_;
                        bitField0_ |= 0x00000002;
                    } else {
                        ensureInputIsMutable();
                        input_.addAll(other.input_);
                    }
                    onChanged();
                }
                if (!other.output_.isEmpty()) {
                    if (output_.isEmpty()) {
                        output_ = other.output_;
                        bitField0_ |= 0x00000004;
                    } else {
                        ensureOutputIsMutable();
                        output_.addAll(other.output_);
                    }
                    onChanged();
                }
                if (!other.attribute_.isEmpty()) {
                    if (attribute_.isEmpty()) {
                        attribute_ = other.attribute_;
                        bitField0_ |= 0x00000008;
                    } else {
                        ensureAttributeIsMutable();
                        attribute_.addAll(other.attribute_);
                    }
                    onChanged();
                }
                if (attributeProtoBuilder_ == null) {
                    if (!other.attributeProto_.isEmpty()) {
                        if (attributeProto_.isEmpty()) {
                            attributeProto_ = other.attributeProto_;
                            bitField0_ = (bitField0_ & ~0x00000010);
                        } else {
                            ensureAttributeProtoIsMutable();
                            attributeProto_.addAll(other.attributeProto_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.attributeProto_.isEmpty()) {
                        if (attributeProtoBuilder_.isEmpty()) {
                            attributeProtoBuilder_.dispose();
                            attributeProtoBuilder_ = null;
                            attributeProto_ = other.attributeProto_;
                            bitField0_ = (bitField0_ & ~0x00000010);
                            attributeProtoBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetAttributeProtoFieldBuilder() : null;
                        } else {
                            attributeProtoBuilder_.addAllMessages(other.attributeProto_);
                        }
                    }
                }
                if (nodeBuilder_ == null) {
                    if (!other.node_.isEmpty()) {
                        if (node_.isEmpty()) {
                            node_ = other.node_;
                            bitField0_ = (bitField0_ & ~0x00000020);
                        } else {
                            ensureNodeIsMutable();
                            node_.addAll(other.node_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.node_.isEmpty()) {
                        if (nodeBuilder_.isEmpty()) {
                            nodeBuilder_.dispose();
                            nodeBuilder_ = null;
                            node_ = other.node_;
                            bitField0_ = (bitField0_ & ~0x00000020);
                            nodeBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetNodeFieldBuilder() : null;
                        } else {
                            nodeBuilder_.addAllMessages(other.node_);
                        }
                    }
                }
                if (other.hasDocString()) {
                    docString_ = other.docString_;
                    bitField0_ |= 0x00000040;
                    onChanged();
                }
                if (opsetImportBuilder_ == null) {
                    if (!other.opsetImport_.isEmpty()) {
                        if (opsetImport_.isEmpty()) {
                            opsetImport_ = other.opsetImport_;
                            bitField0_ = (bitField0_ & ~0x00000080);
                        } else {
                            ensureOpsetImportIsMutable();
                            opsetImport_.addAll(other.opsetImport_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.opsetImport_.isEmpty()) {
                        if (opsetImportBuilder_.isEmpty()) {
                            opsetImportBuilder_.dispose();
                            opsetImportBuilder_ = null;
                            opsetImport_ = other.opsetImport_;
                            bitField0_ = (bitField0_ & ~0x00000080);
                            opsetImportBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetOpsetImportFieldBuilder() : null;
                        } else {
                            opsetImportBuilder_.addAllMessages(other.opsetImport_);
                        }
                    }
                }
                if (other.hasDomain()) {
                    domain_ = other.domain_;
                    bitField0_ |= 0x00000100;
                    onChanged();
                }
                if (other.hasOverload()) {
                    overload_ = other.overload_;
                    bitField0_ |= 0x00000200;
                    onChanged();
                }
                if (valueInfoBuilder_ == null) {
                    if (!other.valueInfo_.isEmpty()) {
                        if (valueInfo_.isEmpty()) {
                            valueInfo_ = other.valueInfo_;
                            bitField0_ = (bitField0_ & ~0x00000400);
                        } else {
                            ensureValueInfoIsMutable();
                            valueInfo_.addAll(other.valueInfo_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.valueInfo_.isEmpty()) {
                        if (valueInfoBuilder_.isEmpty()) {
                            valueInfoBuilder_.dispose();
                            valueInfoBuilder_ = null;
                            valueInfo_ = other.valueInfo_;
                            bitField0_ = (bitField0_ & ~0x00000400);
                            valueInfoBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetValueInfoFieldBuilder() : null;
                        } else {
                            valueInfoBuilder_.addAllMessages(other.valueInfo_);
                        }
                    }
                }
                if (metadataPropsBuilder_ == null) {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataProps_.isEmpty()) {
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000800);
                        } else {
                            ensureMetadataPropsIsMutable();
                            metadataProps_.addAll(other.metadataProps_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataPropsBuilder_.isEmpty()) {
                            metadataPropsBuilder_.dispose();
                            metadataPropsBuilder_ = null;
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000800);
                            metadataPropsBuilder_ =
                                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                                    internalGetMetadataPropsFieldBuilder() : null;
                        } else {
                            metadataPropsBuilder_.addAllMessages(other.metadataProps_);
                        }
                    }
                }
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }
            
            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }
            
            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                name_ = input.readBytes();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 34: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                ensureInputIsMutable();
                                input_.add(bs);
                                break;
                            } // case 34
                            case 42: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                ensureOutputIsMutable();
                                output_.add(bs);
                                break;
                            } // case 42
                            case 50: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                ensureAttributeIsMutable();
                                attribute_.add(bs);
                                break;
                            } // case 50
                            case 58: {
                                ProtoOnnx.NodeProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.parser(),
                                        extensionRegistry);
                                if (nodeBuilder_ == null) {
                                    ensureNodeIsMutable();
                                    node_.add(m);
                                } else {
                                    nodeBuilder_.addMessage(m);
                                }
                                break;
                            } // case 58
                            case 66: {
                                docString_ = input.readBytes();
                                bitField0_ |= 0x00000040;
                                break;
                            } // case 66
                            case 74: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.parser(),
                                        extensionRegistry);
                                if (opsetImportBuilder_ == null) {
                                    ensureOpsetImportIsMutable();
                                    opsetImport_.add(m);
                                } else {
                                    opsetImportBuilder_.addMessage(m);
                                }
                                break;
                            } // case 74
                            case 82: {
                                domain_ = input.readBytes();
                                bitField0_ |= 0x00000100;
                                break;
                            } // case 82
                            case 90: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto m =
                                    input.readMessage(
                                        ProtoOnnx.AttributeProto.parser(),
                                        extensionRegistry);
                                if (attributeProtoBuilder_ == null) {
                                    ensureAttributeProtoIsMutable();
                                    attributeProto_.add(m);
                                } else {
                                    attributeProtoBuilder_.addMessage(m);
                                }
                                break;
                            } // case 90
                            case 98: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto m =
                                    input.readMessage(
                                        ProtoOnnx.ValueInfoProto.parser(),
                                        extensionRegistry);
                                if (valueInfoBuilder_ == null) {
                                    ensureValueInfoIsMutable();
                                    valueInfo_.add(m);
                                } else {
                                    valueInfoBuilder_.addMessage(m);
                                }
                                break;
                            } // case 98
                            case 106: {
                                overload_ = input.readBytes();
                                bitField0_ |= 0x00000200;
                                break;
                            } // case 106
                            case 114: {
                                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto m =
                                    input.readMessage(
                                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.parser(),
                                        extensionRegistry);
                                if (metadataPropsBuilder_ == null) {
                                    ensureMetadataPropsIsMutable();
                                    metadataProps_.add(m);
                                } else {
                                    metadataPropsBuilder_.addMessage(m);
                                }
                                break;
                            } // case 114
                            default: {
                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.unwrapIOException();
                } finally {
                    onChanged();
                } // finally
                return this;
            }
            private int bitField0_;
            
            private java.lang.Object name_ = "";
            /**
             * <pre>
             * The name of the function, similar to op_type in NodeProto.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The name of the function, similar to op_type in NodeProto.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The name of the function, similar to op_type in NodeProto.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The name of the function, similar to op_type in NodeProto.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name of the function, similar to op_type in NodeProto.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                name_ = getDefaultInstance().getName();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name of the function, similar to op_type in NodeProto.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                name_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }
            
            private com.google.protobuf.LazyStringArrayList input_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            private void ensureInputIsMutable() {
                if (!input_.isModifiable()) {
                    input_ = new com.google.protobuf.LazyStringArrayList(input_);
                }
                bitField0_ |= 0x00000002;
            }
            /**
             * <pre>
             * The inputs and outputs of the function.
             * </pre>
             *
             * <code>repeated string input = 4;</code>
             * @return A list containing the input.
             */
            public com.google.protobuf.ProtocolStringList
            getInputList() {
                input_.makeImmutable();
                return input_;
            }
            /**
             * <pre>
             * The inputs and outputs of the function.
             * </pre>
             *
             * <code>repeated string input = 4;</code>
             * @return The count of input.
             */
            public int getInputCount() {
                return input_.size();
            }
            /**
             * <pre>
             * The inputs and outputs of the function.
             * </pre>
             *
             * <code>repeated string input = 4;</code>
             * @param index The index of the element to return.
             * @return The input at the given index.
             */
            public java.lang.String getInput(int index) {
                return input_.get(index);
            }
            /**
             * <pre>
             * The inputs and outputs of the function.
             * </pre>
             *
             * <code>repeated string input = 4;</code>
             * @param index The index of the value to return.
             * @return The bytes of the input at the given index.
             */
            public com.google.protobuf.ByteString
            getInputBytes(int index) {
                return input_.getByteString(index);
            }
            /**
             * <pre>
             * The inputs and outputs of the function.
             * </pre>
             *
             * <code>repeated string input = 4;</code>
             * @param index The index to set the value at.
             * @param value The input to set.
             * @return This builder for chaining.
             */
            public Builder setInput(
                int index, java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureInputIsMutable();
                input_.set(index, value);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the function.
             * </pre>
             *
             * <code>repeated string input = 4;</code>
             * @param value The input to add.
             * @return This builder for chaining.
             */
            public Builder addInput(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureInputIsMutable();
                input_.add(value);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the function.
             * </pre>
             *
             * <code>repeated string input = 4;</code>
             * @param values The input to add.
             * @return This builder for chaining.
             */
            public Builder addAllInput(
                java.lang.Iterable<java.lang.String> values) {
                ensureInputIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, input_);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the function.
             * </pre>
             *
             * <code>repeated string input = 4;</code>
             * @return This builder for chaining.
             */
            public Builder clearInput() {
                input_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                bitField0_ = (bitField0_ & ~0x00000002);;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the function.
             * </pre>
             *
             * <code>repeated string input = 4;</code>
             * @param value The bytes of the input to add.
             * @return This builder for chaining.
             */
            public Builder addInputBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                ensureInputIsMutable();
                input_.add(value);
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }
            
            private com.google.protobuf.LazyStringArrayList output_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            private void ensureOutputIsMutable() {
                if (!output_.isModifiable()) {
                    output_ = new com.google.protobuf.LazyStringArrayList(output_);
                }
                bitField0_ |= 0x00000004;
            }
            /**
             * <code>repeated string output = 5;</code>
             * @return A list containing the output.
             */
            public com.google.protobuf.ProtocolStringList
            getOutputList() {
                output_.makeImmutable();
                return output_;
            }
            /**
             * <code>repeated string output = 5;</code>
             * @return The count of output.
             */
            public int getOutputCount() {
                return output_.size();
            }
            /**
             * <code>repeated string output = 5;</code>
             * @param index The index of the element to return.
             * @return The output at the given index.
             */
            public java.lang.String getOutput(int index) {
                return output_.get(index);
            }
            /**
             * <code>repeated string output = 5;</code>
             * @param index The index of the value to return.
             * @return The bytes of the output at the given index.
             */
            public com.google.protobuf.ByteString
            getOutputBytes(int index) {
                return output_.getByteString(index);
            }
            /**
             * <code>repeated string output = 5;</code>
             * @param index The index to set the value at.
             * @param value The output to set.
             * @return This builder for chaining.
             */
            public Builder setOutput(
                int index, java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureOutputIsMutable();
                output_.set(index, value);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <code>repeated string output = 5;</code>
             * @param value The output to add.
             * @return This builder for chaining.
             */
            public Builder addOutput(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureOutputIsMutable();
                output_.add(value);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <code>repeated string output = 5;</code>
             * @param values The output to add.
             * @return This builder for chaining.
             */
            public Builder addAllOutput(
                java.lang.Iterable<java.lang.String> values) {
                ensureOutputIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, output_);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            /**
             * <code>repeated string output = 5;</code>
             * @return This builder for chaining.
             */
            public Builder clearOutput() {
                output_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                bitField0_ = (bitField0_ & ~0x00000004);;
                onChanged();
                return this;
            }
            /**
             * <code>repeated string output = 5;</code>
             * @param value The bytes of the output to add.
             * @return This builder for chaining.
             */
            public Builder addOutputBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                ensureOutputIsMutable();
                output_.add(value);
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }
            
            private com.google.protobuf.LazyStringArrayList attribute_ =
                com.google.protobuf.LazyStringArrayList.emptyList();
            private void ensureAttributeIsMutable() {
                if (!attribute_.isModifiable()) {
                    attribute_ = new com.google.protobuf.LazyStringArrayList(attribute_);
                }
                bitField0_ |= 0x00000008;
            }
            /**
             * <pre>
             * The attribute parameters of the function.
             * It is for function parameters without default values.
             * </pre>
             *
             * <code>repeated string attribute = 6;</code>
             * @return A list containing the attribute.
             */
            public com.google.protobuf.ProtocolStringList
            getAttributeList() {
                attribute_.makeImmutable();
                return attribute_;
            }
            /**
             * <pre>
             * The attribute parameters of the function.
             * It is for function parameters without default values.
             * </pre>
             *
             * <code>repeated string attribute = 6;</code>
             * @return The count of attribute.
             */
            public int getAttributeCount() {
                return attribute_.size();
            }
            /**
             * <pre>
             * The attribute parameters of the function.
             * It is for function parameters without default values.
             * </pre>
             *
             * <code>repeated string attribute = 6;</code>
             * @param index The index of the element to return.
             * @return The attribute at the given index.
             */
            public java.lang.String getAttribute(int index) {
                return attribute_.get(index);
            }
            /**
             * <pre>
             * The attribute parameters of the function.
             * It is for function parameters without default values.
             * </pre>
             *
             * <code>repeated string attribute = 6;</code>
             * @param index The index of the value to return.
             * @return The bytes of the attribute at the given index.
             */
            public com.google.protobuf.ByteString
            getAttributeBytes(int index) {
                return attribute_.getByteString(index);
            }
            /**
             * <pre>
             * The attribute parameters of the function.
             * It is for function parameters without default values.
             * </pre>
             *
             * <code>repeated string attribute = 6;</code>
             * @param index The index to set the value at.
             * @param value The attribute to set.
             * @return This builder for chaining.
             */
            public Builder setAttribute(
                int index, java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureAttributeIsMutable();
                attribute_.set(index, value);
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The attribute parameters of the function.
             * It is for function parameters without default values.
             * </pre>
             *
             * <code>repeated string attribute = 6;</code>
             * @param value The attribute to add.
             * @return This builder for chaining.
             */
            public Builder addAttribute(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                ensureAttributeIsMutable();
                attribute_.add(value);
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The attribute parameters of the function.
             * It is for function parameters without default values.
             * </pre>
             *
             * <code>repeated string attribute = 6;</code>
             * @param values The attribute to add.
             * @return This builder for chaining.
             */
            public Builder addAllAttribute(
                java.lang.Iterable<java.lang.String> values) {
                ensureAttributeIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                    values, attribute_);
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The attribute parameters of the function.
             * It is for function parameters without default values.
             * </pre>
             *
             * <code>repeated string attribute = 6;</code>
             * @return This builder for chaining.
             */
            public Builder clearAttribute() {
                attribute_ =
                    com.google.protobuf.LazyStringArrayList.emptyList();
                bitField0_ = (bitField0_ & ~0x00000008);;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The attribute parameters of the function.
             * It is for function parameters without default values.
             * </pre>
             *
             * <code>repeated string attribute = 6;</code>
             * @param value The bytes of the attribute to add.
             * @return This builder for chaining.
             */
            public Builder addAttributeBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                ensureAttributeIsMutable();
                attribute_.add(value);
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto> attributeProto_ =
                java.util.Collections.emptyList();
            private void ensureAttributeProtoIsMutable() {
                if (!((bitField0_ & 0x00000010) != 0)) {
                    attributeProto_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto>(attributeProto_);
                    bitField0_ |= 0x00000010;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder> attributeProtoBuilder_;
            
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto> getAttributeProtoList() {
                if (attributeProtoBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(attributeProto_);
                } else {
                    return attributeProtoBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public int getAttributeProtoCount() {
                if (attributeProtoBuilder_ == null) {
                    return attributeProto_.size();
                } else {
                    return attributeProtoBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto getAttributeProto(int index) {
                if (attributeProtoBuilder_ == null) {
                    return attributeProto_.get(index);
                } else {
                    return attributeProtoBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public Builder setAttributeProto(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto value) {
                if (attributeProtoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureAttributeProtoIsMutable();
                    attributeProto_.set(index, value);
                    onChanged();
                } else {
                    attributeProtoBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public Builder setAttributeProto(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder builderForValue) {
                if (attributeProtoBuilder_ == null) {
                    ensureAttributeProtoIsMutable();
                    attributeProto_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    attributeProtoBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public Builder addAttributeProto(org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto value) {
                if (attributeProtoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureAttributeProtoIsMutable();
                    attributeProto_.add(value);
                    onChanged();
                } else {
                    attributeProtoBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public Builder addAttributeProto(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto value) {
                if (attributeProtoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureAttributeProtoIsMutable();
                    attributeProto_.add(index, value);
                    onChanged();
                } else {
                    attributeProtoBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public Builder addAttributeProto(
                org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder builderForValue) {
                if (attributeProtoBuilder_ == null) {
                    ensureAttributeProtoIsMutable();
                    attributeProto_.add(builderForValue.build());
                    onChanged();
                } else {
                    attributeProtoBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public Builder addAttributeProto(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder builderForValue) {
                if (attributeProtoBuilder_ == null) {
                    ensureAttributeProtoIsMutable();
                    attributeProto_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    attributeProtoBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public Builder addAllAttributeProto(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto> values) {
                if (attributeProtoBuilder_ == null) {
                    ensureAttributeProtoIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, attributeProto_);
                    onChanged();
                } else {
                    attributeProtoBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public Builder clearAttributeProto() {
                if (attributeProtoBuilder_ == null) {
                    attributeProto_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000010);
                    onChanged();
                } else {
                    attributeProtoBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public Builder removeAttributeProto(int index) {
                if (attributeProtoBuilder_ == null) {
                    ensureAttributeProtoIsMutable();
                    attributeProto_.remove(index);
                    onChanged();
                } else {
                    attributeProtoBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder getAttributeProtoBuilder(
                int index) {
                return internalGetAttributeProtoFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public ProtoOnnx.AttributeProtoOrBuilder getAttributeProtoOrBuilder(
                int index) {
                if (attributeProtoBuilder_ == null) {
                    return attributeProto_.get(index);  } else {
                    return attributeProtoBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder>
            getAttributeProtoOrBuilderList() {
                if (attributeProtoBuilder_ != null) {
                    return attributeProtoBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(attributeProto_);
                }
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public ProtoOnnx.AttributeProto.Builder addAttributeProtoBuilder() {
                return internalGetAttributeProtoFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder addAttributeProtoBuilder(
                int index) {
                return internalGetAttributeProtoFieldBuilder().addBuilder(
                    index, ProtoOnnx.AttributeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The attribute protos of the function.
             * It is for function attributes with default values.
             * A function attribute shall be represented either as
             * a string attribute or an AttributeProto, not both.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.AttributeProto attribute_proto = 11;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder>
            getAttributeProtoBuilderList() {
                return internalGetAttributeProtoFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder>
            internalGetAttributeProtoFieldBuilder() {
                if (attributeProtoBuilder_ == null) {
                    attributeProtoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.AttributeProto, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.AttributeProtoOrBuilder>(
                        attributeProto_,
                        ((bitField0_ & 0x00000010) != 0),
                        getParentForChildren(),
                        isClean());
                    attributeProto_ = null;
                }
                return attributeProtoBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto> node_ =
                java.util.Collections.emptyList();
            private void ensureNodeIsMutable() {
                if (!((bitField0_ & 0x00000020) != 0)) {
                    node_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto>(node_);
                    bitField0_ |= 0x00000020;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder> nodeBuilder_;
            
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto> getNodeList() {
                if (nodeBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(node_);
                } else {
                    return nodeBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public int getNodeCount() {
                if (nodeBuilder_ == null) {
                    return node_.size();
                } else {
                    return nodeBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto getNode(int index) {
                if (nodeBuilder_ == null) {
                    return node_.get(index);
                } else {
                    return nodeBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public Builder setNode(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto value) {
                if (nodeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureNodeIsMutable();
                    node_.set(index, value);
                    onChanged();
                } else {
                    nodeBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public Builder setNode(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder builderForValue) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    nodeBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public Builder addNode(org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto value) {
                if (nodeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureNodeIsMutable();
                    node_.add(value);
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public Builder addNode(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto value) {
                if (nodeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureNodeIsMutable();
                    node_.add(index, value);
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public Builder addNode(
                org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder builderForValue) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.add(builderForValue.build());
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public Builder addNode(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder builderForValue) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public Builder addAllNode(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto> values) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, node_);
                    onChanged();
                } else {
                    nodeBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public Builder clearNode() {
                if (nodeBuilder_ == null) {
                    node_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000020);
                    onChanged();
                } else {
                    nodeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public Builder removeNode(int index) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.remove(index);
                    onChanged();
                } else {
                    nodeBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder getNodeBuilder(
                int index) {
                return internalGetNodeFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder getNodeOrBuilder(
                int index) {
                if (nodeBuilder_ == null) {
                    return node_.get(index);  } else {
                    return nodeBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder>
            getNodeOrBuilderList() {
                if (nodeBuilder_ != null) {
                    return nodeBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(node_);
                }
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder addNodeBuilder() {
                return internalGetNodeFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public ProtoOnnx.NodeProto.Builder addNodeBuilder(
                int index) {
                return internalGetNodeFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The nodes in the function.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.NodeProto node = 7;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder>
            getNodeBuilderList() {
                return internalGetNodeFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.NodeProto, ProtoOnnx.NodeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder>
            internalGetNodeFieldBuilder() {
                if (nodeBuilder_ == null) {
                    nodeBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.NodeProtoOrBuilder>(
                        node_,
                        ((bitField0_ & 0x00000020) != 0),
                        getParentForChildren(),
                        isClean());
                    node_ = null;
                }
                return nodeBuilder_;
            }
            
            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this function. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 8;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000040) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this function. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 8;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this function. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 8;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this function. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 8;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000040;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this function. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 8;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                docString_ = getDefaultInstance().getDocString();
                bitField0_ = (bitField0_ & ~0x00000040);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this function. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 8;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                docString_ = value;
                bitField0_ |= 0x00000040;
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto> opsetImport_ =
                java.util.Collections.emptyList();
            private void ensureOpsetImportIsMutable() {
                if (!((bitField0_ & 0x00000080) != 0)) {
                    opsetImport_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto>(opsetImport_);
                    bitField0_ |= 0x00000080;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder> opsetImportBuilder_;
            
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public java.util.List<ProtoOnnx.OperatorSetIdProto> getOpsetImportList() {
                if (opsetImportBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(opsetImport_);
                } else {
                    return opsetImportBuilder_.getMessageList();
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public int getOpsetImportCount() {
                if (opsetImportBuilder_ == null) {
                    return opsetImport_.size();
                } else {
                    return opsetImportBuilder_.getCount();
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public ProtoOnnx.OperatorSetIdProto getOpsetImport(int index) {
                if (opsetImportBuilder_ == null) {
                    return opsetImport_.get(index);
                } else {
                    return opsetImportBuilder_.getMessage(index);
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public Builder setOpsetImport(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto value) {
                if (opsetImportBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOpsetImportIsMutable();
                    opsetImport_.set(index, value);
                    onChanged();
                } else {
                    opsetImportBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public Builder setOpsetImport(
                int index, ProtoOnnx.OperatorSetIdProto.Builder builderForValue) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    opsetImportBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public Builder addOpsetImport(ProtoOnnx.OperatorSetIdProto value) {
                if (opsetImportBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(value);
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public Builder addOpsetImport(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto value) {
                if (opsetImportBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(index, value);
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public Builder addOpsetImport(
                org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder builderForValue) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(builderForValue.build());
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public Builder addOpsetImport(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder builderForValue) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public Builder addAllOpsetImport(
                java.lang.Iterable<? extends ProtoOnnx.OperatorSetIdProto> values) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, opsetImport_);
                    onChanged();
                } else {
                    opsetImportBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public Builder clearOpsetImport() {
                if (opsetImportBuilder_ == null) {
                    opsetImport_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000080);
                    onChanged();
                } else {
                    opsetImportBuilder_.clear();
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public Builder removeOpsetImport(int index) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.remove(index);
                    onChanged();
                } else {
                    opsetImportBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder getOpsetImportBuilder(
                int index) {
                return internalGetOpsetImportFieldBuilder().getBuilder(index);
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
                int index) {
                if (opsetImportBuilder_ == null) {
                    return opsetImport_.get(index);  } else {
                    return opsetImportBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder>
            getOpsetImportOrBuilderList() {
                if (opsetImportBuilder_ != null) {
                    return opsetImportBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(opsetImport_);
                }
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder addOpsetImportBuilder() {
                return internalGetOpsetImportFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.getDefaultInstance());
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder addOpsetImportBuilder(
                int index) {
                return internalGetOpsetImportFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.getDefaultInstance());
            }
            /**
             * <code>repeated .org.brain4j.core.importing.onnx.OperatorSetIdProto opset_import = 9;</code>
             */
            public java.util.List<ProtoOnnx.OperatorSetIdProto.Builder>
            getOpsetImportBuilderList() {
                return internalGetOpsetImportFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder>
            internalGetOpsetImportFieldBuilder() {
                if (opsetImportBuilder_ == null) {
                    opsetImportBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.OperatorSetIdProtoOrBuilder>(
                        opsetImport_,
                        ((bitField0_ & 0x00000080) != 0),
                        getParentForChildren(),
                        isClean());
                    opsetImport_ = null;
                }
                return opsetImportBuilder_;
            }
            
            private java.lang.Object domain_ = "";
            /**
             * <pre>
             * The domain which this function belongs to.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string domain = 10;</code>
             * @return Whether the domain field is set.
             */
            public boolean hasDomain() {
                return ((bitField0_ & 0x00000100) != 0);
            }
            /**
             * <pre>
             * The domain which this function belongs to.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string domain = 10;</code>
             * @return The domain.
             */
            public java.lang.String getDomain() {
                java.lang.Object ref = domain_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        domain_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The domain which this function belongs to.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string domain = 10;</code>
             * @return The bytes for domain.
             */
            public com.google.protobuf.ByteString
            getDomainBytes() {
                java.lang.Object ref = domain_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    domain_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The domain which this function belongs to.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string domain = 10;</code>
             * @param value The domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomain(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                domain_ = value;
                bitField0_ |= 0x00000100;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The domain which this function belongs to.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string domain = 10;</code>
             * @return This builder for chaining.
             */
            public Builder clearDomain() {
                domain_ = getDefaultInstance().getDomain();
                bitField0_ = (bitField0_ & ~0x00000100);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The domain which this function belongs to.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string domain = 10;</code>
             * @param value The bytes for domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomainBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                domain_ = value;
                bitField0_ |= 0x00000100;
                onChanged();
                return this;
            }
            
            private java.lang.Object overload_ = "";
            /**
             * <pre>
             * The overload identifier of the function.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string overload = 13;</code>
             * @return Whether the overload field is set.
             */
            public boolean hasOverload() {
                return ((bitField0_ & 0x00000200) != 0);
            }
            /**
             * <pre>
             * The overload identifier of the function.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string overload = 13;</code>
             * @return The overload.
             */
            public java.lang.String getOverload() {
                java.lang.Object ref = overload_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        overload_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The overload identifier of the function.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string overload = 13;</code>
             * @return The bytes for overload.
             */
            public com.google.protobuf.ByteString
            getOverloadBytes() {
                java.lang.Object ref = overload_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                            (java.lang.String) ref);
                    overload_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The overload identifier of the function.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string overload = 13;</code>
             * @param value The overload to set.
             * @return This builder for chaining.
             */
            public Builder setOverload(
                java.lang.String value) {
                if (value == null) { throw new NullPointerException(); }
                overload_ = value;
                bitField0_ |= 0x00000200;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The overload identifier of the function.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string overload = 13;</code>
             * @return This builder for chaining.
             */
            public Builder clearOverload() {
                overload_ = getDefaultInstance().getOverload();
                bitField0_ = (bitField0_ & ~0x00000200);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The overload identifier of the function.
             * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
             * </pre>
             *
             * <code>optional string overload = 13;</code>
             * @param value The bytes for overload to set.
             * @return This builder for chaining.
             */
            public Builder setOverloadBytes(
                com.google.protobuf.ByteString value) {
                if (value == null) { throw new NullPointerException(); }
                overload_ = value;
                bitField0_ |= 0x00000200;
                onChanged();
                return this;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> valueInfo_ =
                java.util.Collections.emptyList();
            private void ensureValueInfoIsMutable() {
                if (!((bitField0_ & 0x00000400) != 0)) {
                    valueInfo_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto>(valueInfo_);
                    bitField0_ |= 0x00000400;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder> valueInfoBuilder_;
            
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> getValueInfoList() {
                if (valueInfoBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(valueInfo_);
                } else {
                    return valueInfoBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public int getValueInfoCount() {
                if (valueInfoBuilder_ == null) {
                    return valueInfo_.size();
                } else {
                    return valueInfoBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public ProtoOnnx.ValueInfoProto getValueInfo(int index) {
                if (valueInfoBuilder_ == null) {
                    return valueInfo_.get(index);
                } else {
                    return valueInfoBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public Builder setValueInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (valueInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureValueInfoIsMutable();
                    valueInfo_.set(index, value);
                    onChanged();
                } else {
                    valueInfoBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public Builder setValueInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    valueInfoBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public Builder addValueInfo(org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (valueInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureValueInfoIsMutable();
                    valueInfo_.add(value);
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public Builder addValueInfo(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto value) {
                if (valueInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureValueInfoIsMutable();
                    valueInfo_.add(index, value);
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public Builder addValueInfo(
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.add(builderForValue.build());
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public Builder addValueInfo(
                int index, ProtoOnnx.ValueInfoProto.Builder builderForValue) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public Builder addAllValueInfo(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto> values) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, valueInfo_);
                    onChanged();
                } else {
                    valueInfoBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public Builder clearValueInfo() {
                if (valueInfoBuilder_ == null) {
                    valueInfo_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000400);
                    onChanged();
                } else {
                    valueInfoBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public Builder removeValueInfo(int index) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.remove(index);
                    onChanged();
                } else {
                    valueInfoBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder getValueInfoBuilder(
                int index) {
                return internalGetValueInfoFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
                int index) {
                if (valueInfoBuilder_ == null) {
                    return valueInfo_.get(index);  } else {
                    return valueInfoBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public java.util.List<? extends org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
            getValueInfoOrBuilderList() {
                if (valueInfoBuilder_ != null) {
                    return valueInfoBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(valueInfo_);
                }
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public ProtoOnnx.ValueInfoProto.Builder addValueInfoBuilder() {
                return internalGetValueInfoFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder addValueInfoBuilder(
                int index) {
                return internalGetValueInfoFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Information for the values in the function. The ValueInfoProto.name's
             * must be distinct and refer to names in the function (including inputs,
             * outputs, and intermediate values). It is optional for a value to appear
             * in value_info list.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.ValueInfoProto value_info = 12;</code>
             */
            public java.util.List<ProtoOnnx.ValueInfoProto.Builder>
            getValueInfoBuilderList() {
                return internalGetValueInfoFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>
            internalGetValueInfoFieldBuilder() {
                if (valueInfoBuilder_ == null) {
                    valueInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        ProtoOnnx.ValueInfoProto, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.ValueInfoProtoOrBuilder>(
                        valueInfo_,
                        ((bitField0_ & 0x00000400) != 0),
                        getParentForChildren(),
                        isClean());
                    valueInfo_ = null;
                }
                return valueInfoBuilder_;
            }
            
            private java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> metadataProps_ =
                java.util.Collections.emptyList();
            private void ensureMetadataPropsIsMutable() {
                if (!((bitField0_ & 0x00000800) != 0)) {
                    metadataProps_ = new java.util.ArrayList<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto>(metadataProps_);
                    bitField0_ |= 0x00000800;
                }
            }
            
            private com.google.protobuf.RepeatedFieldBuilder<
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;
            
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> getMetadataPropsList() {
                if (metadataPropsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                } else {
                    return metadataPropsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public int getMetadataPropsCount() {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.size();
                } else {
                    return metadataPropsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto getMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);
                } else {
                    return metadataPropsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder setMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder setMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(
                org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(
                int index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addAllMetadataProps(
                java.lang.Iterable<? extends org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto> values) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, metadataProps_);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder clearMetadataProps() {
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000800);
                    onChanged();
                } else {
                    metadataPropsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder removeMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.remove(index);
                    onChanged();
                } else {
                    metadataPropsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
                int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);  } else {
                    return metadataPropsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public java.util.List<? extends ProtoOnnx.StringStringEntryProtoOrBuilder>
            getMetadataPropsOrBuilderList() {
                if (metadataPropsBuilder_ != null) {
                    return metadataPropsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
                int index) {
                return internalGetMetadataPropsFieldBuilder().addBuilder(
                    index, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .org.brain4j.core.importing.onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public java.util.List<org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder>
            getMetadataPropsBuilderList() {
                return internalGetMetadataPropsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilder<
                ProtoOnnx.StringStringEntryProto, ProtoOnnx.StringStringEntryProto.Builder, ProtoOnnx.StringStringEntryProtoOrBuilder>
            internalGetMetadataPropsFieldBuilder() {
                if (metadataPropsBuilder_ == null) {
                    metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                        org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProto.Builder, org.brain4j.core.importing.onnx.ProtoOnnx.StringStringEntryProtoOrBuilder>(
                        metadataProps_,
                        ((bitField0_ & 0x00000800) != 0),
                        getParentForChildren(),
                        isClean());
                    metadataProps_ = null;
                }
                return metadataPropsBuilder_;
            }
            
            // @@protoc_insertion_point(builder_scope:org.brain4j.core.importing.onnx.FunctionProto)
        }
        
        // @@protoc_insertion_point(class_scope:org.brain4j.core.importing.onnx.FunctionProto)
        private static final org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto();
        }
        
        public static org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }
        
        private static final com.google.protobuf.Parser<FunctionProto>
            PARSER = new com.google.protobuf.AbstractParser<FunctionProto>() {
            @java.lang.Override
            public FunctionProto parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
                Builder builder = newBuilder();
                try {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (com.google.protobuf.UninitializedMessageException e) {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };
        
        public static com.google.protobuf.Parser<FunctionProto> parser() {
            return PARSER;
        }
        
        @java.lang.Override
        public com.google.protobuf.Parser<FunctionProto> getParserForType() {
            return PARSER;
        }
        
        @java.lang.Override
        public org.brain4j.core.importing.onnx.ProtoOnnx.FunctionProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }
        
    }
    
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_AttributeProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_AttributeProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_ValueInfoProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_ValueInfoProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_NodeProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_NodeProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_IntIntListEntryProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_IntIntListEntryProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_NodeDeviceConfigurationProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_NodeDeviceConfigurationProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_ShardingSpecProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_ShardingSpecProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_ShardedDimProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_ShardedDimProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_SimpleShardedDimProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_SimpleShardedDimProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TrainingInfoProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TrainingInfoProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_ModelProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_ModelProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_DeviceConfigurationProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_DeviceConfigurationProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_StringStringEntryProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_StringStringEntryProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TensorAnnotation_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TensorAnnotation_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_GraphProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_GraphProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TensorProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TensorProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TensorProto_Segment_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TensorProto_Segment_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_SparseTensorProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_SparseTensorProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TensorShapeProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TensorShapeProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TensorShapeProto_Dimension_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TypeProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TypeProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TypeProto_Tensor_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TypeProto_Tensor_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TypeProto_Sequence_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TypeProto_Sequence_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TypeProto_Map_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TypeProto_Map_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TypeProto_Optional_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TypeProto_Optional_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_TypeProto_SparseTensor_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_OperatorSetIdProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_OperatorSetIdProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
        internal_static_onnx_FunctionProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internal_static_onnx_FunctionProto_fieldAccessorTable;
    
    public static com.google.protobuf.Descriptors.FileDescriptor
    getDescriptor() {
        return descriptor;
    }
    private static  com.google.protobuf.Descriptors.FileDescriptor
        descriptor;
    static {
        java.lang.String[] descriptorData = {
            "\n\norg.brain4j.core.importing.onnx.proto\022\004onnx\"\333\005\n\016AttributeProto\022\014\n" +
                "\004name\030\001 \001(\t\022\025\n\rref_attr_name\030\025 \001(\t\022\022\n\ndo" +
                "c_string\030\r \001(\t\0220\n\004type\030\024 \001(\0162\".org.brain4j.core.importing.onnx.Attr" +
                "ibuteProto.AttributeType\022\t\n\001f\030\002 \001(\002\022\t\n\001i" +
                "\030\003 \001(\003\022\t\n\001s\030\004 \001(\014\022\034\n\001t\030\005 \001(\0132\021.org.brain4j.core.importing.onnx.Tens" +
                "orProto\022\033\n\001g\030\006 \001(\0132\020.org.brain4j.core.importing.onnx.GraphProto\022.\n\r" +
                "sparse_tensor\030\026 \001(\0132\027.org.brain4j.core.importing.onnx.SparseTensorP" +
                "roto\022\033\n\002tp\030\016 \001(\0132\017.org.brain4j.core.importing.onnx.TypeProto\022\016\n\006flo" +
                "ats\030\007 \003(\002\022\014\n\004ints\030\010 \003(\003\022\017\n\007strings\030\t \003(\014" +
                "\022\"\n\007tensors\030\n \003(\0132\021.org.brain4j.core.importing.onnx.TensorProto\022 \n\006" +
                "graphs\030\013 \003(\0132\020.org.brain4j.core.importing.onnx.GraphProto\022/\n\016sparse" +
                "_tensors\030\027 \003(\0132\027.org.brain4j.core.importing.onnx.SparseTensorProto\022" +
                "$\n\013type_protos\030\017 \003(\0132\017.org.brain4j.core.importing.onnx.TypeProto\"\331\001" +
                "\n\rAttributeType\022\r\n\tUNDEFINED\020\000\022\t\n\005FLOAT\020" +
                "\001\022\007\n\003INT\020\002\022\n\n\006STRING\020\003\022\n\n\006TENSOR\020\004\022\t\n\005GR" +
                "APH\020\005\022\021\n\rSPARSE_TENSOR\020\013\022\016\n\nTYPE_PROTO\020\r" +
                "\022\n\n\006FLOATS\020\006\022\010\n\004INTS\020\007\022\013\n\007STRINGS\020\010\022\013\n\007T" +
                "ENSORS\020\t\022\n\n\006GRAPHS\020\n\022\022\n\016SPARSE_TENSORS\020\014" +
                "\022\017\n\013TYPE_PROTOS\020\016J\004\010\014\020\rJ\004\010\020\020\024R\001v\"\207\001\n\016Val" +
                "ueInfoProto\022\014\n\004name\030\001 \001(\t\022\035\n\004type\030\002 \001(\0132" +
                "\017.org.brain4j.core.importing.onnx.TypeProto\022\022\n\ndoc_string\030\003 \001(\t\0224\n\016" +
                "metadata_props\030\004 \003(\0132\034.org.brain4j.core.importing.onnx.StringString" +
                "EntryProto\"\241\002\n\tNodeProto\022\r\n\005input\030\001 \003(\t\022" +
                "\016\n\006output\030\002 \003(\t\022\014\n\004name\030\003 \001(\t\022\017\n\007op_type" +
                "\030\004 \001(\t\022\016\n\006domain\030\007 \001(\t\022\020\n\010overload\030\010 \001(\t" +
                "\022\'\n\tattribute\030\005 \003(\0132\024.org.brain4j.core.importing.onnx.AttributeProt" +
                "o\022\022\n\ndoc_string\030\006 \001(\t\0224\n\016metadata_props\030" +
                "\t \003(\0132\034.org.brain4j.core.importing.onnx.StringStringEntryProto\022A\n\025d" +
                "evice_configurations\030\n \003(\0132\".org.brain4j.core.importing.onnx.NodeDe" +
                "viceConfigurationProto\"2\n\024IntIntListEntr" +
                "yProto\022\013\n\003key\030\001 \001(\003\022\r\n\005value\030\002 \003(\003\"\200\001\n\034N" +
                "odeDeviceConfigurationProto\022\030\n\020configura" +
                "tion_id\030\001 \001(\t\022.\n\rsharding_spec\030\002 \003(\0132\027.o" +
                "nnx.ShardingSpecProto\022\026\n\016pipeline_stage\030" +
                "\003 \001(\005\"\243\001\n\021ShardingSpecProto\022\023\n\013tensor_na" +
                "me\030\001 \001(\t\022\016\n\006device\030\002 \003(\003\022=\n\031index_to_dev" +
                "ice_group_map\030\003 \003(\0132\032.org.brain4j.core.importing.onnx.IntIntListEnt" +
                "ryProto\022*\n\013sharded_dim\030\004 \003(\0132\025.org.brain4j.core.importing.onnx.Shar" +
                "dedDimProto\"U\n\017ShardedDimProto\022\014\n\004axis\030\001" +
                " \001(\003\0224\n\017simple_sharding\030\002 \003(\0132\033.org.brain4j.core.importing.onnx.Sim" +
                "pleShardedDimProto\"\\\n\025SimpleShardedDimPr" +
                "oto\022\023\n\tdim_value\030\001 \001(\003H\000\022\023\n\tdim_param\030\002 " +
                "\001(\tH\000\022\022\n\nnum_shards\030\003 \001(\003B\005\n\003dim\"\326\001\n\021Tra" +
                "iningInfoProto\022(\n\016initialization\030\001 \001(\0132\020" +
                ".org.brain4j.core.importing.onnx.GraphProto\022#\n\talgorithm\030\002 \001(\0132\020.on" +
                "nx.GraphProto\022<\n\026initialization_binding\030" +
                "\003 \003(\0132\034.org.brain4j.core.importing.onnx.StringStringEntryProto\0224\n\016u" +
                "pdate_binding\030\004 \003(\0132\034.org.brain4j.core.importing.onnx.StringStringE" +
                "ntryProto\"\242\003\n\nModelProto\022\022\n\nir_version\030\001" +
                " \001(\003\022.\n\014opset_import\030\010 \003(\0132\030.org.brain4j.core.importing.onnx.Operat" +
                "orSetIdProto\022\025\n\rproducer_name\030\002 \001(\t\022\030\n\020p" +
                "roducer_version\030\003 \001(\t\022\016\n\006domain\030\004 \001(\t\022\025\n" +
                "\rmodel_version\030\005 \001(\003\022\022\n\ndoc_string\030\006 \001(\t" +
                "\022\037\n\005graph\030\007 \001(\0132\020.org.brain4j.core.importing.onnx.GraphProto\0224\n\016met" +
                "adata_props\030\016 \003(\0132\034.org.brain4j.core.importing.onnx.StringStringEnt" +
                "ryProto\022.\n\rtraining_info\030\024 \003(\0132\027.org.brain4j.core.importing.onnx.Tr" +
                "ainingInfoProto\022&\n\tfunctions\030\031 \003(\0132\023.onn" +
                "x.FunctionProto\0225\n\rconfiguration\030\032 \003(\0132\036" +
                ".org.brain4j.core.importing.onnx.DeviceConfigurationProto\"M\n\030Device" +
                "ConfigurationProto\022\014\n\004name\030\001 \001(\t\022\023\n\013num_" +
                "devices\030\002 \001(\005\022\016\n\006device\030\003 \003(\t\"4\n\026StringS" +
                "tringEntryProto\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 " +
                "\001(\t\"k\n\020TensorAnnotation\022\023\n\013tensor_name\030\001" +
                " \001(\t\022B\n\034quant_parameter_tensor_names\030\002 \003" +
                "(\0132\034.org.brain4j.core.importing.onnx.StringStringEntryProto\"\324\003\n\nGra" +
                "phProto\022\035\n\004node\030\001 \003(\0132\017.org.brain4j.core.importing.onnx.NodeProto\022\014" +
                "\n\004name\030\002 \001(\t\022&\n\013initializer\030\005 \003(\0132\021.onnx" +
                ".TensorProto\0223\n\022sparse_initializer\030\017 \003(\013" +
                "2\027.org.brain4j.core.importing.onnx.SparseTensorProto\022\022\n\ndoc_string\030" +
                "\n \001(\t\022#\n\005input\030\013 \003(\0132\024.org.brain4j.core.importing.onnx.ValueInfoPro" +
                "to\022$\n\006output\030\014 \003(\0132\024.org.brain4j.core.importing.onnx.ValueInfoProto" +
                "\022(\n\nvalue_info\030\r \003(\0132\024.org.brain4j.core.importing.onnx.ValueInfoPro" +
                "to\0227\n\027quantization_annotation\030\016 \003(\0132\026.on" +
                "nx.TensorAnnotation\0224\n\016metadata_props\030\020 " +
                "\003(\0132\034.org.brain4j.core.importing.onnx.StringStringEntryProtoJ\004\010\003\020\004J" +
                "\004\010\004\020\005J\004\010\006\020\nR\nir_versionR\020producer_versio" +
                "nR\014producer_tagR\006domain\"\335\006\n\013TensorProto\022" +
                "\014\n\004dims\030\001 \003(\003\022\021\n\tdata_type\030\002 \001(\005\022*\n\007segm" +
                "ent\030\003 \001(\0132\031.org.brain4j.core.importing.onnx.TensorProto.Segment\022\026\n\n" +
                "float_data\030\004 \003(\002B\002\020\001\022\026\n\nint32_data\030\005 \003(\005" +
                "B\002\020\001\022\023\n\013string_data\030\006 \003(\014\022\026\n\nint64_data\030" +
                "\007 \003(\003B\002\020\001\022\014\n\004name\030\010 \001(\t\022\022\n\ndoc_string\030\014 " +
                "\001(\t\022\020\n\010raw_data\030\t \001(\014\0223\n\rexternal_data\030\r" +
                " \003(\0132\034.org.brain4j.core.importing.onnx.StringStringEntryProto\0225\n\rda" +
                "ta_location\030\016 \001(\0162\036.org.brain4j.core.importing.onnx.TensorProto.Dat" +
                "aLocation\022\027\n\013double_data\030\n \003(\001B\002\020\001\022\027\n\013ui" +
                "nt64_data\030\013 \003(\004B\002\020\001\0224\n\016metadata_props\030\020 " +
                "\003(\0132\034.org.brain4j.core.importing.onnx.StringStringEntryProto\032%\n\007Seg" +
                "ment\022\r\n\005begin\030\001 \001(\003\022\013\n\003end\030\002 \001(\003\"\311\002\n\010Dat" +
                "aType\022\r\n\tUNDEFINED\020\000\022\t\n\005FLOAT\020\001\022\t\n\005UINT8" +
                "\020\002\022\010\n\004INT8\020\003\022\n\n\006UINT16\020\004\022\t\n\005INT16\020\005\022\t\n\005I" +
                "NT32\020\006\022\t\n\005INT64\020\007\022\n\n\006STRING\020\010\022\010\n\004BOOL\020\t\022" +
                "\013\n\007FLOAT16\020\n\022\n\n\006DOUBLE\020\013\022\n\n\006UINT32\020\014\022\n\n\006" +
                "UINT64\020\r\022\r\n\tCOMPLEX64\020\016\022\016\n\nCOMPLEX128\020\017\022" +
                "\014\n\010BFLOAT16\020\020\022\020\n\014FLOAT8E4M3FN\020\021\022\022\n\016FLOAT" +
                "8E4M3FNUZ\020\022\022\016\n\nFLOAT8E5M2\020\023\022\022\n\016FLOAT8E5M" +
                "2FNUZ\020\024\022\t\n\005UINT4\020\025\022\010\n\004INT4\020\026\022\016\n\nFLOAT4E2" +
                "M1\020\027\")\n\014DataLocation\022\013\n\007DEFAULT\020\000\022\014\n\010EXT" +
                "ERNAL\020\001\"h\n\021SparseTensorProto\022!\n\006values\030\001" +
                " \001(\0132\021.org.brain4j.core.importing.onnx.TensorProto\022\"\n\007indices\030\002 \001(\013" +
                "2\021.org.brain4j.core.importing.onnx.TensorProto\022\014\n\004dims\030\003 \003(\003\"\225\001\n\020Te" +
                "nsorShapeProto\022-\n\003dim\030\001 \003(\0132 .org.brain4j.core.importing.onnx.Tenso" +
                "rShapeProto.Dimension\032R\n\tDimension\022\023\n\tdi" +
                "m_value\030\001 \001(\003H\000\022\023\n\tdim_param\030\002 \001(\tH\000\022\022\n\n" +
                "denotation\030\003 \001(\tB\007\n\005value\"\316\004\n\tTypeProto\022" +
                "-\n\013tensor_type\030\001 \001(\0132\026.org.brain4j.core.importing.onnx.TypeProto.Te" +
                "nsorH\000\0221\n\rsequence_type\030\004 \001(\0132\030.org.brain4j.core.importing.onnx.Typ" +
                "eProto.SequenceH\000\022\'\n\010map_type\030\005 \001(\0132\023.on" +
                "nx.TypeProto.MapH\000\0221\n\roptional_type\030\t \001(" +
                "\0132\030.org.brain4j.core.importing.onnx.TypeProto.OptionalH\000\022:\n\022sparse_" +
                "tensor_type\030\010 \001(\0132\034.org.brain4j.core.importing.onnx.TypeProto.Spars" +
                "eTensorH\000\022\022\n\ndenotation\030\006 \001(\t\032B\n\006Tensor\022" +
                "\021\n\telem_type\030\001 \001(\005\022%\n\005shape\030\002 \001(\0132\026.onnx" +
                ".TensorShapeProto\032.\n\010Sequence\022\"\n\telem_ty" +
                "pe\030\001 \001(\0132\017.org.brain4j.core.importing.onnx.TypeProto\032<\n\003Map\022\020\n\010key_" +
                "type\030\001 \001(\005\022#\n\nvalue_type\030\002 \001(\0132\017.org.brain4j.core.importing.onnx.Ty" +
                "peProto\032.\n\010Optional\022\"\n\telem_type\030\001 \001(\0132\017" +
                ".org.brain4j.core.importing.onnx.TypeProto\032H\n\014SparseTensor\022\021\n\telem_" +
                "type\030\001 \001(\005\022%\n\005shape\030\002 \001(\0132\026.org.brain4j.core.importing.onnx.TensorS" +
                "hapeProtoB\007\n\005value\"5\n\022OperatorSetIdProto" +
                "\022\016\n\006domain\030\001 \001(\t\022\017\n\007version\030\002 \001(\003\"\206\003\n\rFu" +
                "nctionProto\022\014\n\004name\030\001 \001(\t\022\r\n\005input\030\004 \003(\t" +
                "\022\016\n\006output\030\005 \003(\t\022\021\n\tattribute\030\006 \003(\t\022-\n\017a" +
                "ttribute_proto\030\013 \003(\0132\024.org.brain4j.core.importing.onnx.AttributePro" +
                "to\022\035\n\004node\030\007 \003(\0132\017.org.brain4j.core.importing.onnx.NodeProto\022\022\n\ndoc" +
                "_string\030\010 \001(\t\022.\n\014opset_import\030\t \003(\0132\030.on" +
                "nx.OperatorSetIdProto\022\016\n\006domain\030\n \001(\t\022\020\n" +
                "\010overload\030\r \001(\t\022(\n\nvalue_info\030\014 \003(\0132\024.on" +
                "nx.ValueInfoProto\0224\n\016metadata_props\030\016 \003(" +
                "\0132\034.org.brain4j.core.importing.onnx.StringStringEntryProtoJ\004\010\002\020\003J\004\010" +
                "\003\020\004R\rsince_versionR\006status*\261\002\n\007Version\022\022" +
                "\n\016_START_VERSION\020\000\022\031\n\025IR_VERSION_2017_10" +
                "_10\020\001\022\031\n\025IR_VERSION_2017_10_30\020\002\022\030\n\024IR_V" +
                "ERSION_2017_11_3\020\003\022\030\n\024IR_VERSION_2019_1_" +
                "22\020\004\022\030\n\024IR_VERSION_2019_3_18\020\005\022\030\n\024IR_VER" +
                "SION_2019_9_19\020\006\022\027\n\023IR_VERSION_2020_5_8\020" +
                "\007\022\030\n\024IR_VERSION_2021_7_30\020\010\022\027\n\023IR_VERSIO" +
                "N_2023_5_5\020\t\022\030\n\024IR_VERSION_2024_3_25\020\n\022\016" +
                "\n\nIR_VERSION\020\013*.\n\016OperatorStatus\022\020\n\014EXPE" +
                "RIMENTAL\020\000\022\n\n\006STABLE\020\001B\002H\003"
        };
        descriptor = com.google.protobuf.Descriptors.FileDescriptor
            .internalBuildGeneratedFileFrom(descriptorData,
                new com.google.protobuf.Descriptors.FileDescriptor[] {
                });
        internal_static_onnx_AttributeProto_descriptor =
            getDescriptor().getMessageTypes().get(0);
        internal_static_onnx_AttributeProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_AttributeProto_descriptor,
            new java.lang.String[] { "Name", "RefAttrName", "DocString", "Type", "F", "I", "S", "T", "G", "SparseTensor", "Tp", "Floats", "Ints", "Strings", "Tensors", "Graphs", "SparseTensors", "TypeProtos", });
        internal_static_onnx_ValueInfoProto_descriptor =
            getDescriptor().getMessageTypes().get(1);
        internal_static_onnx_ValueInfoProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_ValueInfoProto_descriptor,
            new java.lang.String[] { "Name", "Type", "DocString", "MetadataProps", });
        internal_static_onnx_NodeProto_descriptor =
            getDescriptor().getMessageTypes().get(2);
        internal_static_onnx_NodeProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_NodeProto_descriptor,
            new java.lang.String[] { "Input", "Output", "Name", "OpType", "Domain", "Overload", "Attribute", "DocString", "MetadataProps", "DeviceConfigurations", });
        internal_static_onnx_IntIntListEntryProto_descriptor =
            getDescriptor().getMessageTypes().get(3);
        internal_static_onnx_IntIntListEntryProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_IntIntListEntryProto_descriptor,
            new java.lang.String[] { "Key", "Value", });
        internal_static_onnx_NodeDeviceConfigurationProto_descriptor =
            getDescriptor().getMessageTypes().get(4);
        internal_static_onnx_NodeDeviceConfigurationProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_NodeDeviceConfigurationProto_descriptor,
            new java.lang.String[] { "ConfigurationId", "ShardingSpec", "PipelineStage", });
        internal_static_onnx_ShardingSpecProto_descriptor =
            getDescriptor().getMessageTypes().get(5);
        internal_static_onnx_ShardingSpecProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_ShardingSpecProto_descriptor,
            new java.lang.String[] { "TensorName", "Device", "IndexToDeviceGroupMap", "ShardedDim", });
        internal_static_onnx_ShardedDimProto_descriptor =
            getDescriptor().getMessageTypes().get(6);
        internal_static_onnx_ShardedDimProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_ShardedDimProto_descriptor,
            new java.lang.String[] { "Axis", "SimpleSharding", });
        internal_static_onnx_SimpleShardedDimProto_descriptor =
            getDescriptor().getMessageTypes().get(7);
        internal_static_onnx_SimpleShardedDimProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_SimpleShardedDimProto_descriptor,
            new java.lang.String[] { "DimValue", "DimParam", "NumShards", "Dim", });
        internal_static_onnx_TrainingInfoProto_descriptor =
            getDescriptor().getMessageTypes().get(8);
        internal_static_onnx_TrainingInfoProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TrainingInfoProto_descriptor,
            new java.lang.String[] { "Initialization", "Algorithm", "InitializationBinding", "UpdateBinding", });
        internal_static_onnx_ModelProto_descriptor =
            getDescriptor().getMessageTypes().get(9);
        internal_static_onnx_ModelProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_ModelProto_descriptor,
            new java.lang.String[] { "IrVersion", "OpsetImport", "ProducerName", "ProducerVersion", "Domain", "ModelVersion", "DocString", "Graph", "MetadataProps", "TrainingInfo", "Functions", "Configuration", });
        internal_static_onnx_DeviceConfigurationProto_descriptor =
            getDescriptor().getMessageTypes().get(10);
        internal_static_onnx_DeviceConfigurationProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_DeviceConfigurationProto_descriptor,
            new java.lang.String[] { "Name", "NumDevices", "Device", });
        internal_static_onnx_StringStringEntryProto_descriptor =
            getDescriptor().getMessageTypes().get(11);
        internal_static_onnx_StringStringEntryProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_StringStringEntryProto_descriptor,
            new java.lang.String[] { "Key", "Value", });
        internal_static_onnx_TensorAnnotation_descriptor =
            getDescriptor().getMessageTypes().get(12);
        internal_static_onnx_TensorAnnotation_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TensorAnnotation_descriptor,
            new java.lang.String[] { "TensorName", "QuantParameterTensorNames", });
        internal_static_onnx_GraphProto_descriptor =
            getDescriptor().getMessageTypes().get(13);
        internal_static_onnx_GraphProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_GraphProto_descriptor,
            new java.lang.String[] { "Node", "Name", "Initializer", "SparseInitializer", "DocString", "Input", "Output", "ValueInfo", "QuantizationAnnotation", "MetadataProps", });
        internal_static_onnx_TensorProto_descriptor =
            getDescriptor().getMessageTypes().get(14);
        internal_static_onnx_TensorProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TensorProto_descriptor,
            new java.lang.String[] { "Dims", "DataType", "Segment", "FloatData", "Int32Data", "StringData", "Int64Data", "Name", "DocString", "RawData", "ExternalData", "DataLocation", "DoubleData", "Uint64Data", "MetadataProps", });
        internal_static_onnx_TensorProto_Segment_descriptor =
            internal_static_onnx_TensorProto_descriptor.getNestedTypes().get(0);
        internal_static_onnx_TensorProto_Segment_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TensorProto_Segment_descriptor,
            new java.lang.String[] { "Begin", "End", });
        internal_static_onnx_SparseTensorProto_descriptor =
            getDescriptor().getMessageTypes().get(15);
        internal_static_onnx_SparseTensorProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_SparseTensorProto_descriptor,
            new java.lang.String[] { "Values", "Indices", "Dims", });
        internal_static_onnx_TensorShapeProto_descriptor =
            getDescriptor().getMessageTypes().get(16);
        internal_static_onnx_TensorShapeProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TensorShapeProto_descriptor,
            new java.lang.String[] { "Dim", });
        internal_static_onnx_TensorShapeProto_Dimension_descriptor =
            internal_static_onnx_TensorShapeProto_descriptor.getNestedTypes().get(0);
        internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TensorShapeProto_Dimension_descriptor,
            new java.lang.String[] { "DimValue", "DimParam", "Denotation", "Value", });
        internal_static_onnx_TypeProto_descriptor =
            getDescriptor().getMessageTypes().get(17);
        internal_static_onnx_TypeProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TypeProto_descriptor,
            new java.lang.String[] { "TensorType", "SequenceType", "MapType", "OptionalType", "SparseTensorType", "Denotation", "Value", });
        internal_static_onnx_TypeProto_Tensor_descriptor =
            internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(0);
        internal_static_onnx_TypeProto_Tensor_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TypeProto_Tensor_descriptor,
            new java.lang.String[] { "ElemType", "Shape", });
        internal_static_onnx_TypeProto_Sequence_descriptor =
            internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(1);
        internal_static_onnx_TypeProto_Sequence_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TypeProto_Sequence_descriptor,
            new java.lang.String[] { "ElemType", });
        internal_static_onnx_TypeProto_Map_descriptor =
            internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(2);
        internal_static_onnx_TypeProto_Map_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TypeProto_Map_descriptor,
            new java.lang.String[] { "KeyType", "ValueType", });
        internal_static_onnx_TypeProto_Optional_descriptor =
            internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(3);
        internal_static_onnx_TypeProto_Optional_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TypeProto_Optional_descriptor,
            new java.lang.String[] { "ElemType", });
        internal_static_onnx_TypeProto_SparseTensor_descriptor =
            internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(4);
        internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_TypeProto_SparseTensor_descriptor,
            new java.lang.String[] { "ElemType", "Shape", });
        internal_static_onnx_OperatorSetIdProto_descriptor =
            getDescriptor().getMessageTypes().get(18);
        internal_static_onnx_OperatorSetIdProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_OperatorSetIdProto_descriptor,
            new java.lang.String[] { "Domain", "Version", });
        internal_static_onnx_FunctionProto_descriptor =
            getDescriptor().getMessageTypes().get(19);
        internal_static_onnx_FunctionProto_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
            internal_static_onnx_FunctionProto_descriptor,
            new java.lang.String[] { "Name", "Input", "Output", "Attribute", "AttributeProto", "Node", "DocString", "OpsetImport", "Domain", "Overload", "ValueInfo", "MetadataProps", });
        descriptor.resolveAllFeaturesImmutable();
    }
    
    // @@protoc_insertion_point(outer_class_scope)
}
